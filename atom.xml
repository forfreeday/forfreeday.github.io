<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思想家</title>
  
  <subtitle>有限的时间，编写先限的可能</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liukay.com/"/>
  <updated>2021-11-16T06:09:05.428Z</updated>
  <id>https://liukay.com/</id>
  
  <author>
    <name>咪雅先森</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go 函数多个返回值</title>
    <link href="https://liukay.com/posts/b9c503bd.html"/>
    <id>https://liukay.com/posts/b9c503bd.html</id>
    <published>2021-11-16T06:03:51.000Z</published>
    <updated>2021-11-16T06:09:05.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>结构和别的语言略有不同。<br>go 的特点，返回可以有多个返回值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单个返回值方法"><a href="#单个返回值方法" class="headerlink" title="单个返回值方法"></a>单个返回值方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个返回值方法"><a href="#两个返回值方法" class="headerlink" title="两个返回值方法"></a>两个返回值方法</h2><p>实际上可以返回多个值，这里演示，所以只写两个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;结构和别的语言略有不同。&lt;br&gt;go 的特点，返回可以有多个返回值。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
      <category term="语法" scheme="https://liukay.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="函数" scheme="https://liukay.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>go 函数介绍</title>
    <link href="https://liukay.com/posts/b9c503bd.html"/>
    <id>https://liukay.com/posts/b9c503bd.html</id>
    <published>2021-11-16T02:13:52.000Z</published>
    <updated>2021-11-16T06:43:14.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数是基本的代码块。<br>Go是编译型语言，函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的底部，类似于C语言的习惯。</p><p>Go 语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>func：函数声明关键字，函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表。</li><li>return_types：返回类型，函数返回一列值。<br>return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><h2 id="Go-里面拥三种类型的函数"><a href="#Go-里面拥三种类型的函数" class="headerlink" title="Go 里面拥三种类型的函数"></a>Go 里面拥三种类型的函数</h2><ul><li>普通函数</li><li>匿名函数或者lambda函数</li><li>方法（Methods）<br>说下方法，确实有这种类型。go是为了兼容面向对象的特性，实现了方法这种特性。</li></ul><h2 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getTest()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带入参返回值"><a href="#带入参返回值" class="headerlink" title="带入参返回值"></a>带入参返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义&quot;&gt;&lt;/a&gt;函数定义&lt;/h2&gt;&lt;p&gt;函数是基本的代码块。&lt;br&gt;Go是编译型语言，函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文
      
    
    </summary>
    
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go defer关键字</title>
    <link href="https://liukay.com/posts/20130.html"/>
    <id>https://liukay.com/posts/20130.html</id>
    <published>2021-11-05T03:15:34.000Z</published>
    <updated>2021-11-05T03:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="defer-延时机制"><a href="#defer-延时机制" class="headerlink" title="defer 延时机制"></a>defer 延时机制</h1><p>在函数执行过后执行。<br>作用：在函数执行过后及时释放资源。<br>最佳的实践在于，做一些执行后的操作，释放资源，比如：数据库连接、文件句柄、锁等。</p><p>在 golang 中的通常做法是，创建资源后，立即使用 defer 进行释放。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><p>原理是使用了 defer 关键字后，会将修饰语句加入到一个栈中，这里称为 defer 栈中，直到程序执行后，最后执行，当函数执行完毕后，在从 defer 栈中，依次从栈顶取出语句执行，先入后出的机制。<br>defer对执行流程的改变，只是在本函数内有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;n1=%d, n2=%d\n&quot;</span>,n1, n2)</span><br><span class="line">  res := n1 + n2</span><br><span class="line">  <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;res1=%d\n&quot;</span>, res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  res := sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;res2=%d&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>res1=30<br>n1=10, n2=20<br>res2=30</p></blockquote><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><p>defer 拷贝入栈后，值是拷贝进去的，后续的操作，不影响已拷贝的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n2=&quot;</span>, n2)</span><br><span class="line">  n1++</span><br><span class="line">  n2++</span><br><span class="line">  res := n1 + n2</span><br><span class="line">  <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;res1=%d\n&quot;</span>, res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  res2 := sum2(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;res2=%d&quot;</span>, res2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>res1=32<br>n2= 20<br>n1= 10<br>res2=32</p></blockquote><h2 id="3-defer-的意义"><a href="#3-defer-的意义" class="headerlink" title="3.defer 的意义"></a>3.defer 的意义</h2><p>在于可以及时的释放函数创建的资源。很多时间在开发中，打开了资源后，就忘了关闭，defer 的机制可以让程序员在开发时，使用资源后立即加上关闭操作，也不影响后续的代码执行。类似于 java 的<code>finally</code>的作用，不同在于语法上defer可以写在前面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;defer-延时机制&quot;&gt;&lt;a href=&quot;#defer-延时机制&quot; class=&quot;headerlink&quot; title=&quot;defer 延时机制&quot;&gt;&lt;/a&gt;defer 延时机制&lt;/h1&gt;&lt;p&gt;在函数执行过后执行。&lt;br&gt;作用：在函数执行过后及时释放资源。&lt;br&gt;最佳的
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="golang" scheme="https://liukay.com/tags/golang/"/>
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
      <category term="defer" scheme="https://liukay.com/tags/defer/"/>
    
      <category term="关键字" scheme="https://liukay.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>go 空白标识符</title>
    <link href="https://liukay.com/posts/29773.html"/>
    <id>https://liukay.com/posts/29773.html</id>
    <published>2021-11-05T03:08:40.000Z</published>
    <updated>2021-11-05T03:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用于抛弃不需要接收的变量值</p></blockquote><h1 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符 _"></a>空白标识符 _</h1><p>作用：在接收多个变量返回时，抛弃不需要的返回值<br><code>_</code> 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _,numb,strs := numbers() <span class="comment">//只获取函数返回值的后两个</span></span><br><span class="line">  fmt.Println(numb, strs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个可以返回多个值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  a , b , c := <span class="number">1</span> , <span class="number">2</span> , <span class="string">&quot;str&quot;</span></span><br><span class="line">  <span class="keyword">return</span> a,b,c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>2 str</p><p>a 因为使用 _ 被抛弃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;用于抛弃不需要接收的变量值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;空白标识符&quot;&gt;&lt;a href=&quot;#空白标识符&quot; class=&quot;headerlink&quot; title=&quot;空白标识符 _&quot;&gt;&lt;/a&gt;空白标识符 _&lt;/h1&gt;&lt;p&gt;作用：在接收
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
      <category term="语法" scheme="https://liukay.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="空白标识符" scheme="https://liukay.com/tags/%E7%A9%BA%E7%99%BD%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint 共识源码分析</title>
    <link href="https://liukay.com/posts/4334.html"/>
    <id>https://liukay.com/posts/4334.html</id>
    <published>2021-11-03T07:59:17.000Z</published>
    <updated>2021-11-03T07:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Tendermint的共识算法可以看成是POS+BFT，Tendermint在进行BFT共识算法确认区块前，首先使用POS算法从Validators中选举出Proposer。<br>然后由Proposer进行提案，最后使用BFT算法生成区块。Tendermint 的共识协议使用的gossip协议。</p><p>另外，源码分析部分由于代码篇幅太长，会省略部分源码，不影响阅读。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Tendermint 共识网络中有两个重要角色</p><ol><li><strong>Validator</strong>: 网络的参与者，也是区块的验证者（预先配置的网络中的一般验证者账户们）</li><li><strong>Proposer</strong>: 从validator中选举出一个节点成为出块人（选举出的出块人），选举不需要网络通信，这点后面从源码中说明。</li></ol><h2 id="共识5个阶段"><a href="#共识5个阶段" class="headerlink" title="共识5个阶段"></a>共识5个阶段</h2><ol><li>NewHeight</li><li>propose</li><li>prevote</li><li>precommit</li><li>commit</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                        +--------------------------------------+</span><br><span class="line">                        v                                      |(Wait til `CommmitTime+timeoutCommit`)</span><br><span class="line">                   +-----------+                         +-----+-----+</span><br><span class="line">      +----------&gt; |  Propose  +--------------+          | NewHeight |</span><br><span class="line">      |            +-----------+              |          +-----------+</span><br><span class="line">      |                                       |                ^</span><br><span class="line">      |(Else, after timeoutPrecommit)         v                |</span><br><span class="line">+-----+-----+                           +-----------+          |</span><br><span class="line">| Precommit |  &lt;------------------------+  Prevote  |          |</span><br><span class="line">+-----+-----+                           +-----------+          |</span><br><span class="line">      |(When +2/3 Precommits for block found)                  |</span><br><span class="line">      v                                                        |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|  Commit                                                            |</span><br><span class="line">|                                                                    |</span><br><span class="line">|  * Set CommitTime = now;                                           |</span><br><span class="line">|  * Wait for block, then stage/save/commit block;                   |</span><br><span class="line">+--------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>阶段：Propose阶段、Prevote阶段、Precommit阶段<br>投票种类：prevote、precommit、commit</p><h2 id="round-based-协议"><a href="#round-based-协议" class="headerlink" title="round-based 协议"></a>round-based 协议</h2><p>整个Tendermint区块链网络需要通过Round-based协议来决定下一个区块，在区块链中共识的直接目的就是确定下一个区块内容、链接下一个区块</p><p>round-based 协议是一个状态机，主要有:</p><blockquote><p>NewHeigh -&gt; Propose -&gt; Prevote -&gt; Precommit -&gt; Commit</p></blockquote><p>上述每个状态都被称为一个 Step。首尾的 NewHeigh 和 Commit ，这两个 Steps 被称为特殊的 Step。</p><h3 id="Round"><a href="#Round" class="headerlink" title="Round"></a>Round</h3><p>而中间循环三个 Steps则被称为一个 <code>Round</code>(<code>Propose</code> -&gt; <code>Prevote</code> -&gt; <code>Precommit</code>)，是<code>共识阶段</code>，也是算法的核心原理所在。</p><p>一个块的最终提交（Commit）可能需要多个 Round 过程，这是因为有许多原因可能会导致当前 Round 不成功（比如出块节点 Offline，提出的块是无效块，收到的 Prevote 或者 Precommit 票数不够 +2/3 等等）。</p><h3 id="共识失败怎么办"><a href="#共识失败怎么办" class="headerlink" title="共识失败怎么办"></a>共识失败怎么办</h3><p>如果出块节点 Offline，提出的块是无效块，收到的 Prevote 或者 Precommit 票数不够 +2/3<br>出现这些情况的话，解决方案就是移步到下一轮，或者增加 timeout 时间。</p><h3 id="共识流程"><a href="#共识流程" class="headerlink" title="共识流程"></a>共识流程</h3><ol><li><strong>NewHeight 阶段：</strong>当区块链达到一个新的高度时进入 NewHeight 阶段。</li><li><strong>propose 阶段：</strong>接下来 Propose 阶段会提交一个 proposal ，</li><li><strong>prevote 阶段：</strong>prevote 阶段会对收到的 proposal 进行 prevote 投票。</li><li><strong>precommit 阶段：</strong>在 precommit 阶段收集到+⅔ prevote 投票后，对 block 进行 precommit 投票。</li><li><strong>commit阶段：</strong><ul><li>如果收集到+⅔ precommit 投票后则进入 commit 阶段，</li><li>如果没有收集到+⅔ precommit 投票，会再次进入 propose 段。<br>在共识阶段期间如果收到+⅔ commit 投票那么直接进入 commit 阶段。<br>以上就是算法运行的整体过程，接下来分阶段来阐述各个阶段。</li></ul></li></ol><h2 id="Round0-首轮共识分析"><a href="#Round0-首轮共识分析" class="headerlink" title="Round0 首轮共识分析"></a>Round0 首轮共识分析</h2><p>服务刚启动时，节点进入第一轮状态共识，Tendenmint 称之为<code>Round0</code>。<br>启动流程如下</p><p><img src="/posts/4334/启动首论共识.png" alt="启动首论共识"></p><h3 id="Round0-是什么做用？做了哪些事"><a href="#Round0-是什么做用？做了哪些事" class="headerlink" title="Round0 是什么做用？做了哪些事"></a>Round0 是什么做用？做了哪些事</h3><p>主要是通过监听消息，来处理对应消息类型携带的事件。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>OnStart</li><li>receiveRoutine 启动接收程序<br>go cs.receiveRoutine</li><li>scheduleRound0: 注意，这个发送的是内部消息，不是 peer消息</li><li>scheduleTimeout 发送<code>round0</code> 的事件，事件类型：<code>receiveRoutine</code></li><li>receiveRoutine: 处理事件</li></ol><h4 id="共识核心方法说明"><a href="#共识核心方法说明" class="headerlink" title="共识核心方法说明"></a>共识核心方法说明</h4><p>receiveRoutine 核心方法<br>这个函数就比较重要了，它处理了可能导致状态转换的消息。<br>其中超时消息、完成一个提案和超过2/3的投票都会导致状态转换。<br>通过监听各种 Queue 的消息类型来处理</p><p>state.go 源码分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnStart loads the latest state via the WAL, and starts the timeout and</span></span><br><span class="line"><span class="comment">// receive routines.</span></span><br><span class="line"><span class="comment">// OnStart通过WAL加载最新状态，并启动超时和接收程序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// We may set the WAL in testing before calling Start, so only OpenWAL if its</span></span><br><span class="line">    <span class="comment">// still the nilWAL.</span></span><br><span class="line">    <span class="comment">// 在测试中，我们可能会在调用Start之前设置WAL，所以只有在其仍然是nilWAL的情况下才会打开WAL。</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := cs.wal.(nilWAL); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> err := cs.loadWalFile(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may have lost some votes if the process crashed reload from consensus</span></span><br><span class="line">    <span class="comment">// log to catchup.</span></span><br><span class="line">    <span class="comment">// 如果从共识日志到追赶的过程中崩溃重新加载，我们可能会失去一些票数。</span></span><br><span class="line">    <span class="keyword">if</span> cs.doWALCatchup &#123;</span><br><span class="line">        repairAttempted := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    LOOP:</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            err := cs.catchupReplay(cs.Height)</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> !IsDataCorruptionError(err):</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;error on catchup replay; proceeding to start state anyway&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> repairAttempted:</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cs.Logger.Error(<span class="string">&quot;the WAL file is corrupted; attempting repair&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1) prep work</span></span><br><span class="line">            <span class="keyword">if</span> err := cs.wal.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            repairAttempted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2) backup original WAL file</span></span><br><span class="line">            corruptedFile := fmt.Sprintf(<span class="string">&quot;%s.CORRUPTED&quot;</span>, cs.config.WalFile())</span><br><span class="line">            <span class="keyword">if</span> err := tmos.CopyFile(cs.config.WalFile(), corruptedFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cs.Logger.Debug(<span class="string">&quot;backed up WAL file&quot;</span>, <span class="string">&quot;src&quot;</span>, cs.config.WalFile(), <span class="string">&quot;dst&quot;</span>, corruptedFile)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3) try to repair (WAL file will be overwritten!)</span></span><br><span class="line">            <span class="keyword">if</span> err := repairWalFile(corruptedFile, cs.config.WalFile()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;the WAL repair failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cs.Logger.Info(<span class="string">&quot;successful WAL repair&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reload WAL file</span></span><br><span class="line">            <span class="keyword">if</span> err := cs.loadWalFile(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventSwitch 只监听 EventNewRoundStep、EventValidBlock和EventVote 这三种事件</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.evsw.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need the timeoutRoutine for replay so</span></span><br><span class="line">    <span class="comment">// we don&#x27;t block on the tick chan.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we will get a build up of garbage go routines</span></span><br><span class="line">    <span class="comment">// firing on the tockChan until the receiveRoutine is started</span></span><br><span class="line">    <span class="comment">// to deal with them (by that point, at most one will be valid)</span></span><br><span class="line">    <span class="comment">// 我们需要重放的timeoutRoutine，这样我们就不会在tick chan上阻塞。</span></span><br><span class="line">    <span class="comment">// 注意：我们将得到大量的垃圾程序</span></span><br><span class="line">    <span class="comment">// 直到receiveRoutine开始处理它们（到那时，最多只有一个是有效的）来处理它们（到那时，最多只有一个是有效的）。</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.timeoutTicker.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Double Signing Risk Reduction</span></span><br><span class="line">    <span class="comment">// 检查双重验签</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.checkDoubleSigningRisk(cs.Height); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now start the receiveRoutine</span></span><br><span class="line">    <span class="comment">// 启动接收程序</span></span><br><span class="line">    <span class="keyword">go</span> cs.receiveRoutine(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedule the first round!</span></span><br><span class="line">    <span class="comment">// use GetRoundState so we don&#x27;t race the receiveRoutine for access</span></span><br><span class="line">    <span class="comment">// 安排第一轮!</span></span><br><span class="line">    <span class="comment">// 使用GetRoundState，这样我们就不会和receiveRoutine争夺访问权了。</span></span><br><span class="line">    cs.scheduleRound0(cs.GetRoundState())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送内部消息-cs-scheduleRound0"><a href="#发送内部消息-cs-scheduleRound0" class="headerlink" title="发送内部消息 cs.scheduleRound0"></a>发送内部消息 cs.scheduleRound0</h2><p>scheduleRound0 的作用是将消息发送到内部的 chan 当中，receiveRoutine 负责监听不同类型事件，会监听到这个事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enterNewRound(height, 0) at cs.StartTime.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">scheduleRound0</span><span class="params">(rs *cstypes.RoundState)</span></span> &#123;</span><br><span class="line">    <span class="comment">// cs.Logger.Info(&quot;scheduleRound0&quot;, &quot;now&quot;, tmtime.Now(), &quot;startTime&quot;, cs.StartTime)</span></span><br><span class="line">    sleepDuration := rs.StartTime.Sub(tmtime.Now())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一轮是发送了 cstypes.RoundStepNewHeight 事件类型</span></span><br><span class="line">    cs.scheduleTimeout(sleepDuration, rs.Height, <span class="number">0</span>, cstypes.RoundStepNewHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送内部消息，最终将消息发送到 chan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduleTimeout schedules a new timeout by sending on the internal tickChan.</span></span><br><span class="line"><span class="comment">// The timeoutRoutine is always available to read from tickChan, so this won&#x27;t block.</span></span><br><span class="line"><span class="comment">// The scheduling may fail if the timeoutRoutine has already scheduled a timeout for a later height/round/step.</span></span><br><span class="line"><span class="comment">// ScheduleTimeout通过在内部tickChan上发送来安排一个新的超时。</span></span><br><span class="line"><span class="comment">// timeoutRoutine总是可以从tickChan中读取，所以这不会阻塞。</span></span><br><span class="line"><span class="comment">// 如果timeoutRoutine已经为以后的高度/轮次/步长安排了一个超时，则调度可能会失败。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timeoutTicker)</span> <span class="title">ScheduleTimeout</span><span class="params">(ti timeoutInfo)</span></span> &#123;</span><br><span class="line">    t.tickChan &lt;- ti</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="核心处理逻辑"><a href="#核心处理逻辑" class="headerlink" title="核心处理逻辑"></a>核心处理逻辑</h2><h3 id="主要是-receiveRoutine-处理"><a href="#主要是-receiveRoutine-处理" class="headerlink" title="主要是 receiveRoutine 处理"></a>主要是 receiveRoutine 处理</h3><p>receiveRoutine 处理消息类型</p><ol><li>peerMsgQueue 来自节点的消息</li><li>internalMsgQueue 内部消息</li><li>timeoutTicker 超时的消息<br>timeoutTicker 这个消息，就是被上面流程中<code>scheduleRound0</code>发出的消息</li></ol><h3 id="receiveRoutine-处理流程"><a href="#receiveRoutine-处理流程" class="headerlink" title="receiveRoutine 处理流程"></a>receiveRoutine 处理流程</h3><ol><li>根据类型选把处理器<br>cs.timeoutTicker.Chan()</li><li>handleTimeout 处理<br>处理具体类型</li></ol><h3 id="handleTimeout-处理具体事件类型"><a href="#handleTimeout-处理具体事件类型" class="headerlink" title="handleTimeout 处理具体事件类型"></a>handleTimeout 处理具体事件类型</h3><ol><li>监听<code>RoundStepNewHeight</code>事件<br>case cstypes.RoundStepNewHeight:</li><li>进入 Round 流程<br>这个就重点了，概据官方文档说明，每一次共识都有 5 个步骤，这个是第一步。<br>cs.enterNewRound(ti.Height, 0)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">// the main go routines</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// receiveRoutine handles messages which may cause state transitions.</span></span><br><span class="line"><span class="comment">// it&#x27;s argument (n) is the number of messages to process before exiting - use 0 to run forever</span></span><br><span class="line"><span class="comment">// It keeps the RoundState and is the only thing that updates it.</span></span><br><span class="line"><span class="comment">// Updates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.</span></span><br><span class="line"><span class="comment">// State must be locked before any internal state is updated.</span></span><br><span class="line"><span class="comment">// receiveRoutine处理可能导致状态转换的消息。</span></span><br><span class="line"><span class="comment">// 它的参数(n)是退出前要处理的消息的数量--用0表示永远运行。</span></span><br><span class="line"><span class="comment">// 它保持RoundState，并且是唯一能更新它的东西。</span></span><br><span class="line"><span class="comment">// 更新（状态转换）发生在超时、完整提案和2/3多数的情况下。</span></span><br><span class="line"><span class="comment">// 在任何内部状态被更新之前，状态必须被锁定。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">receiveRoutine</span><span class="params">(maxSteps <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 拿到当前链状态</span></span><br><span class="line">        rs := cs.RoundState</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这个是接收的 reactor 的消息</span></span><br><span class="line">        <span class="keyword">var</span> mi msgInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理三种类型的消息</span></span><br><span class="line">        <span class="comment">// 1.peerMsgQueue 来自节点的消息</span></span><br><span class="line">        <span class="comment">// 2.internalMsgQueue 内部消息</span></span><br><span class="line">        <span class="comment">// 3.timeoutTicker 超时的消息</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-cs.txNotifier.TxsAvailable():</span><br><span class="line">            cs.handleTxsAvailable()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// peer 节点消息</span></span><br><span class="line">        <span class="keyword">case</span> mi = &lt;-cs.peerMsgQueue:</span><br><span class="line">            <span class="keyword">if</span> err := cs.wal.Write(mi); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;failed writing to WAL&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// handles proposals, block parts, votes</span></span><br><span class="line">            <span class="comment">// may generate internal events (votes, complete proposals, 2/3 majorities)</span></span><br><span class="line">            cs.handleMsg(mi)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听内部队列消息</span></span><br><span class="line">        <span class="keyword">case</span> mi = &lt;-cs.internalMsgQueue:</span><br><span class="line">            err := cs.wal.WriteSync(mi) <span class="comment">// <span class="doctag">NOTE:</span> fsync</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(</span><br><span class="line">                    <span class="string">&quot;failed to write %v msg to consensus WAL due to %v; check your file system and restart the node&quot;</span>,</span><br><span class="line">                    mi, err,</span><br><span class="line">                ))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// handles proposals, block parts, votes</span></span><br><span class="line">            <span class="comment">// 核心的状态逻辑处理，处理 proposals, block parts, votes</span></span><br><span class="line">            cs.handleMsg(mi)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这个监听，ScheduleTimeout 的 channel</span></span><br><span class="line">        <span class="keyword">case</span> ti := &lt;-cs.timeoutTicker.Chan(): <span class="comment">// tockChan:</span></span><br><span class="line">            <span class="keyword">if</span> err := cs.wal.Write(ti); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;failed writing to WAL&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the timeout is relevant to the rs</span></span><br><span class="line">            <span class="comment">// go to the next step</span></span><br><span class="line">            cs.handleTimeout(ti, rs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-cs.Quit():</span><br><span class="line">            onExit(cs)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="handleTimeout-分析"><a href="#handleTimeout-分析" class="headerlink" title="handleTimeout 分析"></a>handleTimeout 分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入新一轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">enterNewRound</span><span class="params">(height <span class="keyword">int64</span>, round <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    logger := cs.Logger.With(<span class="string">&quot;height&quot;</span>, height, <span class="string">&quot;round&quot;</span>, round)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cs.Height != height || round &lt; cs.Round || (cs.Round == round &amp;&amp; cs.Step != cstypes.RoundStepNewHeight) &#123;</span><br><span class="line">        logger.Debug(</span><br><span class="line">            <span class="string">&quot;entering new round with invalid args&quot;</span>,</span><br><span class="line">            <span class="string">&quot;current&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v/%v/%v&quot;</span>, cs.Height, cs.Round, cs.Step),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> now := tmtime.Now(); cs.StartTime.After(now) &#123;</span><br><span class="line">        logger.Debug(<span class="string">&quot;need to set a buffer and log message here for sanity&quot;</span>, <span class="string">&quot;start_time&quot;</span>, cs.StartTime, <span class="string">&quot;now&quot;</span>, now)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.Debug(<span class="string">&quot;entering new round&quot;</span>, <span class="string">&quot;current&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v/%v/%v&quot;</span>, cs.Height, cs.Round, cs.Step))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment validators if necessary</span></span><br><span class="line">    <span class="comment">// 必要时增加 validator</span></span><br><span class="line">    validators := cs.Validators</span><br><span class="line">    <span class="keyword">if</span> cs.Round &lt; round &#123;</span><br><span class="line">        validators = validators.Copy()</span><br><span class="line">        validators.IncrementProposerPriority(tmmath.SafeSubInt32(round, cs.Round))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup new round</span></span><br><span class="line">    <span class="comment">// we don&#x27;t fire newStep for this step,</span></span><br><span class="line">    <span class="comment">// but we fire an event, so update the round step first</span></span><br><span class="line">    <span class="comment">// 只是 set 值，并没有接口调用</span></span><br><span class="line">    cs.updateRoundStep(round, cstypes.RoundStepNewRound)</span><br><span class="line">    ...<span class="comment">//省略部分代码</span></span><br><span class="line">    cs.Votes.SetRound(tmmath.SafeAddInt32(round, <span class="number">1</span>)) <span class="comment">// also track next round (round+1) to allow round-skipping</span></span><br><span class="line">    cs.TriggeredTimeoutPrecommit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件？？</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.eventBus.PublishEventNewRound(cs.NewRoundEvent()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cs.Logger.Error(<span class="string">&quot;failed publishing new round&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cs.metrics.Rounds.Set(<span class="keyword">float64</span>(round))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for txs to be available in the mempool</span></span><br><span class="line">    <span class="comment">// before we enterPropose in round 0. If the last block changed the app hash,</span></span><br><span class="line">    <span class="comment">// we may need an empty &quot;proof&quot; block, and enterPropose immediately.</span></span><br><span class="line">    <span class="comment">// 进入 round0 之前，等待mempool中的txs可用。</span></span><br><span class="line">    <span class="comment">// 如果最后一个区块改变了应用程序的哈希值，我们可能需要一个空的 &quot;证明 &quot;区块，并立即输入Propose。</span></span><br><span class="line">    waitForTxs := cs.config.WaitForTxs() &amp;&amp; round == <span class="number">0</span> &amp;&amp; !cs.needProofBlock(height)</span><br><span class="line">    <span class="keyword">if</span> waitForTxs &#123;</span><br><span class="line">        <span class="keyword">if</span> cs.config.CreateEmptyBlocksInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 构建空块证明，进入下一个阶段</span></span><br><span class="line">            cs.scheduleTimeout(cs.config.CreateEmptyBlocksInterval, height, round,</span><br><span class="line">                cstypes.RoundStepNewRound)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进入 propose 阶段</span></span><br><span class="line">        cs.enterPropose(height, round)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;Tendermint的共识算法可以看成是POS+BFT，Tendermint在进行BFT共识算法确认区块前，首先使用POS算法从Valida
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/tendermint/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/Tendermint/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="BlockChain" scheme="https://liukay.com/tags/BlockChain/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="共识" scheme="https://liukay.com/tags/%E5%85%B1%E8%AF%86/"/>
    
      <category term="源码分析" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint 启动流程</title>
    <link href="https://liukay.com/posts/11173.html"/>
    <id>https://liukay.com/posts/11173.html</id>
    <published>2021-11-03T06:31:52.000Z</published>
    <updated>2021-11-03T06:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>Tendermint 的启动流程比较清析明了，各业务启动流程都在对应的实现代码，主启动流程加载所需配置，由各启动实现类启动自己对应业务，如节点启动相关在 nodeImpl，共识相关处理是 state 中进行处理。</p><p>流程大致：</p><ol><li>加载配置 <code>node.NewDefault</code></li><li>启动运行 <code>Start</code></li><li>启动相关实现的 <code>OnStart</code></li></ol><p>先看启动流程</p><p><img src="/posts/11173/服务启动.png" alt="服务启动"></p><p>启动入口代码，这里使用到了一个命令行工具：<code>cobra</code>。<br>代码位置：<code>cmd/tendermint/main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...省略部份代码</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">// Users wishing to:</span></span><br><span class="line">    <span class="comment">//    * Use an external signer for their validators</span></span><br><span class="line">    <span class="comment">//    * Supply an in-proc abci app</span></span><br><span class="line">    <span class="comment">//    * Supply a genesis doc file from another source</span></span><br><span class="line">    <span class="comment">//    * Provide their own DB implementation</span></span><br><span class="line">    <span class="comment">// can copy this file and use something other than the</span></span><br><span class="line">    <span class="comment">// node.NewDefault function</span></span><br><span class="line">    <span class="comment">// 创建节点为默认动行节点，这里是函数引用，并未执行</span></span><br><span class="line">    <span class="comment">// 在 cmd.NewRunNodeCmd 调用</span></span><br><span class="line">    nodeFunc := node.NewDefault</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create &amp; start node</span></span><br><span class="line">    <span class="comment">// 主要方法 cmd.NewRunNodeCmd</span></span><br><span class="line">    rootCmd.AddCommand(cmd.NewRunNodeCmd(nodeFunc))</span><br><span class="line"></span><br><span class="line">    cmd := cli.PrepareBaseCmd(rootCmd, <span class="string">&quot;TM&quot;</span>, os.ExpandEnv(filepath.Join(<span class="string">&quot;$HOME&quot;</span>, config.DefaultTendermintDir)))</span><br><span class="line">    <span class="keyword">if</span> err := cmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建运行节点"><a href="#创建运行节点" class="headerlink" title="创建运行节点"></a>创建运行节点</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewRunNodeCmd returns the command that allows the CLI to start a node.</span></span><br><span class="line"><span class="comment">// It can be used with a custom PrivValidator and in-process ABCI application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRunNodeCmd</span><span class="params">(nodeProvider cfg.ServiceProvider)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="comment">// 添加到命令行</span></span><br><span class="line">    cmd := &amp;cobra.Command&#123;</span><br><span class="line">        Use:     <span class="string">&quot;start&quot;</span>,</span><br><span class="line">        Aliases: []<span class="keyword">string</span>&#123;<span class="string">&quot;node&quot;</span>, <span class="string">&quot;run&quot;</span>&#125;,</span><br><span class="line">        Short:   <span class="string">&quot;Run the tendermint node&quot;</span>,</span><br><span class="line">        RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := checkGenesisHash(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里调用 node.NewDefault 这个方法实现</span></span><br><span class="line">            <span class="comment">// 创建了节点</span></span><br><span class="line">            n, err := nodeProvider(config, logger)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create node: %w&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动服务</span></span><br><span class="line">            <span class="keyword">if</span> err := n.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to start node: %w&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.Info(<span class="string">&quot;started node&quot;</span>, <span class="string">&quot;node&quot;</span>, n.String())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Stop upon receiving SIGTERM or CTRL-C.</span></span><br><span class="line">            tmos.TrapSignal(logger, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> n.IsRunning() &#123;</span><br><span class="line">                    <span class="keyword">if</span> err := n.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        logger.Error(<span class="string">&quot;unable to stop the node&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run forever.</span></span><br><span class="line">            <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddNodeFlags(cmd)</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动需的默认配置一目了然</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultConfig returns a default configuration for a Tendermint node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultConfig</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">        BaseConfig:      DefaultBaseConfig(),</span><br><span class="line">        RPC:             DefaultRPCConfig(),</span><br><span class="line">        P2P:             DefaultP2PConfig(),</span><br><span class="line">        Mempool:         DefaultMempoolConfig(),</span><br><span class="line">        StateSync:       DefaultStateSyncConfig(),</span><br><span class="line">        BlockSync:       DefaultBlockSyncConfig(),</span><br><span class="line">        Consensus:       DefaultConsensusConfig(),</span><br><span class="line">        TxIndex:         DefaultTxIndexConfig(),</span><br><span class="line">        Instrumentation: DefaultInstrumentationConfig(),</span><br><span class="line">        PrivValidator:   DefaultPrivValidatorConfig(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>启动服务接口 <code>Service</code> 主要实现类是<code>BaseService</code>。</p><p>service.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service defines a service that can be started, stopped, and reset.</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Start the service.</span></span><br><span class="line">    <span class="comment">// If it&#x27;s already started or stopped, will return an error.</span></span><br><span class="line">    <span class="comment">// If OnStart() returns an error, it&#x27;s returned by Start()</span></span><br><span class="line">    Start() error</span><br><span class="line">    OnStart() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动-node"><a href="#启动-node" class="headerlink" title="启动 node"></a>启动 node</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start implements Service by calling OnStart (if defined). An error will be</span></span><br><span class="line"><span class="comment">// returned if the service is already running or stopped. Not to start the</span></span><br><span class="line"><span class="comment">// stopped service, you need to call Reset.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *BaseService)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapUint32(&amp;bs.started, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> atomic.LoadUint32(&amp;bs.stopped) == <span class="number">1</span> &#123;</span><br><span class="line">            bs.Logger.Error(<span class="string">&quot;not starting service; already stopped&quot;</span>, <span class="string">&quot;service&quot;</span>, bs.name, <span class="string">&quot;impl&quot;</span>, bs.impl.String())</span><br><span class="line">            atomic.StoreUint32(&amp;bs.started, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ErrAlreadyStopped</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bs.Logger.Info(<span class="string">&quot;starting service&quot;</span>, <span class="string">&quot;service&quot;</span>, bs.name, <span class="string">&quot;impl&quot;</span>, bs.impl.String())</span><br><span class="line">        <span class="comment">// 启动节点。BaseService 有很多实，都实现 OnStart。</span></span><br><span class="line">        <span class="comment">// 服务启动是：node.go OnStart</span></span><br><span class="line">        <span class="comment">// 共识启动是: state.go OnStart</span></span><br><span class="line">        <span class="keyword">if</span> err := bs.impl.OnStart(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// revert flag</span></span><br><span class="line">            atomic.StoreUint32(&amp;bs.started, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs.Logger.Debug(<span class="string">&quot;not starting service; already started&quot;</span>, <span class="string">&quot;service&quot;</span>, bs.name, <span class="string">&quot;impl&quot;</span>, bs.impl.String())</span><br><span class="line">    <span class="keyword">return</span> ErrAlreadyStarted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nodeImpl 实现启动流程，总的来说还是比较清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// OnStart starts the Node. It implements service.Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *nodeImpl)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    now := tmtime.Now()</span><br><span class="line">    genTime := n.genesisDoc.GenesisTime</span><br><span class="line">    <span class="keyword">if</span> genTime.After(now) &#123;</span><br><span class="line">        n.Logger.Info(<span class="string">&quot;Genesis time is in the future. Sleeping until then...&quot;</span>, <span class="string">&quot;genTime&quot;</span>, genTime)</span><br><span class="line">        time.Sleep(genTime.Sub(now))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the RPC server before the P2P server</span></span><br><span class="line">    <span class="comment">// so we can eg. receive txs for the first block</span></span><br><span class="line">    <span class="comment">// 这里顺带说下，tendermint 的3种节点为类型</span></span><br><span class="line">    <span class="comment">//     ModeFull      = &quot;full&quot; 数据转发节点</span></span><br><span class="line">    <span class="comment">//    ModeValidator = &quot;validator&quot;  数据验证节点</span></span><br><span class="line">    <span class="comment">//    ModeSeed      = &quot;seed&quot;   用来做节点发现</span></span><br><span class="line">    <span class="keyword">if</span> n.config.RPC.ListenAddress != <span class="string">&quot;&quot;</span> &amp;&amp; n.config.Mode != config.ModeSeed &#123;</span><br><span class="line">        <span class="comment">// 启动 RPC</span></span><br><span class="line">        listeners, err := n.startRPC()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        n.rpcListeners = listeners</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n.config.Instrumentation.Prometheus &amp;&amp;</span><br><span class="line">        n.config.Instrumentation.PrometheusListenAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        n.prometheusSrv = n.startPrometheusServer(n.config.Instrumentation.PrometheusListenAddr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the transport.</span></span><br><span class="line">    addr, err := types.NewNetAddressString(n.nodeKey.ID.AddressString(n.config.P2P.ListenAddress))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := n.transport.Listen(p2p.NewEndpoint(addr)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n.isListening = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p2p 路由</span></span><br><span class="line">    <span class="keyword">if</span> err = n.router.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n.config.Mode != config.ModeSeed &#123;</span><br><span class="line">        <span class="keyword">if</span> n.config.BlockSync.Enable &#123;</span><br><span class="line">            <span class="comment">// 开启区块同步</span></span><br><span class="line">            <span class="keyword">if</span> err := n.bcReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real consensus reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.consensusReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real state sync reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.stateSyncReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real mempool reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.mempoolReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real evidence reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.evidenceReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := n.pexReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run state sync</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We shouldn&#x27;t run state sync if we already have state that has a</span></span><br><span class="line">    <span class="comment">// LastBlockHeight that is not InitialHeight</span></span><br><span class="line">    <span class="keyword">if</span> n.stateSync &#123;</span><br><span class="line">        bcR, ok := n.bcReactor.(consensus.BlockSyncReactor)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;this blockchain reactor does not support switching from state sync&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we need to get the genesis state to get parameters such as</span></span><br><span class="line">        state, err := sm.MakeGenesisState(n.genesisDoc)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to derive state: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> we may want to move these events within the respective</span></span><br><span class="line">        <span class="comment">// reactors.</span></span><br><span class="line">        <span class="comment">// At the beginning of the statesync start, we use the initialHeight as the event height</span></span><br><span class="line">        <span class="comment">// because of the statesync doesn&#x27;t have the concreate state height before fetched the snapshot.</span></span><br><span class="line">        d := types.EventDataStateSyncStatus&#123;Complete: <span class="literal">false</span>, Height: state.InitialHeight&#125;</span><br><span class="line">        <span class="keyword">if</span> err := n.eventBus.PublishEventStateSyncStatus(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            n.eventBus.Logger.Error(<span class="string">&quot;failed to emit the statesync start event&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> We shouldn&#x27;t allow state sync to silently error out without</span></span><br><span class="line">        <span class="comment">// bubbling up the error and gracefully shutting down the rest of the node</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            n.Logger.Info(<span class="string">&quot;starting state sync&quot;</span>)</span><br><span class="line">            state, err := n.stateSyncReactor.Sync(context.TODO())</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                n.Logger.Error(<span class="string">&quot;state sync failed; shutting down this node&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                <span class="comment">// stop the node</span></span><br><span class="line">                <span class="keyword">if</span> err := n.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    n.Logger.Error(<span class="string">&quot;failed to shut down node&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n.consensusReactor.SetStateSyncingMetrics(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            d := types.EventDataStateSyncStatus&#123;Complete: <span class="literal">true</span>, Height: state.LastBlockHeight&#125;</span><br><span class="line">            <span class="keyword">if</span> err := n.eventBus.PublishEventStateSyncStatus(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                n.eventBus.Logger.Error(<span class="string">&quot;failed to emit the statesync start event&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Some form of orchestrator is needed here between the state</span></span><br><span class="line">            <span class="comment">// advancing reactors to be able to control which one of the three</span></span><br><span class="line">            <span class="comment">// is running</span></span><br><span class="line">            <span class="keyword">if</span> n.config.BlockSync.Enable &#123;</span><br><span class="line">                <span class="comment">// FIXME Very ugly to have these metrics bleed through here.</span></span><br><span class="line">                n.consensusReactor.SetBlockSyncingMetrics(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> err := bcR.SwitchToBlockSync(state); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    n.Logger.Error(<span class="string">&quot;failed to switch to block sync&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                d := types.EventDataBlockSyncStatus&#123;Complete: <span class="literal">false</span>, Height: state.LastBlockHeight&#125;</span><br><span class="line">                <span class="keyword">if</span> err := n.eventBus.PublishEventBlockSyncStatus(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    n.eventBus.Logger.Error(<span class="string">&quot;failed to emit the block sync starting event&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n.consensusReactor.SwitchToConsensus(state, <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h1&gt;&lt;p&gt;Tendermint 的启动流程比较清析明了，各业务启动流程都在对应的实现代码，主启动流程加载所需配置，由各启动实现类启动自
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="BlockChain" scheme="https://liukay.com/tags/BlockChain/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="源码分析" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="启动流程" scheme="https://liukay.com/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint ABCI概述</title>
    <link href="https://liukay.com/posts/6715.html"/>
    <id>https://liukay.com/posts/6715.html</id>
    <published>2021-11-02T03:35:30.000Z</published>
    <updated>2021-11-02T03:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABCI-概述-Application-BlockChain-Interface"><a href="#ABCI-概述-Application-BlockChain-Interface" class="headerlink" title="ABCI 概述 (Application BlockChain Interface)"></a>ABCI 概述 (Application BlockChain Interface)</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>让<code>应用程序层</code> 和 <code>共识层进行</code>解耦。可以理解为一套应用程序的接口标准，是<code>应用程序层</code>和<code>共识层进行</code>的桥梁。</p><p>应用程序区块链接口（ABCI） 允许用任何编程语言实现应用程序拜占庭容错复制。<br>区块链是多主状态机复制的系统。ABCI是一个接口，定义了复制引擎（区块链）和状态机（应用程序）之间的边界。使用Socket协议，运行在一个进程中的共识引擎可以管理运行在另一个进程中的应用程序状态。<br>以前，ABCI被称为TMSP。</p><p>官方github：<a href="https://github.com/tendermint/tendermint/tree/master/abci">ABCI</a></p><p><img src="/posts/6715/abci.png" alt="abci"></p><h2 id="开发动机"><a href="#开发动机" class="headerlink" title="开发动机"></a>开发动机</h2><p>目前为止，所有的区块链“技术栈”（如比特币）都是作为一个紧耦合的整体进行设计的。 换句话说，每一个区块链技术栈都是一个单独的程序，处理分布式账本的所有问题。 这些问题包括P2P连接、交易内存池广播、最新区块共识、账户余额、图灵完备合约、用户级权限管理等。</p><p>在计算机科学中，过高耦合度的程序架构通常不是好做法。 因为耦合度高会导致程序难以复用，并且这样做易导致代码库分叉进而维护困难。 当开发者没有对代码库进行模块化设计并遭受“意大利面代码”的困扰时，这种设计方式导致的问题更加明显。</p><p>高耦合度设计导致的另一个问题是所使用的开发语言受限于区块链技术栈（反之亦然）。在以太坊中，它提供一个图灵完备的字节码合约虚拟机，这就把开发者限制在了对应的合约语言上；<br>目前，这个合约语言是Serpent和Solidity。</p><p>相比之下，Tendermint分离了共识引擎和P2P层与特定区块链程序的应用状态细节。 Tendermint将应用程序的状态管理细节抽象到一个接口，并将该接口以socket协议的形式实现了出来。</p><p>所以，Tendermint拥有接口规范，即应用程序区块链接口（ABCI），并有了一个主要实现Tendermint socket协议（也叫TSP或Teaspoon）。</p><h2 id="ABCI介绍"><a href="#ABCI介绍" class="headerlink" title="ABCI介绍"></a>ABCI介绍</h2><p>ABCI 与 Tendermint Core 通信<br>Tendermint Core （“共识引擎”）通过满足<code>ABCI规范</code>的socket协议与应用程序通信。</p><h2 id="ABCI-应用"><a href="#ABCI-应用" class="headerlink" title="ABCI 应用"></a>ABCI 应用</h2><p>如果有人想在ABCI上创建一个类似比特币的系统，</p><h3 id="Tendermint-Core将会实现"><a href="#Tendermint-Core将会实现" class="headerlink" title="Tendermint Core将会实现"></a>Tendermint Core将会实现</h3><ul><li>在节点之间共享区块和交易</li><li>建立交易标准/不可更改的顺序（即区块链）</li></ul><h3 id="应用程序将会实现"><a href="#应用程序将会实现" class="headerlink" title="应用程序将会实现"></a>应用程序将会实现</h3><ul><li>维护UTXO数据库</li><li>验证交易签名</li><li>防止使用未产生的交易</li><li>允许客户端查询UTXO数据库</li></ul><p>Tendermint通过在应用程序进程和共识进程之间提供非常简单的API（即ABCI）来分解区块链设计。</p><p>ABI由3种主要消息类型组成，它们从Tendermint核心传递到应用程序，应用程序用相应的响应消息进行回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABCI-概述-Application-BlockChain-Interface&quot;&gt;&lt;a href=&quot;#ABCI-概述-Application-BlockChain-Interface&quot; class=&quot;headerlink&quot; title=&quot;ABCI 概述 (App
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
    
      <category term="概念" scheme="https://liukay.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="BlockChain" scheme="https://liukay.com/tags/BlockChain/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="概述" scheme="https://liukay.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
      <category term="快速入门" scheme="https://liukay.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
      <category term="ABCI" scheme="https://liukay.com/tags/ABCI/"/>
    
  </entry>
  
  <entry>
    <title>go 数组</title>
    <link href="https://liukay.com/posts/10187.html"/>
    <id>https://liukay.com/posts/10187.html</id>
    <published>2021-11-02T02:45:56.000Z</published>
    <updated>2021-11-02T02:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言数组声明有两种方式，1.定长数组，2.不定长度数组<br>注意：</p><ol><li>如果没有赋值，会有默认值<ul><li>int 数组，默认初始化为 0</li><li>string 就是空串</li></ul></li><li>数据类型必须相同，不能混用，int数组不能包含float 等，已验证</li><li>boolean 是false</li><li>数组越界是 panic 异常</li><li>数组是值类型，默认情况下是值拷贝，也就是说每次拷贝后是一个独立副本，数组间互不影响。</li><li>可以使用指针来实现引用传递</li></ol><h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure><h3 id="1-定长数组"><a href="#1-定长数组" class="headerlink" title="1.定长数组"></a>1.定长数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P01var</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest3</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> hens [<span class="number">6</span>]<span class="keyword">int</span></span><br><span class="line">   hens[<span class="number">0</span>] = <span class="number">111</span></span><br><span class="line">   hens[<span class="number">1</span>] = <span class="number">222</span></span><br><span class="line">   hens[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(hens); i++ &#123;</span><br><span class="line">           fmt.Printf(<span class="string">&quot;打印数组i=%d, 数据=%d\n&quot;</span>, i, hens[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打印数组i=0, 数据=111</span><br><span class="line">打印数组i=1, 数据=222</span><br><span class="line">打印数组i=2, 数据=333</span><br><span class="line">打印数组i=3, 数据=0</span><br><span class="line">打印数组i=4, 数据=0</span><br><span class="line">打印数组i=5, 数据=0</span><br></pre></td></tr></table></figure><p>如果输入超过实初始化的长度会越界，<br>//越界<br>hens[9] = 999</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../ArrayTest.go:11:6: invalid array index 9 (out of bounds for 6-element array)</span><br></pre></td></tr></table></figure><p>初始化二，类似java的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一般用这种方式</span></span><br><span class="line">  balance := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不定数组长度"><a href="#2-不定数组长度" class="headerlink" title="2.不定数组长度"></a>2.不定数组长度</h3><p>如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> balance = [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">  <span class="comment">//或</span></span><br><span class="line">  balance := [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通过下标初始化"><a href="#3-通过下标初始化" class="headerlink" title="3.通过下标初始化"></a>3.通过下标初始化</h3><p>如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</p><p>1:2 和 3:7.0 就是初始化了 1 和 3 两个元素<br>初始化 balance[4]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  balance := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1</span>:<span class="number">2.0</span>,<span class="number">3</span>:<span class="number">7.0</span>&#125;</span><br><span class="line"></span><br><span class="line">  balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 [5]int 后，[…]int 后的个数要对上，否则报错，已测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125; <span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 4.遍历数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n [<span class="number">10</span>]<span class="keyword">int</span> <span class="comment">/* n 是一个长度为 10 的数组 */</span></span><br><span class="line">   <span class="keyword">var</span> i,j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为数组 n 初始化元素 */</span></span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      n[i] = i + <span class="number">100</span> <span class="comment">/* 设置元素为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[0] = 100</span><br><span class="line">Element[1] = 101</span><br><span class="line">Element[2] = 102</span><br><span class="line">Element[3] = 103</span><br><span class="line">Element[4] = 104</span><br><span class="line">Element[5] = 105</span><br><span class="line">Element[6] = 106</span><br><span class="line">Element[7] = 107</span><br><span class="line">Element[8] = 108</span><br><span class="line">Element[9] = 109</span><br></pre></td></tr></table></figure><h3 id="5-声明数组的同时快速初始化数组"><a href="#5-声明数组的同时快速初始化数组" class="headerlink" title="5.声明数组的同时快速初始化数组"></a>5.声明数组的同时快速初始化数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i,j,k <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 声明数组的同时快速初始化数组</span></span><br><span class="line">  balance := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出数组元素 */</span></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;balance[%d] = %f\n&quot;</span>, i, balance[i] )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  balance2 := [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">  <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">  <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;balance2[%d] = %f\n&quot;</span>, j, balance2[j] )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line">  balance3 := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1</span>:<span class="number">2.0</span>,<span class="number">3</span>:<span class="number">7.0</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++ &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;balance3[%d] = %f\n&quot;</span>, k, balance3[k] )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言数组声明有两种方式，1.定长数组，2.不定长度数组&lt;br&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有赋值，会有默认值&lt;ul&gt;
&lt;li&gt;int 数组，默认初始化为 0&lt;/li&gt;
&lt;li&gt;string 就是空串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据类型必须相
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="数组" scheme="https://liukay.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint概述</title>
    <link href="https://liukay.com/posts/51570.html"/>
    <id>https://liukay.com/posts/51570.html</id>
    <published>2021-11-01T09:19:26.000Z</published>
    <updated>2021-11-01T09:19:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单理解为一个分布式状态机</p></blockquote><h1 id="什么是Tendermint"><a href="#什么是Tendermint" class="headerlink" title="什么是Tendermint?"></a>什么是Tendermint?</h1><p>Tenermint是个能够在多机器上安全一致地复制应用的软件。 安全是指无论多达1/3的机器出现何种类型的故障，Tendermint都可以正常工作。<br>一致是指每个正确运行的机器都可以获取完全相同的交易日志并计算相同的状态。 在分布式系统中，安全一致地复制至关重要；从货币到选举再到基础设施管理等广泛应用容错方面，它都有着着重要作用。</p><p>拜占庭容错（BFT）指的是系统能够容忍机器以任意方式出现故障，包括机器故意危害系统的方式。<br>拜占庭容错理论已有几十年的历史，但最近由于比特币和以太坊等“区块链技术”的成功，其软件实现才逐渐流行。<br>区块链技术是在更现代的环境下对BFT的一种改造，重点引入了点对点网络和密码认证等技术。 区块链的名称来源于交易的处理方式，交易被打包在每一个区块中，每一个区块存储前一个区块的哈希值，形成了一个链的结构。 实际上，区块链数据结构优化了BFT设计。</p><p>Tendermint包括两个主要技术组件：<code>区块链共识引擎</code>和<code>通用应用程序接口</code>。<br>共识引擎，被称作Tendermint Core，保证所有的机器按照相同的顺序记录相同的交易。<br>应用程序接口，被称为应用程序区块链接口ABCI，实现任意编程语言处理交易的功能。<br>其他区块链和共识解决方案通常预置内部状态机，比如使用键值存储不常见的脚本语言来完成功能，而Tendermint支持开发者用任意编程语言实现拜占庭容错的状态机复制功能，并且开发环境也非常友好。</p><p>Tendermint的目标是易使用、便理解、高性能并适用各种分布式应用场景。</p><h1 id="Tendermint-和其他技术对比"><a href="#Tendermint-和其他技术对比" class="headerlink" title="Tendermint 和其他技术对比"></a>Tendermint 和其他技术对比</h1><p>Tendermint大体上类似于两类软件。<br>第一类是非BFT一致性的分布式键值存储系统，包括Zookeeper、etcd和consul。<br>第二类是“区块链技术”，包括比特币和以太坊等加密货币和Hyperledger Burrow等分布式账本。</p><h2 id="Zookeeper、etcd和consul"><a href="#Zookeeper、etcd和consul" class="headerlink" title="Zookeeper、etcd和consul"></a>Zookeeper、etcd和consul</h2><p>Zookeeper、etcd和consul都基于经典非拜占庭容错一致性算法，实现了分布式键值存储。<br>Zookeeper使用了Zookeeper Atomic Broadcast版本的的Paxos共识算法，而etcd和consul使用了更新更简单的Raft共识算法。 一个典型的集群包含3-5台机器，并且可以容忍多达1/2台机器的故障，但是只要出现一个拜占庭错误机器，系统就会崩溃。</p><p>虽然这些软件都提供了各有特色的键值存储功能，但都关注为分布式系统提供基础服务，如动态配置、服务发现、锁定、领导人选举等。</p><p>Tendermint虽然在本质上和以上软件类似，但是具有两点关键不同：</p><ul><li><p>它实现了拜占庭容错。虽然只能够容忍系统1/3节点的故障，但是可以容忍任意类型的，包括黑客和恶意攻击的错误。</p></li><li><p>它不像键值存储那样只指定一种特定的应用，而是侧重于任意状态机复制。因此从键值存储到加密货币，再到电子投票平台，开发人员可以构建适合他们的任意应用程序逻辑。</p></li></ul><h2 id="Bitcoin-Ethereum-etc"><a href="#Bitcoin-Ethereum-etc" class="headerlink" title="Bitcoin, Ethereum, etc."></a>Bitcoin, Ethereum, etc.</h2><p>Tendermint诞生于比特币、以太坊等传统加密货币，目标是提供比比特币的PoW算法更高效、更安全的共识算法。 在早期，Tendermint内置了一种简单的货币，为了参与共识，用户必须将货币“绑定”到一个保证金中， 如果他们行为不当，保证金可能会被撤销——这就是Tendermint成为PoS算法的原因。</p><p>从那时起，Tendermint已经发展成为一个通用的区块链共识引擎，可以承载任意的应用程序状态。 这表示它可以成为其他区块链软件的共识引擎的即插即用替代品。 因此，当前的以太坊代码库，无论是Rust、Go还是Haskell，都可以作为一个ABCI应用程序运行在Tendermint共识引擎之上。<br>Tendermint 已经实现了以太坊。Tendermint 接下来准备对比特币、ZCash和其他各种确定性应用完成类似的开发实现。</p><p>目前，另外一个已实现的基于Tendermint的虚拟货币应用程序是Cosmos 网络。</p><p><a href="https://github.com/cosmos/ethermint">Tendermint 实现 Ethermint</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单理解为一个分布式状态机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是Tendermint&quot;&gt;&lt;a href=&quot;#什么是Tendermint&quot; class=&quot;headerlink&quot; title=&quot;什么是Tendermint?&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
    
      <category term="概念" scheme="https://liukay.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="概述" scheme="https://liukay.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
      <category term="快速入门" scheme="https://liukay.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>leveldb-整体架构</title>
    <link href="https://liukay.com/posts/18926.html"/>
    <id>https://liukay.com/posts/18926.html</id>
    <published>2021-10-31T14:14:50.000Z</published>
    <updated>2021-10-31T14:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中使用leveldb做为存储，使用过一段时间后，对leveldb进行一个深入的学习，让录本人学习过程中理解。过程中参照网上文章以经实际应用，进行文章输出，如果错漏，还望指正。</p><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>leveldb是一个写性能十分优秀的存储引擎，是典型的LSM树(Log Structured-Merge Tree)实现。<br>LSM树的核心思想就是放弃部分读的性能，换取最大的写入能力。这个很重要，后续深入会发现的leveldb的原理都是基于最大的写入性能去设计的。</p><p><img src="/posts/18926/leveldb_arch.jpg" alt="leveldb-整体架构"></p><p>LSM树写性能极高的原理，简单地来说就是尽量减少随机写的次数。对于每次写入操作，并不是直接将最新的数据驻留在磁盘中，而是将其拆分成<br>（1）一次日志文件的顺序写<br>（2）一次内存中的数据插入。<br>leveldb正是实践了这种思想，将数据首先更新在内存中，当内存中的数据达到一定的阈值，将这部分数据真正刷新到磁盘文件中，因而获得了极高的写性能（顺序写60MB/s, 随机写45MB/s）。</p><p>从图里能看出 LevelDB 主要结构包括：<br><strong>1.内存结构</strong></p><ol><li>MemTable</li><li>Immutable MemTable 不可变内存结构</li></ol><p><strong>2.磁盘文件</strong></p><ol><li>Current 文件</li><li>Manifest 文件</li><li>log 文件</li><li>SSTable 文件</li></ol><h3 id="Memtable"><a href="#Memtable" class="headerlink" title="Memtable"></a>Memtable</h3><blockquote><p>使用 leveldb，数据先写入内存，最终落入磁盘。</p></blockquote><p>leveldb的一次写入操作并不是直接将数据刷新到磁盘文件，而是首先写入到内存中作为代替，memtable就是一个在内存中进行数据组织与维护的结构。<br>memtable中，所有的数据按用户定义的排序方法排序之后按序存储，等到其存储内容的容量达到阈值时（默认为4MB），便将其转换成一个不可修改的memtable，与此同时创建一个新的memtable，供用户继续进行读写操作。<br>memtable底层使用了一种跳表数据结构，这种数据结构效率可以比拟二叉查找树，绝大多数操作的时间复杂度为<code>O(log n)</code>。</p><h3 id="Immutable-Memtable"><a href="#Immutable-Memtable" class="headerlink" title="Immutable Memtable"></a>Immutable Memtable</h3><p>memtable的容量到达阈值时，便会转换成一个不可修改的memtable，也称为immutable memtable。<br>这两者的结构定义完全一样，区别只是immutable memtable是只读的。当一个immutable memtable被创建时，leveldb的后台压缩进程便会将利用其中的内容，创建一个sstable，持久化到磁盘文件中。</p><p>所有 KV 数据都是存储在 Memtable，Immutable Memtable 和 SSTable 中的，Immutable Memtable 从结构上讲和 Memtable 是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而 Memtable 则是允许写入和读取的。当 Memtable 写入的数据占用内存到达指定数量，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成新的 Memtable 供写操作写入新数据，理解了 Memtable，那么 Immutable Memtable 自然不在话下。</p><h3 id="Log-文件"><a href="#Log-文件" class="headerlink" title="Log 文件"></a>Log 文件</h3><p>写入内存前先写 log 文件，这个文件是磁盘文件，类似于 MySQL 的 binlog。</p><p>leveldb的写操作并不是直接写入磁盘的，而是首先写入到内存。假设写入到内存的数据还未来得及持久化，leveldb进程发生了异常，抑或是宿主机器发生了宕机，会造成用户的写入发生丢失。因此leveldb在写内存之前会首先将所有的写操作写到日志文件中，也就是log文件。当以下异常情况发生时，均可以通过日志文件进行恢复：</p><ol><li>写log期间进程异常；</li><li>写log完成，写内存未完成；</li><li>write动作完成（即log、内存写入都完成）后，进程异常；</li><li>Immutable memtable持久化过程中进程异常；</li><li>其他压缩异常（较为复杂，首先不在这里介绍）；</li></ol><p>当第一类情况发生时，数据库重启读取log时，发现异常日志数据，抛弃该条日志数据，即视作这次用户写入失败，保障了数据库的一致性；</p><p>当第二类，第三类，第四类情况发生了，均可以通过redo日志文件中记录的写入操作完成数据库的恢复。</p><p>每次日志的写操作都是一次顺序写，因此写效率高，整体写入性能较好。</p><p>此外，leveldb的<code>用户写操作的原子性</code>同样通过日志来实现。</p><h3 id="SSTable-Sorted-String-Table"><a href="#SSTable-Sorted-String-Table" class="headerlink" title="SSTable (Sorted String Table)"></a>SSTable (Sorted String Table)</h3><p>这个是数据存储的文件。</p><p>虽然leveldb采用了先写内存的方式来提高写入效率，但是内存中数据不可能无限增长，且日志中记录的写入操作过多，会导致异常发生时，恢复时间过长。因此内存中的数据达到一定容量，就需要将数据持久化到磁盘中。除了某些元数据文件，leveldb的数据主要都是通过sstable来进行存储。</p><p>虽然在内存中，所有的数据都是按序排列的，但是当多个memetable数据持久化到磁盘后，对应的不同的sstable之间是存在交集的，在读操作时，需要对所有的sstable文件进行遍历，严重影响了读取效率。因此leveldb后台会“定期“整合这些sstable文件，该过程也称为compaction。随着compaction的进行，sstable文件在逻辑上被分成若干层，由内存数据直接dump出来的文件称为level 0层文件，后期整合而成的文件为level i 层文件，这也是leveldb这个名字的由来。</p><p>注意，所有的sstable文件本身的内容是不可修改的，这种设计哲学为leveldb带来了许多优势，简化了很多设计。具体将在接下来的文章中具体解释。</p><p>看下sst的整体结构</p><p>注意，sst 是逻辑上的结构，实际物理文件会有序号进行排序，但并不代表其层级。</p><p><img src="/posts/18926/sst层级2.jpg" alt="sst层级"></p><h3 id="manifest-文件"><a href="#manifest-文件" class="headerlink" title="manifest 文件"></a>manifest 文件</h3><p>leveldb中有个版本的概念，一个版本中主要记录了每一层中所有文件的元数据，元数据包括<br>（1）文件大小<br>（2）最大key值<br>（3）最小key值<br>该版本信息十分关键，除了在查找数据时，利用维护的每个文件的最大／小key值来加快查找，还在其中维护了一些进行compaction的统计值，来控制compaction的进行。</p><p>SSTable 中的某个文件属于特定层级，而且其存储的记录是 key 有序的，那么必然有文件中的最小 key 和最大 key，这是非常重要的信息，LevelDB 应该记下这些信息。manifest 就是干这个的，它记载了 SSTable 各个文件的管理信息，比如属于哪个 level，文件名称叫啥，最小 key 和最大 key 各自是多少。</p><p><img src="/posts/18926/manifest.png" alt="manifest"></p><p>图中只显示了两个文件（manifest 会记载所有 SSTable 文件的这些信息），即 level 0 的 Test1.sst 和 Test2.sst 文件，同时记载了这些文件各自对应的 key 范围，比如 Test1.sst 的 key 范围是 “abc” 到 “hello”，而文件 Test2.sst 的 key 范围是 “bbc” 到 “world”，可以看出两者的 key 范围是有重叠的。</p><h3 id="current-文件"><a href="#current-文件" class="headerlink" title="current 文件"></a>current 文件</h3><p>这个文件的内容只有一个信息，就是记载当前的 manifest 文件名。因为在 LevleDB 的运行过程中，随着 compaction 的进行，SSTable 文件会发生变化，会有新的文件产生，老的文件被废弃，manifest 也会跟着反映这种变化，此时往往会新生成 manifest 文件来记载这种变化，而 current 则用来指出哪个 manifest 文件才是我们关心的那个 manifest 文件。</p><p>注意，每次leveldb启动时，也都会创建一个新的Manifest文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;项目中使用leveldb做为存储，使用过一段时间后，对leveldb进行一个深入的学习，让录本人学习过程中理解。过程中参照网上文章以经实际应
      
    
    </summary>
    
      <category term="leveldb" scheme="https://liukay.com/categories/leveldb/"/>
    
    
      <category term="架构" scheme="https://liukay.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="数据库" scheme="https://liukay.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="leveldb" scheme="https://liukay.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>go 安装</title>
    <link href="https://liukay.com/posts/33246.html"/>
    <id>https://liukay.com/posts/33246.html</id>
    <published>2021-10-27T02:49:38.000Z</published>
    <updated>2021-11-04T07:04:48.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官网安装"><a href="#官网安装" class="headerlink" title="官网安装"></a>官网安装</h2><p>一般是直接上官网下载安装，不同版本功能还不一样，也可以使用脚本来快速安装。</p><p><a href="https://golang.org/dl">https://golang.org/dl</a></p><p>也可以参考官方安装文档<br><a href="https://golang.org/doc/install#install">https://golang.org/doc/install#install</a></p><p><img src="/posts/33246/go安装.jpg" alt="go下载列表"></p><h3 id="如果需要其他版本"><a href="#如果需要其他版本" class="headerlink" title="如果需要其他版本"></a>如果需要其他版本</h3><p>选 Archived versions 可以查看之前的发行版</p><p><img src="/posts/33246/其他版本.jpg" alt="其他版本"></p><h2 id="开发环境安装"><a href="#开发环境安装" class="headerlink" title="开发环境安装"></a>开发环境安装</h2><p>开发环境安装通常使用脚本快速安装</p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch install.sh</span><br><span class="line">chmod u+x install.sh</span><br></pre></td></tr></table></figure><h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><p>脚本会在当前用户下创建 go 目录，写入 .bash_profile 中<br><code>VERSION</code> 是版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; install.sh &lt;&lt;&quot;EOF&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">VERSION=&quot;1.16.4&quot;</span><br><span class="line">[ -z &quot;$GOROOT&quot; ] &amp;&amp; GOROOT=&quot;$HOME/.go&quot;</span><br><span class="line">[ -z &quot;$GOPATH&quot; ] &amp;&amp; GOPATH=&quot;$HOME/go&quot;</span><br><span class="line"></span><br><span class="line">OS=&quot;$(uname -s)&quot;</span><br><span class="line">ARCH=&quot;$(uname -m)&quot;</span><br><span class="line"></span><br><span class="line">case $OS in</span><br><span class="line">    &quot;Linux&quot;)</span><br><span class="line">        case $ARCH in</span><br><span class="line">        &quot;x86_64&quot;)</span><br><span class="line">            ARCH=amd64</span><br><span class="line">            ;;</span><br><span class="line">        &quot;armv6&quot;)</span><br><span class="line">            ARCH=armv6l</span><br><span class="line">            ;;</span><br><span class="line">        &quot;armv8&quot;)</span><br><span class="line">            ARCH=arm64</span><br><span class="line">            ;;</span><br><span class="line">        .*386.*)</span><br><span class="line">            ARCH=386</span><br><span class="line">            ;;</span><br><span class="line">        esac</span><br><span class="line">        PLATFORM=&quot;linux-$ARCH&quot;</span><br><span class="line">    ;;</span><br><span class="line">    &quot;Darwin&quot;)</span><br><span class="line">        PLATFORM=&quot;darwin-amd64&quot;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">print_help() &#123;</span><br><span class="line">    echo &quot;Usage: bash goinstall.sh OPTIONS&quot;</span><br><span class="line">    echo -e &quot;\nOPTIONS:&quot;</span><br><span class="line">    echo -e &quot;  --remove\tRemove currently installed version&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -n &quot;`$SHELL -c &#x27;echo $ZSH_VERSION&#x27;`&quot; ]; then</span><br><span class="line">    shell_profile=&quot;zshrc&quot;</span><br><span class="line">elif [ -n &quot;`$SHELL -c &#x27;echo $BASH_VERSION&#x27;`&quot; ]; then</span><br><span class="line">    shell_profile=&quot;bashrc&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">PACKAGE_NAME=&quot;go$VERSION.$PLATFORM.tar.gz&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; == &quot;--remove&quot; ]; then</span><br><span class="line">    rm -rf &quot;$GOROOT&quot;</span><br><span class="line">    if [ &quot;$OS&quot; == &quot;Darwin&quot; ]; then</span><br><span class="line">        sed -i &quot;&quot; &#x27;/# GoLang/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &quot;&quot; &#x27;/export GOROOT/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &quot;&quot; &#x27;/$GOROOT\/bin/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &quot;&quot; &#x27;/export GOPATH/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &quot;&quot; &#x27;/$GOPATH\/bin/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">        sed -i &#x27;/# GoLang/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &#x27;/export GOROOT/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &#x27;/$GOROOT\/bin/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &#x27;/export GOPATH/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">        sed -i &#x27;/$GOPATH\/bin/d&#x27; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;Go removed.&quot;</span><br><span class="line">    exit 0</span><br><span class="line">elif [ &quot;$1&quot; == &quot;--help&quot; ]; then</span><br><span class="line">    print_help</span><br><span class="line">    exit 0</span><br><span class="line">elif [ ! -z &quot;$1&quot; ]; then</span><br><span class="line">    echo &quot;Unrecognized option: $1&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$GOROOT&quot; ]; then</span><br><span class="line">    echo &quot;The Go install directory ($GOROOT) already exists. Exiting.&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Downloading $PACKAGE_NAME ...&quot;</span><br><span class="line">if hash wget 2&gt;/dev/null; then</span><br><span class="line">    wget https://storage.googleapis.com/golang/$PACKAGE_NAME -O /tmp/go.tar.gz</span><br><span class="line">else</span><br><span class="line">    curl -o /tmp/go.tar.gz https://storage.googleapis.com/golang/$PACKAGE_NAME</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $? -ne 0 ]; then</span><br><span class="line">    echo &quot;Download failed! Exiting.&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;Extracting File...&quot;</span><br><span class="line">mkdir -p &quot;$GOROOT&quot;</span><br><span class="line">tar -C &quot;$GOROOT&quot; --strip-components=1 -xzf /tmp/go.tar.gz</span><br><span class="line">touch &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line">&#123;</span><br><span class="line">    echo &#x27;# GoLang&#x27;</span><br><span class="line">    echo &quot;export GOROOT=$&#123;GOROOT&#125;&quot;</span><br><span class="line">    echo &#x27;export PATH=$GOROOT/bin:$PATH&#x27;</span><br><span class="line">    echo &quot;export GOPATH=$GOPATH&quot;</span><br><span class="line">    echo &#x27;export PATH=$GOPATH/bin:$PATH&#x27;</span><br><span class="line">    echo &quot;export GOBIN=$GOPATH/bin&quot;</span><br><span class="line">&#125; &gt;&gt; &quot;$HOME/.$&#123;shell_profile&#125;&quot;</span><br><span class="line"></span><br><span class="line">mkdir -p $GOPATH/&#123;src,pkg,bin&#125;</span><br><span class="line">echo -e &quot;\nGo $VERSION was installed into $GOROOT.\nMake sure to relogin into your shell or run:&quot;</span><br><span class="line">echo -e &quot;\n\tsource $HOME/.$&#123;shell_profile&#125;\n\nto update your environment variables.&quot;</span><br><span class="line">echo &quot;Tip: Opening a new terminal window usually just works. :)&quot;</span><br><span class="line">rm -f /tmp/go.tar.gz</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh install.sh</span><br><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;官网安装&quot;&gt;&lt;a href=&quot;#官网安装&quot; class=&quot;headerlink&quot; title=&quot;官网安装&quot;&gt;&lt;/a&gt;官网安装&lt;/h2&gt;&lt;p&gt;一般是直接上官网下载安装，不同版本功能还不一样，也可以使用脚本来快速安装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="安装" scheme="https://liukay.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="golang" scheme="https://liukay.com/tags/golang/"/>
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq-安装</title>
    <link href="https://liukay.com/posts/60633.html"/>
    <id>https://liukay.com/posts/60633.html</id>
    <published>2021-10-26T09:42:56.000Z</published>
    <updated>2021-11-06T05:04:34.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RabbitMQ 基于 Erlang，安装前，需要安装对应版本的 Erlang<br>官网 RabbitMQ 与 Erlang 版本对照表 <a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a><br>CentOS 7 环境下安装</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h3><ol><li><p>查看是否存在旧erlang版本<br><code>erl -version</code></p></li><li><p>若版本低于（version 11.2.2），卸载erlang<br><code>yum -y remove erlang-*</code></p></li><li><p>安装erlang所依赖工具<br><code>yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel</code></p></li><li><p>安装 socat<br>erlang内存管理依赖socat<br><code>yum install -y socat</code></p></li><li><p>安装 signing-key，用于和 yum更新源通信<br><code>rpm --import https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</code></p></li><li><p>更新源<br><code>vi /etc/yum.repos.d/rabbitmq_erlang.repo</code><br>将对应的内容拷贝到文件里面，参考链接：<a href="https://github.com/rabbitmq/erlang-rpm">https://github.com/rabbitmq/erlang-rpm</a><br>使用 Erlang 23.3 配置<br>复制除 begin end 分割线外的中间内容</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq-rabbitmq-erlang</span><br><span class="line">baseurl=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/rpm/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang-noarch]</span><br><span class="line">name=rabbitmq-rabbitmq-erlang-noarch</span><br><span class="line">baseurl=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/rpm/el/7/noarch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang-source]</span><br><span class="line">name=rabbitmq-rabbitmq-erlang-source</span><br><span class="line">baseurl=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/rpm/el/7/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://dl.cloudsmith.io/public/rabbitmq/rabbitmq-erlang/gpg.E495BB49CC4BBE5B.key</span><br><span class="line">       https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc</span><br><span class="line">gpgcheck=1</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line">pkg_gpgcheck=1</span><br><span class="line">autorefresh=1</span><br><span class="line">type=rpm-md</span><br></pre></td></tr></table></figure><ol start="7"><li><p>更新源<br>yum update -y</p></li><li><p>安装erlang<br>yum install -y erlang-23.3.4</p></li></ol><h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><ol><li><p>安装RabbitMQ</p><blockquote><p>yum install -y <a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.22/rabbitmq-server-3.8.22-1.el7.noarch.rpm">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.22/rabbitmq-server-3.8.22-1.el7.noarch.rpm</a></p></blockquote></li><li><p>systemctl 系统命令操作</p><blockquote><p>systemctl start rabbitmq-server   #启动<br>systemctl restart rabbitmq-server #重启<br>systemctl stop rabbitmq-server    #关闭<br>systemctl status rabbitmq-server  #查看状态</p></blockquote></li></ol><ol start="3"><li><p>rabbitmqctl 相关命令</p><blockquote><p>sudo rabbitmqctl status   #查看服务状态<br>sudo rabbitmqctl version  #查看服务版本</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;RabbitMQ 基于 Erlang，安装前，需要安装对应版本的 Erlang&lt;br&gt;官网 RabbitMQ 与 Erlang 版本对照表 
      
    
    </summary>
    
      <category term="rabbitmq" scheme="https://liukay.com/categories/rabbitmq/"/>
    
    
      <category term="mq" scheme="https://liukay.com/tags/mq/"/>
    
      <category term="安装" scheme="https://liukay.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="matic" scheme="https://liukay.com/tags/matic/"/>
    
  </entry>
  
  <entry>
    <title>matic checkpoint理解</title>
    <link href="https://liukay.com/posts/6413.html"/>
    <id>https://liukay.com/posts/6413.html</id>
    <published>2021-10-19T06:24:10.000Z</published>
    <updated>2021-11-10T06:36:19.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>checkpoint</code>是<code>Matic</code>协议中最关键的部分。它代表了<code>Bor</code>链状态的快照，应该由⅔+的验证器集证明，然后再验证并提交给部署在以太坊上的合约。</p><p>这里有几个问题：</p><ol><li>checkpoint 是什么</li><li>为什么要提交bor的状态，状态中包含哪些信息</li><li>checkpoint 验证流程</li></ol><h2 id="checkpoint-是什么"><a href="#checkpoint-是什么" class="headerlink" title="checkpoint 是什么"></a>checkpoint 是什么</h2><p><code>checkpoint</code>是<code>Matic</code>协议中最关键的部分。它代表了<code>Bor</code>链状态的快照，应该由⅔+的<code>validator</code>集证明，然后再验证并提交给部署在以太坊上的合约。</p><p>Heimdall 层允许将 Bor 生成的区块聚合到单个 Merkle 根中，并定期将其发布到以太坊主链。<br>此已发布状态也称为检查点，因此整个过程称为<code>validator(检查点)</code>。<br>检查点提议者最初是通过 <code>Tendermint</code> 的加权循环算法选择的。</p><h3 id="checkpoint-结构"><a href="#checkpoint-结构" class="headerlink" title="checkpoint 结构"></a>checkpoint 结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CheckpointBlockHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Proposer is selected based on stake</span></span><br><span class="line">    Proposer        types.HeimdallAddress <span class="string">`json:&quot;proposer&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// StartBlock: The block number on Bor from which this checkpoint starts</span></span><br><span class="line">    StartBlock      <span class="keyword">uint64</span>                <span class="string">`json:&quot;startBlock&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EndBlock: The block number on Bor from which this checkpoint ends</span></span><br><span class="line">    EndBlock        <span class="keyword">uint64</span>                <span class="string">`json:&quot;endBlock&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RootHash is the Merkle root of all the leaves containing the block</span></span><br><span class="line">    <span class="comment">// headers starting from start to the end block</span></span><br><span class="line">    RootHash        types.HeimdallHash    <span class="string">`json:&quot;rootHash&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account root hash for each validator</span></span><br><span class="line">    <span class="comment">// Hash of data that needs to be passed from Heimdall to Ethereum chain like slashing, withdraw topup etc.</span></span><br><span class="line">    AccountRootHash types.HeimdallHash    <span class="string">`json:&quot;accountRootHash&quot;`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Timestamp when checkpoint was created on Heimdall</span></span><br><span class="line">    TimeStamp       <span class="keyword">uint64</span>          <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里 checkpoint 的提交是基于 bor 的<code>StartBlock</code>到<code>EndBlock</code>之间的区块，这点很重要。<br><code>bor</code>是基于<code>Ethereum协议</code>实现的底层链。<a href="https://docs.polygon.technology/docs/contribute/bor/overview">官方定义</a></p><p><img src="/posts/6413/checkpoint.svg" alt="checkpoint"></p><h3 id="blockHash"><a href="#blockHash" class="headerlink" title="blockHash"></a>blockHash</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockHash = keccak256([number, time, tx hash, receipt hash])</span><br></pre></td></tr></table></figure><h3 id="rootHash"><a href="#rootHash" class="headerlink" title="rootHash"></a>rootHash</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B(<span class="number">1</span>) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line">B(<span class="number">2</span>) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">B(n) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpoint is Merkle root of all block hash</span></span><br><span class="line">checkpoint<span class="string">&#x27;s root hash = Merkel[B(1), B(2), ....., B(n)]</span></span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是 Bor 链区块创建<code>checkpoint</code>的代码片段，官方代码：<br><a href="https://github.com/maticnetwork/heimdall/blob/develop/checkpoint/types/merkel.go#L60-L114">https://github.com/maticnetwork/heimdall/blob/develop/checkpoint/types/merkel.go#L60-L114</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Golang representation of block data used in checkpoint</span></span><br><span class="line">blockData := crypto.Keccak256(appendBytes32(</span><br><span class="line">    blockHeader.Number.Bytes(),</span><br><span class="line">    <span class="built_in">new</span>(big.Int).SetUint64(blockHeader.Time).Bytes(),</span><br><span class="line">    blockHeader.TxHash.Bytes(),</span><br><span class="line">    blockHeader.ReceiptHash.Bytes(),</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"><span class="comment">// array of block hashes of Bor blocks</span></span><br><span class="line">headers := [blockData1, blockData2, ..., blockDataN]</span><br><span class="line"></span><br><span class="line"><span class="comment">// merkel tre</span></span><br><span class="line">tree := merkle.NewTreeWithOpts(merkle.TreeOptions&#123;EnableHashSorting: <span class="literal">false</span>, DisableHashLeaves: <span class="literal">true</span>&#125;)</span><br><span class="line">tree.Generate(convert(headers), sha3.NewLegacyKeccak256())</span><br><span class="line"></span><br><span class="line"><span class="comment">// create checkpoint&#x27;s root hash</span></span><br><span class="line">rootHash := tree.Root().Hash</span><br></pre></td></tr></table></figure><h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><ol><li>侧链提交 checkpoint</li><li>Validator 接收、验证checkpoint，并提交主链</li><li>主链接收checkpoint，并发送checkpoint-ack</li><li>Validator 接收、验证 checkpoint-ack</li></ol><p><code>Validator</code> 层通过 <code>bridge</code>模块监听<code>主链</code>和<code>侧链</code>上的合约事件。</p><p><strong>质押</strong>：质押链为<code>ETH主链</code></p><p><strong>存款</strong>：发生在<code>ETH主链</code></p><p><strong>取款</strong>：发生在<code>MATIC侧链</code><br>下面的流程图代表了<code>checkpoint</code>的生命周期。<br><img src="/posts/6413/checkpoint流程.png" alt="checkpoint流程"></p><p><code>Heimdall</code>使用与<code>Tendermint</code>相同的<code>共识算法</code>来选择下一个Proposer。<code>Proposer</code> 也就是 <code>Heimdall</code> 层的出块者，在 Matic 中发分起一个 Propose 提案</p><p>在以太坊链上提交<code>checkpoint</code>时，可能会因为多种原因而失败，如<code>gas limit</code>，以太坊拥堵，高<code>gas</code>费用。这就是为什么需要多阶段的<code>checkpoint</code>过程。</p><p>因为每个<code>checkpoint</code>都<code>Proposer</code>提起的，而每个<code>validator</code>都有机会被选举为<code>Proposer</code>。<br>如果提交以太坊链上的<code>checkpoint</code>成功或失败，将会发送<code>ack</code>和<code>no-ack</code>交易将改变Heimdall上的提议者，以进行下一个检查点。</p><h2 id="Checkpoint-流程"><a href="#Checkpoint-流程" class="headerlink" title="Checkpoint 流程"></a>Checkpoint 流程</h2><p><img src="/posts/6413/checkpointMessage 流程.jpg" alt="Checkpoint 流程"></p><p>那么问题来了，Heimdall 链是怎么知道 checkpoint 提交 Ethereum主链成功没成功？</p><p>Heimdall项目中的bor模块，是基于<code>Ethereum</code>实现ETH协议，实际就是包装了EVM，可以接收ETH广播的区块，并监听合约事件，从事件中获取需要的事件信息。</p><h2 id="Checkpoint-事件监听"><a href="#Checkpoint-事件监听" class="headerlink" title="Checkpoint 事件监听"></a>Checkpoint 事件监听</h2><p>看下 checkpoint 相关的事件监听，heimdall 的事件处理通过将监听器监听到的事件，发送到队列当中，由事件处理器进行处理。<br>这些逻辑在 <code>bridge</code> 模块中进行。</p><p>关键事件：</p><ol><li>sendCheckpointToHeimdall</li><li>sendCheckpointToRootchain</li><li>sendCheckpointAckToHeimdall</li></ol><p>Rootchain是<code>Ethereum</code><br>Heimdall是matic的中间层</p><h3 id="获取监听事件"><a href="#获取监听事件" class="headerlink" title="获取监听事件"></a>获取监听事件</h3><p>bridge/setu/listener/heimdall.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessBlockEvent - process Blockevents (BeginBlock, EndBlock events) from heimdall.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hl *HeimdallListener)</span> <span class="title">ProcessBlockEvent</span><span class="params">(event sdk.StringEvent, blockHeight <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    hl.Logger.Info(<span class="string">&quot;Received block event from Heimdall&quot;</span>, <span class="string">&quot;eventType&quot;</span>, event.Type, <span class="string">&quot;height&quot;</span>, blockHeight)</span><br><span class="line">    eventBytes, err := json.Marshal(event)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        hl.Logger.Error(<span class="string">&quot;Error while parsing block event&quot;</span>, <span class="string">&quot;error&quot;</span>, err, <span class="string">&quot;eventType&quot;</span>, event.Type)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> event.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> checkpointTypes.EventTypeCheckpoint:</span><br><span class="line">        <span class="comment">//发送事件到队列</span></span><br><span class="line">        hl.sendBlockTask(<span class="string">&quot;sendCheckpointToRootchain&quot;</span>, eventBytes, blockHeight)</span><br><span class="line">    <span class="keyword">case</span> checkpointTypes.EventTypeCheckpointSync:</span><br><span class="line">        hl.sendBlockTask(<span class="string">&quot;sendCheckpointSyncToStakeChain&quot;</span>, eventBytes, blockHeight)</span><br><span class="line">    <span class="keyword">case</span> slashingTypes.EventTypeSlashLimit:</span><br><span class="line">        hl.sendBlockTask(<span class="string">&quot;sendTickToHeimdall&quot;</span>, eventBytes, blockHeight)</span><br><span class="line">    <span class="keyword">case</span> slashingTypes.EventTypeTickConfirm:</span><br><span class="line">        hl.sendBlockTask(<span class="string">&quot;sendTickToRootchain&quot;</span>, eventBytes, blockHeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> stakingTypes.EventTypeValidatorJoin,</span><br><span class="line">        stakingTypes.EventTypeSignerUpdate,</span><br><span class="line">        stakingTypes.EventTypeValidatorExit,</span><br><span class="line">        stakingTypes.EventTypeStakingSyncAck:</span><br><span class="line">        hl.sendBlockTask(<span class="string">&quot;sendStakingSyncToHeimdall&quot;</span>, eventBytes, blockHeight)</span><br><span class="line">    <span class="keyword">case</span> stakingTypes.EventTypeStakingSync:</span><br><span class="line">        hl.sendBlockTask(<span class="string">&quot;sendStakingSyncToRootChain&quot;</span>, eventBytes, blockHeight)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        hl.Logger.Debug(<span class="string">&quot;BlockEvent Type mismatch&quot;</span>, <span class="string">&quot;eventType&quot;</span>, event.Type)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送事件到队列"><a href="#发送事件到队列" class="headerlink" title="发送事件到队列"></a>发送事件到队列</h3><p>hl.queueConnector 是Heimdall的内部队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hl *HeimdallListener)</span> <span class="title">sendBlockTask</span><span class="params">(taskName <span class="keyword">string</span>, eventBytes []<span class="keyword">byte</span>, blockHeight <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// create machinery task</span></span><br><span class="line">    signature := &amp;tasks.Signature&#123;</span><br><span class="line">        Name: taskName,</span><br><span class="line">        Args: []tasks.Arg&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                Type:  <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                Value: <span class="keyword">string</span>(eventBytes),</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                Type:  <span class="string">&quot;int64&quot;</span>,</span><br><span class="line">                Value: blockHeight,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    signature.RetryCount = <span class="number">3</span></span><br><span class="line">    signature.RetryTimeout = <span class="number">3</span></span><br><span class="line">    hl.Logger.Info(<span class="string">&quot;Sending block level task&quot;</span>,</span><br><span class="line">        <span class="string">&quot;taskName&quot;</span>, taskName, <span class="string">&quot;eventBytes&quot;</span>, eventBytes, <span class="string">&quot;currentTime&quot;</span>, time.Now(), <span class="string">&quot;blockHeight&quot;</span>, blockHeight)</span><br><span class="line">    <span class="comment">// send task</span></span><br><span class="line">    _, err := hl.queueConnector.Server.SendTask(signature)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        hl.Logger.Error(<span class="string">&quot;Error sending block level task&quot;</span>, <span class="string">&quot;taskName&quot;</span>, taskName, <span class="string">&quot;blockHeight&quot;</span>, blockHeight, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理队列的-checkpoint-事件"><a href="#处理队列的-checkpoint-事件" class="headerlink" title="处理队列的 checkpoint 事件"></a>处理队列的 checkpoint 事件</h3><p>bridge/setu/processor/checkpoint.go</p><ol><li><code>sendCheckpointToHeimdall</code> 监听事件</li><li><code>cp.sendCheckpointToHeimdall</code> 事件处理器</li><li><code>sendCheckpointAckToHeimdall</code> checkpoint-Ack事件</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterTasks - Registers checkpoint related tasks with machinery</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cp *CheckpointProcessor)</span> <span class="title">RegisterTasks</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cp.Logger.Info(<span class="string">&quot;Registering checkpoint tasks&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err := cp.queueConnector.Server.RegisterTask(<span class="string">&quot;sendCheckpointToHeimdall&quot;</span>, cp.sendCheckpointToHeimdall); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp.Logger.Error(<span class="string">&quot;RegisterTasks | sendCheckpointToHeimdall&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cp.queueConnector.Server.RegisterTask(<span class="string">&quot;sendCheckpointToRootchain&quot;</span>, cp.sendCheckpointToRootchain); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp.Logger.Error(<span class="string">&quot;RegisterTasks | sendCheckpointToRootchain&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cp.queueConnector.Server.RegisterTask(<span class="string">&quot;sendCheckpointAckToHeimdall&quot;</span>, cp.sendCheckpointAckToHeimdall); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp.Logger.Error(<span class="string">&quot;RegisterTasks | sendCheckpointAckToHeimdall&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cp.queueConnector.Server.RegisterTask(<span class="string">&quot;sendCheckpointSyncToStakeChain&quot;</span>, cp.sendCheckpointSyncToStakeChain); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp.Logger.Error(<span class="string">&quot;RegisterTasks | sendCheckpointSyncToStakeChain&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := cp.queueConnector.Server.RegisterTask(<span class="string">&quot;sendCheckpointSyncAckToHeimdall&quot;</span>, cp.sendCheckpointSyncAckToHeimdall); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp.Logger.Error(<span class="string">&quot;RegisterTasks | sendCheckpointSyncAckToHeimdall&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;checkpoint&lt;/code&gt;是&lt;code&gt;Matic&lt;/code&gt;协议中最关键的部分。它代表了&lt;code&gt;Bor&lt;/cod
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="matic" scheme="https://liukay.com/categories/blockchain/matic/"/>
    
    
      <category term="概念" scheme="https://liukay.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="matic" scheme="https://liukay.com/tags/matic/"/>
    
      <category term="checkpoint" scheme="https://liukay.com/tags/checkpoint/"/>
    
      <category term="polygon" scheme="https://liukay.com/tags/polygon/"/>
    
  </entry>
  
  <entry>
    <title>CMS 问题定位与排查</title>
    <link href="https://liukay.com/posts/28187.html"/>
    <id>https://liukay.com/posts/28187.html</id>
    <published>2021-07-21T03:56:03.000Z</published>
    <updated>2021-11-11T07:25:02.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近排查一个历史老问题，历史问题就是大家都知道，但是没人愿意处理。<br>线上节点 16 和 32 G 内存频繁的出现GC，并且由于 GC 还导至两个问题，1.CPU使用率在GC时变高，2.业务出现异常。<br>这个问题变得无法忍耐了，跟踪程序线程使用，CMS GC 线程CPU 使用在初始化时都 11-99% 之间，严重影响业务处理。<br>通过 <code>jstat</code> 观察，FullGC 不多，但是 YoungGC 非常频繁，YoungGC 多不影响服务性能吗？也影响。<br>计算一个服务GC的好坏，不是看 FullGC 多少，而是看整体服务的吞吐量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">68096.0 68096.0 16840.1  0.0   545344.0 115481.1 6658496.0  4835834.6  63280.0 60712.9 7084.0 6615.1 1930261 53981.101 4804  1248.371 55229.471</span><br><span class="line">68096.0 68096.0  0.0   17347.7 545344.0 12072.1  6658496.0  4836565.4  63280.0 60712.9 7084.0 6615.1 1930262 53981.125 4804  1248.371 55229.496</span><br><span class="line">68096.0 68096.0  0.0   12854.1 545344.0 252246.5 6658496.0  4838818.8  63280.0 60712.9 7084.0 6615.1 1930264 53981.168 4804  1248.371 55229.539</span><br><span class="line">68096.0 68096.0 19501.0  0.0   545344.0 187933.5 6658496.0  4838869.4  63280.0 60712.9 7084.0 6615.1 1930265 53981.189 4804  1248.371 55229.559</span><br><span class="line">68096.0 68096.0 19501.0  0.0   545344.0 445775.5 6658496.0  4838869.4  63280.0 60712.9 7084.0 6615.1 1930265 53981.189 4804  1248.371 55229.559</span><br><span class="line">68096.0 68096.0 11858.3  0.0   545344.0 515043.9 6658496.0  4845614.9  63280.0 60712.9 7084.0 6615.1 1930267 53981.239 4804  1248.371 55229.610</span><br><span class="line">68096.0 68096.0  0.0   16469.0 545344.0 361227.7 6658496.0  4846356.5  63280.0 60712.9 7084.0 6615.1 1930268 53981.263 4804  1248.371 55229.634</span><br><span class="line">68096.0 68096.0  0.0   20075.6 545344.0 226522.4 6658496.0  4847100.6  63280.0 60712.9 7084.0 6615.1 1930270 53981.316 4804  1248.371 55229.687</span><br><span class="line">68096.0 68096.0 19591.2  0.0   545344.0 325872.6 6658496.0  4852312.8  63280.0 60712.9 7084.0 6615.1 1930271 53981.344 4804  1248.371 55229.715</span><br><span class="line">68096.0 68096.0  0.0   19282.2 545344.0 206195.9 6658496.0  4853497.6  63280.0 60712.9 7084.0 6615.1 1930272 53981.368 4804  1248.371 55229.739</span><br><span class="line">68096.0 68096.0  0.0   16319.6 545344.0 520305.2 6658496.0  4858184.1  63280.0 60712.9 7084.0 6615.1 1930274 53981.414 4804  1248.371 55229.785</span><br><span class="line">68096.0 68096.0 19240.3  0.0   545344.0 349365.5 6658496.0  4859016.3  63280.0 60712.9 7084.0 6615.1 1930275 53981.445 4804  1248.371 55229.815</span><br></pre></td></tr></table></figure><p>计算吞吐量</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>先排除环境原因，从开发环境到线上环境发现情况是相同的，可以初步认定是一个普遍问题。</p><h3 id="定位-16G-内存服务情况"><a href="#定位-16G-内存服务情况" class="headerlink" title="定位 16G 内存服务情况"></a>定位 16G 内存服务情况</h3><p>先从 <strong>16G</strong> 内存开始，收集一些基本信息，再观察运行情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java -Xms9g -Xmx9g</span><br><span class="line">   -XX:+UseConcMarkSweepGC</span><br><span class="line">   -XX:+PrintGCDetails -Xloggc:./gc.log</span><br><span class="line">   -XX:+PrintGCDateStamps</span><br><span class="line">   -XX:+CMSParallelRemarkEnabled</span><br><span class="line">   -XX:ReservedCodeCacheSize=<span class="number">256</span>m</span><br><span class="line">   -XX:+CMSScavengeBeforeRemark</span><br><span class="line">   -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">   -XX:MaxDirectMemorySize=<span class="number">1</span>g</span><br><span class="line">  -jar Node.jar</span><br><span class="line">  -c config.conf</span><br></pre></td></tr></table></figure><p>从这上面能看到关于 <strong>CMS</strong> 关相的几个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure><h4 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">40</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">70</span></span><br><span class="line">   MaxHeapSize              = <span class="number">9663676416</span> (<span class="number">9216.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">697892864</span> (<span class="number">665.5625</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">697892864</span> (<span class="number">665.5625</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">8965783552</span> (<span class="number">8550.4375</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line"><span class="function">New <span class="title">Generation</span> <span class="params">(Eden + <span class="number">1</span> Survivor Space)</span>:</span></span><br><span class="line"><span class="function">   capacity </span>= <span class="number">628162560</span> (<span class="number">599.0625</span>MB)</span><br><span class="line">   used     = <span class="number">511774816</span> (<span class="number">488.0664978027344</span>MB)</span><br><span class="line">   free     = <span class="number">116387744</span> (<span class="number">110.99600219726562</span>MB)</span><br><span class="line">   <span class="number">81.47171585648148</span>% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">558432256</span> (<span class="number">532.5625</span>MB)</span><br><span class="line">   used     = <span class="number">487164440</span> (<span class="number">464.5962142944336</span>MB)</span><br><span class="line">   free     = <span class="number">71267816</span> (<span class="number">67.9662857055664</span>MB)</span><br><span class="line">   <span class="number">87.23787617311275</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">69730304</span> (<span class="number">66.5</span>MB)</span><br><span class="line">   used     = <span class="number">24610376</span> (<span class="number">23.47028350830078</span>MB)</span><br><span class="line">   free     = <span class="number">45119928</span> (<span class="number">43.02971649169922</span>MB)</span><br><span class="line">   <span class="number">35.29365941097862</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">69730304</span> (<span class="number">66.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">69730304</span> (<span class="number">66.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = <span class="number">8965783552</span> (<span class="number">8550.4375</span>MB)</span><br><span class="line">   used     = <span class="number">4737287088</span> (<span class="number">4517.829025268555</span>MB)</span><br><span class="line">   free     = <span class="number">4228496464</span> (<span class="number">4032.6084747314453</span>MB)</span><br><span class="line">   <span class="number">52.837401890471156</span>% used</span><br><span class="line"></span><br><span class="line"><span class="number">20983</span> interned Strings occupying <span class="number">2039024</span> bytes.</span><br></pre></td></tr></table></figure><p>这里看出一个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">40</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">70</span></span><br><span class="line">   MaxHeapSize              = <span class="number">9663676416</span> (<span class="number">9216.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">697892864</span> (<span class="number">665.5625</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">697892864</span> (<span class="number">665.5625</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">8965783552</span> (<span class="number">8550.4375</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>NewRatio=2</strong> 但是实际新生代获得的内存空间只有 <strong>665.5625MB</strong>，这就有点奇怪了，不是说好的老年代:新生代 2 : 1 吗。<br>这是一个问题，另外从当前的 GC 回收时间推算出，当前吞吐量为: 96%，还没有达到最优的情况。</p><h4 id="修复新生代比例大小"><a href="#修复新生代比例大小" class="headerlink" title="修复新生代比例大小"></a>修复新生代比例大小</h4><p>添加启动参数 -XX:NewRatio=2，完整启动命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">java -Xms9g -Xmx9g</span><br><span class="line">   -XX:NewRatio=<span class="number">2</span></span><br><span class="line">   -XX:+UseConcMarkSweepGC</span><br><span class="line">   -XX:+PrintGCDetails -Xloggc:./gc.log</span><br><span class="line">   -XX:+PrintGCDateStamps</span><br><span class="line">   -XX:+CMSParallelRemarkEnabled</span><br><span class="line">   -XX:ReservedCodeCacheSize=<span class="number">256</span>m</span><br><span class="line">   -XX:+CMSScavengeBeforeRemark</span><br><span class="line">   -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">   -XX:MaxDirectMemorySize=<span class="number">1</span>g</span><br><span class="line">  -jar Node.jar</span><br><span class="line">  -c config.conf</span><br></pre></td></tr></table></figure><p>通过 <code>jstat -gc pid 1000</code> 观察一下 GC 情况<br>添加 <code>-XX:NewRatio=2</code> 启动参数的机器情况</p><p>jmap -heap 查看一下调整后的新生代占比，现在 <code>NewSize=3072.0MB</code> <code>OldSize=6144.0MB</code><br>这时比例生效了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         &#x3D; 40</span><br><span class="line">   MaxHeapFreeRatio         &#x3D; 70</span><br><span class="line">   MaxHeapSize              &#x3D; 9663676416 (9216.0MB)</span><br><span class="line">   NewSize                  &#x3D; 3221225472 (3072.0MB)</span><br><span class="line">   MaxNewSize               &#x3D; 3221225472 (3072.0MB)</span><br><span class="line">   OldSize                  &#x3D; 6442450944 (6144.0MB)</span><br><span class="line">   NewRatio                 &#x3D; 2</span><br><span class="line">   SurvivorRatio            &#x3D; 8</span><br><span class="line">   MetaspaceSize            &#x3D; 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         &#x3D; 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         &#x3D; 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity &#x3D; 2899116032 (2764.8125MB)</span><br><span class="line">   used     &#x3D; 2516795744 (2400.2034606933594MB)</span><br><span class="line">   free     &#x3D; 382320288 (364.6090393066406MB)</span><br><span class="line">   86.81252203154317% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity &#x3D; 2577006592 (2457.625MB)</span><br><span class="line">   used     &#x3D; 2194686304 (2093.0159606933594MB)</span><br><span class="line">   free     &#x3D; 382320288 (364.6090393066406MB)</span><br><span class="line">   85.16417112836008% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity &#x3D; 322109440 (307.1875MB)</span><br><span class="line">   used     &#x3D; 322109440 (307.1875MB)</span><br><span class="line">   free     &#x3D; 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity &#x3D; 322109440 (307.1875MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 322109440 (307.1875MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity &#x3D; 6442450944 (6144.0MB)</span><br><span class="line">   used     &#x3D; 525052336 (500.7289276123047MB)</span><br><span class="line">   free     &#x3D; 5917398608 (5643.271072387695MB)</span><br><span class="line">   8.149884889523188% used</span><br><span class="line"></span><br><span class="line">13727 interned Strings occupying 1224528 bytes.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S0C      S1C      S0U    S1U     EC        EU        OC         OU         MC      MU      CCSC   CCSU     YGC   YGCT     FGC    FGCT    GCT</span><br><span class="line">314560.0 314560.0  0.0   85539.9 2516608.0 1975197.4 6291456.0  4613067.7  63012.0 59752.3 7024.0 6520.3   9317  494.820  222    22.566  517.386</span><br><span class="line">314560.0 314560.0  0.0   85539.9 2516608.0 2228635.2 6291456.0  4613067.7  63012.0 59752.3 7024.0 6520.3   9317  494.820  222    22.566  517.386</span><br><span class="line">314560.0 314560.0 87689.1  0.0   2516608.0 681984.2  6291456.0  4621812.0  63012.0 59752.3 7024.0 6520.3   9318  494.875  222    22.566  517.441</span><br><span class="line">314560.0 314560.0 87689.1  0.0   2516608.0 1965292.1 6291456.0  4621812.0  63012.0 59752.3 7024.0 6520.3   9318  494.875  222    22.566  517.441</span><br><span class="line">314560.0 314560.0  0.0   95789.9 2516608.0 145469.7  6291456.0  4629480.3  63012.0 59752.3 7024.0 6520.3   9319  494.928  222    22.566  517.494</span><br><span class="line">314560.0 314560.0  0.0   95789.9 2516608.0 1741481.8 6291456.0  4629480.3  63012.0 59752.3 7024.0 6520.3   9319  494.928  222    22.566  517.494</span><br><span class="line">314560.0 314560.0  0.0   95789.9 2516608.0 1978876.4 6291456.0  4629480.3  63012.0 59752.3 7024.0 6520.3   9319  494.928  222    22.566  517.494</span><br><span class="line">314560.0 314560.0 74735.8  0.0   2516608.0 306828.0  6291456.0  4638677.5  63012.0 59752.3 7024.0 6520.3   9320  494.982  222    22.566  517.549</span><br><span class="line">314560.0 314560.0 74735.8  0.0   2516608.0 1513196.3 6291456.0  4638677.5  63012.0 59752.3 7024.0 6520.3   9320  494.982  222    22.566  517.549</span><br><span class="line">314560.0 314560.0 74735.8  0.0   2516608.0 1941220.4 6291456.0  4638677.5  63012.0 59752.3 7024.0 6520.3   9320  494.982  222    22.566  517.549</span><br><span class="line">314560.0 314560.0 74735.8  0.0   2516608.0 2415940.5 6291456.0  4638677.5  63012.0 59752.3 7024.0 6520.3   9320  494.982  222    22.566  517.549</span><br></pre></td></tr></table></figure><p>对比存在问题的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S0C     S1C     S0U    S1U     EC       EU       OC         OU         MC      MU      CCSC   CCSU    YGC    YGCT     FGC     FGCT  GCT</span><br><span class="line">68096.0 68096.0  0.0   16853.2 545344.0 371165.3 8755648.0  5890791.6  62312.0 59746.5 7076.0 6608.5  43879 1312.752  60      5.206 1317.958</span><br><span class="line">68096.0 68096.0 19377.9  0.0   545344.0 420827.3 8755648.0  5891528.9  62312.0 59746.5 7076.0 6608.5  43880 1312.785  60      5.206 1317.991</span><br><span class="line">68096.0 68096.0  0.0   22147.2 545344.0 295435.0 8755648.0  5891577.4  62312.0 59746.5 7076.0 6608.5  43881 1312.816  60      5.206 1318.022</span><br><span class="line">68096.0 68096.0 21257.5  0.0   545344.0 461020.2 8755648.0  5898299.9  62312.0 59746.5 7076.0 6608.5  43882 1312.850  60      5.206 1318.056</span><br><span class="line">68096.0 68096.0  0.0   13895.9 545344.0 419534.8 8755648.0  5901746.3  62312.0 59746.5 7076.0 6608.5  43885 1312.961  60      5.206 1318.167</span><br><span class="line">68096.0 68096.0  0.0   17542.7 545344.0 63902.2  8755648.0  5906856.1  62312.0 59746.5 7076.0 6608.5  43887 1313.028  60      5.206 1318.234</span><br><span class="line">68096.0 68096.0  0.0   17542.7 545344.0 444878.0 8755648.0  5906856.1  62312.0 59746.5 7076.0 6608.5  43887 1313.028  60      5.206 1318.234</span><br><span class="line">68096.0 68096.0 15241.8  0.0   545344.0 403475.0 8755648.0  5909706.0  62312.0 59746.5 7076.0 6608.5  43890 1313.108  60      5.206 1318.314</span><br><span class="line">68096.0 68096.0 24031.2  0.0   545344.0 52019.0  8755648.0  5916571.4  62312.0 59746.5 7076.0 6608.5  43892 1313.174  60      5.206 1318.380</span><br><span class="line">68096.0 68096.0 17381.4  0.0   545344.0 349457.1 8755648.0  5919082.7  62312.0 59746.5 7076.0 6608.5  43894 1313.232  60      5.206 1318.438</span><br><span class="line">68096.0 68096.0  0.0   20887.7 545344.0 442091.1 8755648.0  5919151.3  62312.0 59746.5 7076.0 6608.5  43895 1313.261  60      5.206 1318.467</span><br></pre></td></tr></table></figure><p>这两组数据能看出什么?</p><blockquote><p>YGC : 新生代垃圾回收次数<br>YGCT : 新生代垃圾回收时间<br>FGC : 老年代垃圾回收次数<br>FGCT : 老年代垃圾回收时间<br>GCT : 垃圾回收总消耗时间</p></blockquote><p>对比两组GC回收时间数据</p><ol><li>YGC <code>9320 : 43895</code>，次数减少 4.7倍</li><li>YGCT <code>494.982 : 1313.261</code>， 减少 2.6倍</li><li>GCT <code>517.549: 1318.467</code>，减少 2.5 倍</li><li>FGC <code>222 : 60</code> 却增加了 3.7 倍的次数</li></ol><p>这有点出乎意料，如果新生代空间够大之后，对象有足够的新生代空间可以分配对象，保证尽可能多的对象在新生代中被回收，熬不到老年代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最近排查一个历史老问题，历史问题就是大家都知道，但是没人愿意处理。&lt;br&gt;线上节点 16 和 32 G 内存频繁的出现GC，并且由于 GC 
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="jvm" scheme="https://liukay.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="jvm" scheme="https://liukay.com/tags/jvm/"/>
    
      <category term="gc" scheme="https://liukay.com/tags/gc/"/>
    
      <category term="cms" scheme="https://liukay.com/tags/cms/"/>
    
      <category term="调优" scheme="https://liukay.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>区块链--04coinbase交易</title>
    <link href="https://liukay.com/posts/3428.html"/>
    <id>https://liukay.com/posts/3428.html</id>
    <published>2021-05-24T02:56:14.000Z</published>
    <updated>2021-11-10T06:30:57.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>coinbase交易，也是被打包在区块中的第一笔交易，只是这笔是区块的第一笔交易，是挖矿产生的奖励。</p></blockquote><h2 id="查看-coinbase交易"><a href="#查看-coinbase交易" class="headerlink" title="查看 coinbase交易"></a>查看 coinbase交易</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://api.blockcypher.com/v1/btc/main/txs/1a44cb6551af919652eac49d953c50ab2acb1ebdfe7d2b20ed3c1944bd37ac96</span><br></pre></td></tr></table></figure><h2 id="coinbase-结构"><a href="#coinbase-结构" class="headerlink" title="coinbase 结构"></a>coinbase 结构</h2><p>可以很明显的看到，除了公共字段外，有 outputs、inputs 两个字段。</p><ol><li>outputs: 交易输出</li><li>inputs: 交易输入</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  block_hash: &quot;00000000000000000000bca6ccc2ef309fd814f80a55b3e08a4212326137d7d2&quot;,</span><br><span class="line">  block_height: 681181,</span><br><span class="line">  block_index: 0,</span><br><span class="line">  hash: &quot;1a44cb6551af919652eac49d953c50ab2acb1ebdfe7d2b20ed3c1944bd37ac96&quot;,</span><br><span class="line">  addresses: [</span><br><span class="line">    <span class="string">&quot;1KFHE7w8BhaENAswwryaoccDb6qcT6DbYY&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  total: 680382463,</span><br><span class="line">  fees: 0,</span><br><span class="line">  size: 378,</span><br><span class="line">  vsize: 351,</span><br><span class="line">  preference: &quot;low&quot;,</span><br><span class="line">  confirmed: &quot;2021-04-30T05:03:17.197Z&quot;,</span><br><span class="line">  received: &quot;2021-04-30T05:03:17.197Z&quot;,</span><br><span class="line">  ver: 1,</span><br><span class="line">  lock_time: 1241604347,</span><br><span class="line">  double_spend: false,</span><br><span class="line">  vin_sz: 1,</span><br><span class="line">  vout_sz: 4,</span><br><span class="line">  opt_in_rbf: true,</span><br><span class="line">  data_protocol: &quot;unknown&quot;,</span><br><span class="line">  confirmations: 3552,</span><br><span class="line">  confidence: 1,</span><br><span class="line">  inputs: [</span><br><span class="line">    &#123;</span><br><span class="line">      output_index: -1,</span><br><span class="line">      script: &quot;03dd640a2cfabe6d6ddc65590fdf47b7f8d0805179ce336bb1dfb8fc6697e67bac15286de7910b4a7610000000f09f909f082f4632506f6f6c2f114d696e6564206279206c67316467737472000000000000000000000000000000000000050000000000&quot;,</span><br><span class="line">      sequence: 420554726,</span><br><span class="line">      script_type: &quot;empty&quot;,</span><br><span class="line">      age: 681181</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  outputs: [</span><br><span class="line">    &#123;</span><br><span class="line">      value: 680382463,</span><br><span class="line">      script: &quot;76a914c825a1ecf2a6830c4401620c3a16f1995057c2ab88ac&quot;,</span><br><span class="line">      spent_by: &quot;e80511c1ed5deec12f50d918614a94145d3089f269e33522a0aa72b0054a5c96&quot;,</span><br><span class="line">      addresses: [</span><br><span class="line">        <span class="string">&quot;1KFHE7w8BhaENAswwryaoccDb6qcT6DbYY&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      script_type: &quot;pay-to-pubkey-hash&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: 0,</span><br><span class="line">      script: &quot;6a24aa21a9ed24ea773c9b58e4a4ad4c14ae4b75ff79cb1adbb08b0d3960d532d655414030dc&quot;,</span><br><span class="line">      addresses: null,</span><br><span class="line">      script_type: &quot;null-data&quot;,</span><br><span class="line">      data_hex: &quot;aa21a9ed24ea773c9b58e4a4ad4c14ae4b75ff79cb1adbb08b0d3960d532d655414030dc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: 0,</span><br><span class="line">      script: &quot;6a3448617468ae18c94d8ebfbebe1e8a6567fee08b7023579133e65a4ad2ac48ef7c13b6f444a3bf7eac9e8b418186649d337d64fee1&quot;,</span><br><span class="line">      addresses: null,</span><br><span class="line">      script_type: &quot;null-data&quot;,</span><br><span class="line">      data_hex: &quot;48617468ae18c94d8ebfbebe1e8a6567fee08b7023579133e65a4ad2ac48ef7c13b6f444a3bf7eac9e8b418186649d337d64fee1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      value: 0,</span><br><span class="line">      script: &quot;6a24b9e11b6d267720bd57a3442dd397de915eb9c2d46e3dc90633755d504e5458ef23804ff2&quot;,</span><br><span class="line">      addresses: null,</span><br><span class="line">      script_type: &quot;null-data&quot;,</span><br><span class="line">      data_hex: &quot;b9e11b6d267720bd57a3442dd397de915eb9c2d46e3dc90633755d504e5458ef23804ff2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总体结构说明"><a href="#总体结构说明" class="headerlink" title="总体结构说明"></a>总体结构说明</h2><table><thead><tr><th style="text-align:center">字节</th><th style="text-align:center">字段</th><th style="text-align:center">字段说明</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">ver</td><td style="text-align:center">交易版本号</td><td style="text-align:center">明确这笔交易参照的规则</td></tr><tr><td style="text-align:center">1-9</td><td style="text-align:center">vin_sz</td><td style="text-align:center">输入计数器</td><td style="text-align:center">包含的交易输入数量</td></tr><tr><td style="text-align:center">不定</td><td style="text-align:center">inputs</td><td style="text-align:center">交易输入</td><td style="text-align:center">一个或多个交易输入</td></tr><tr><td style="text-align:center">1-9</td><td style="text-align:center">vout_sz</td><td style="text-align:center">输出计数器</td><td style="text-align:center">包含的交易输出数量</td></tr><tr><td style="text-align:center">不定</td><td style="text-align:center">outputs</td><td style="text-align:center">交易输出</td><td style="text-align:center">一个或多个交易输出</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">lock_time</td><td style="text-align:center">锁定时间</td><td style="text-align:center">一个区块号或UNIX时间戳</td></tr></tbody></table><h3 id="inputs-交易输入"><a href="#inputs-交易输入" class="headerlink" title="inputs 交易输入"></a>inputs 交易输入</h3><table><thead><tr><th style="text-align:center">字节长度</th><th style="text-align:center">字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">32</td><td style="text-align:center">交易哈希值</td><td style="text-align:center">固定为全0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">输出索引</td><td style="text-align:center">固定为全1</td></tr><tr><td style="text-align:center">1-9</td><td style="text-align:center">Coinbase脚本长度</td><td style="text-align:center">coinbase的脚本字节长度</td></tr><tr><td style="text-align:center">不定</td><td style="text-align:center">coinbase脚本</td><td style="text-align:center">coinbase脚本，可以任意填充</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">序列号</td><td style="text-align:center">固定值0xFFFFFFFF</td></tr></tbody></table><h3 id="outputs-交易输出"><a href="#outputs-交易输出" class="headerlink" title="outputs 交易输出"></a>outputs 交易输出</h3><table><thead><tr><th style="text-align:center">字节长度</th><th style="text-align:center">字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">字节长度</td><td style="text-align:center">字段</td><td style="text-align:center">说明</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">总量</td><td style="text-align:center">用聪表示的比特币值</td></tr><tr><td style="text-align:center">1-9</td><td style="text-align:center">锁定脚本大小</td><td style="text-align:center">用字节表示的后面的锁定脚本长度</td></tr><tr><td style="text-align:center">不定</td><td style="text-align:center">锁定脚本</td><td style="text-align:center">一个定义了支付输出所需条件的脚本</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;coinbase交易，也是被打包在区块中的第一笔交易，只是这笔是区块的第一笔交易，是挖矿产生的奖励。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;查看-coinbase交易&quot;&gt;&lt;a href=&quot;#查看-coinbase交易&quot; class=&quot;
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="coinbase交易" scheme="https://liukay.com/tags/coinbase%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>区块链--05比特币区块同步机制</title>
    <link href="https://liukay.com/posts/15476.html"/>
    <id>https://liukay.com/posts/15476.html</id>
    <published>2021-04-29T03:41:28.000Z</published>
    <updated>2021-11-10T06:37:38.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>一个区块生产出来之后，需要进行同步给其它的节点。由于区块链是去中心化的，所以所有节点都保留相同的全量数据。<br>当一个区块打包好一个区块后，需要同步给其它节点，进行校验 和 上链。<br>只有上链的成功的区块，才算是区块链上的一个块。换句话说，区块可能上链成功，也有可能上链不成功。</p></blockquote><h2 id="同步区块中的问题"><a href="#同步区块中的问题" class="headerlink" title="同步区块中的问题"></a>同步区块中的问题</h2><ol><li>为什么要同步区块</li><li>如何保证同步</li><li>网络延迟如何解决</li><li>同时收到相同高度的块，该同步谁的块</li><li>如何得知块已被确认</li><li>被丢块的节点会怎么样</li></ol><h2 id="区块打包"><a href="#区块打包" class="headerlink" title="区块打包"></a>区块打包</h2><h2 id="区块广播"><a href="#区块广播" class="headerlink" title="区块广播"></a>区块广播</h2><h2 id="区块验证"><a href="#区块验证" class="headerlink" title="区块验证"></a>区块验证</h2><h2 id="区块上链"><a href="#区块上链" class="headerlink" title="区块上链"></a>区块上链</h2><h2 id="区块回滚"><a href="#区块回滚" class="headerlink" title="区块回滚"></a>区块回滚</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一个区块生产出来之后，需要进行同步给其它的节点。由于区块链是去中心化的，所以所有节点都保留相同的全量数据。&lt;br&gt;
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="BTC" scheme="https://liukay.com/categories/blockchain/BTC/"/>
    
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="比特币" scheme="https://liukay.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链--04交易广播和打包上链</title>
    <link href="https://liukay.com/posts/42563.html"/>
    <id>https://liukay.com/posts/42563.html</id>
    <published>2021-04-27T06:00:28.000Z</published>
    <updated>2021-11-10T06:33:59.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h2><p>BTC 的一笔交易，需要执行哪些流程，生命周期又是怎么样的？这个很重要，首先需要了解整体大流程，再看细节。<br>比特币是一个网络，网络中所有的数据，在各个节点之前的数据是全量的。<br>当 A 给 B 转账时，通过客户端会广播这笔交易后，这笔交易的广播数据将会被全网的节点收到。最后打包进区块，再广播到所有节点进行验证。</p><h3 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h3><ol><li>产生新交易</li><li>签名加密</li><li>交易在比特币网络中传播</li><li>整合交易&amp;构建新区块</li><li>所有节点确认区块</li><li>新区块连接到区块链</li></ol><h2 id="交易创建"><a href="#交易创建" class="headerlink" title="交易创建"></a>交易创建</h2><p>A 要给 B 发起一笔交易，首先要创建这笔交易。<br>创建是通过比特币节点的钱包应用来负责的，如<code>BitCore</code>钱包。</p><p>构建一笔交易，需要理解创建交易的细节，先理解4个概念：</p><ol><li>UTXO</li><li>交易输出</li><li>交易输入</li><li>交易费</li></ol><h3 id="UTXO-Unspent-Transaction-output"><a href="#UTXO-Unspent-Transaction-output" class="headerlink" title="UTXO  Unspent Transaction output"></a>UTXO  Unspent Transaction output</h3><p>UTXO: 未被使用的交易输出。大白话：账户余额。<br>UTXO 是一个重要的核心概念之一，本质就是交易记录。因为比的交易并不是基本<code>账户模型</code>，即没有我们传统理解的类似于银行账户的概念。</p><h4 id="为什么叫-未被使用的交易输出"><a href="#为什么叫-未被使用的交易输出" class="headerlink" title="为什么叫 未被使用的交易输出"></a>为什么叫 未被使用的交易输出</h4><p>因为没有传统的账户模型，所以账户余额并不是传统上的账户余额，但是又必须定义当前余额的来源，所以称之为未使用的余额。<br>比如：Alice 当前账户有 10 BTC，称不能称之为10个余额，而是称之为10个未被使用的交易输出。</p><p>有输出，那必须有输入。<br>输出：你给别人转钱<br>输出：别人给你转账</p><p>另外，需要注意的一点是，比特币节点在创建交易的时候，可以在离线状态下进行。这个时候创建的交易暂时不会被传播到网络上，无法被网所感知，所以这笔交易会被存储在节点中的一个叫做孤立交易池的地方。而如果比特币节点在联网状态下创建的交易，交易创建完成后，就会被传播到比特币网络上，这样的话，交易就会被网络感知到，存储到每个节点的交易池中。</p><h2 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a>交易广播</h2><h2 id="交易打包"><a href="#交易打包" class="headerlink" title="交易打包"></a>交易打包</h2><p>交易如何打包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;交易流程&quot;&gt;&lt;a href=&quot;#交易流程&quot; class=&quot;headerlink&quot; title=&quot;交易流程&quot;&gt;&lt;/a&gt;交易流程&lt;/h2&gt;&lt;p&gt;BTC 的一笔交易，需要执行哪些流程，生命周期又是怎么样的？这个很重要，首先需要了解整体大流程，再看细节。&lt;br&gt;比特币是一
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="BTC" scheme="https://liukay.com/categories/blockchain/BTC/"/>
    
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="交易" scheme="https://liukay.com/tags/%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title>区块链--03比特币区块结构</title>
    <link href="https://liukay.com/posts/38615.html"/>
    <id>https://liukay.com/posts/38615.html</id>
    <published>2021-04-20T03:23:16.000Z</published>
    <updated>2021-11-10T06:30:24.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><blockquote><p>区块链开发之前，先了解比特币的区块结构，有利于了解后续比特币的各种数据结构的做用。</p></blockquote><p>本文要介结几个重要概念：</p><ol><li>区块结构</li><li>区块头</li><li>区块体</li><li>区块查看工具</li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>区块是比特币的核心。<br>当前比特币网络，每10分产一个块。<br>区块的作用: 比特币最核心的数据结构，包含了交易的重要标识，包括：区块头、区块体、区块大小等数据。</p><h3 id="一个完整的区块结构"><a href="#一个完整的区块结构" class="headerlink" title="一个完整的区块结构"></a>一个完整的区块结构</h3><table><thead><tr><th style="text-align:center">数据项</th><th style="text-align:center">字节</th><th style="text-align:center">字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Magic NO</td><td style="text-align:center">4</td><td style="text-align:center">魔数</td><td style="text-align:center">常数0xD9B4BEF9</td></tr><tr><td style="text-align:center">Blocksize</td><td style="text-align:center">4</td><td style="text-align:center">区块大小</td><td style="text-align:center">用字节表示的该字段之后的区块大小</td></tr><tr><td style="text-align:center">Blockheader</td><td style="text-align:center">80</td><td style="text-align:center">区块头</td><td style="text-align:center">组成区块头的几个字段</td></tr><tr><td style="text-align:center">Transaction counter</td><td style="text-align:center">1-9</td><td style="text-align:center">交易计数器</td><td style="text-align:center">该区块包含的交易数量，包含coinbase交易</td></tr><tr><td style="text-align:center">Transactions</td><td style="text-align:center">不定</td><td style="text-align:center">交易</td><td style="text-align:center">记录在区块里的交易信息，使用原生的交易信息格式，并且交易在数据流中的位置必须与Merkle树的叶子节点顺序一致</td></tr></tbody></table><p><img src="/posts/38615/区块.jpeg" alt="区块"></p><p>这里最典型的要数 <strong>区块头</strong>和 <strong>区块体</strong> 了，因为它们通常在学习区块链的时候，比较能说明区块链的重要特性。</p><p>另外区块链不看不见摸不着的东西，人往往需要可视化的模型会更有助于理解抽象的概念。</p><p>这里介绍一个工具，区块链浏览器：<br><a href="https://blockchain.info/">https://blockchain.info/</a></p><p> 通过这个浏览器，可以查看区块内的信息。<br> 为什么这个站点可以查看区块信息？<br> 因为区块链的服务，也就是个服务，提供了查询接口，机构或个人，只需要运行区块链服务，在本地运行就可以访问区块链信息，前提是要同步好区块数据。<br> 之前的文章就强调过，鼓励大家运行区块链服务是区块链的特点，币是奖励，算是一种副产物，是被金融机构炒起来的。</p><h3 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h3><p><strong>查看区块信息</strong>￼</p><blockquote><p>getblock  00000000000000000000bca6ccc2ef309fd814f80a55b3e08a4212326137d7d2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hash&quot;: &quot;00000000000000000000bca6ccc2ef309fd814f80a55b3e08a4212326137d7d2&quot;,</span><br><span class="line">  &quot;confirmations&quot;: 30,</span><br><span class="line">  &quot;strippedsize&quot;: 884103,</span><br><span class="line">  &quot;size&quot;: 1345977,</span><br><span class="line">  &quot;weight&quot;: 3998286,</span><br><span class="line">  &quot;height&quot;: 681181,</span><br><span class="line">  &quot;version&quot;: 536870912,</span><br><span class="line">  &quot;versionHex&quot;: &quot;20000000&quot;,</span><br><span class="line">  &quot;merkleroot&quot;: &quot;574dfd1961a53bb1fd307d7345b2aff6a196cce29a824b9029d454e1f61cfb35&quot;,</span><br><span class="line">  &quot;tx&quot;: [</span><br><span class="line">    &quot;1a44cb6551af919652eac49d953c50ab2acb1ebdfe7d2b20ed3c1944bd37ac96&quot;,</span><br><span class="line">    &quot;3e06d35f7f550068a72991d62dd32281a13e1492867b1c8531a4aa12f591cff8&quot;,</span><br><span class="line">    &quot;9d66b3a4b6b683aa4d03d8186d31d33e41e73bd96692cbf33a152b99100b326a&quot;,</span><br><span class="line">    &quot;ae6fdde3a16e91d587a5d3c1500d5828a01e69c02b6832cde132111fd90c4760&quot;,</span><br><span class="line">    &quot;91a5aa20c0582695a90cfdf4dab5540406c9b78fba4a20f6cd6cb96445d31be5&quot;,</span><br><span class="line">    &quot;471ce26f56eb1c164315704b923a1095145256c0e43a77ccd72254265c950b0f&quot;,</span><br><span class="line">    &quot;fb56a184da1cff5e8c0cc65c13392c68517713754338f87047bef07c1a43b032&quot;,</span><br><span class="line">    &quot;8be8b938eff96313ee9e61c287fdffea2779c0537d2f0ccd7fc1e973693fd12b&quot;,</span><br><span class="line">    &quot;d12faee60ec1f46f2bdd6a490b1c92c2e804955786a014b56d8fb9e6d2a35eef&quot;,</span><br><span class="line">    &quot;819f0fb4a16a3f88079bf35f6f03c0b032879a75f56b412baedfe525e19708f4&quot;,</span><br><span class="line">    &quot;dcc9e980cd345e9a6e136d76a4cd36a36bb7e3217b3685ad9ca577acc8019bf8&quot;,</span><br><span class="line">    &quot;6a1a122610ff86d6037d46e57c49183960bcefad04ea233a387fc3d8a0db997b&quot;,</span><br><span class="line">    &quot;23dab800d04d100b2748b2addec5237b75ad6da992de80984f95d8decd546859&quot;</span><br><span class="line">    &#x2F;&#x2F;省略部份交易</span><br><span class="line">  ],</span><br><span class="line">  &quot;time&quot;: 1619758979,</span><br><span class="line">  &quot;mediantime&quot;: 1619755004,</span><br><span class="line">  &quot;nonce&quot;: 32721792,</span><br><span class="line">  &quot;bits&quot;: &quot;170bef93&quot;,</span><br><span class="line">  &quot;difficulty&quot;: 23581981443663.85,</span><br><span class="line">  &quot;chainwork&quot;: &quot;00000000000000000000000000000000000000001cb2cd894a35651ba07be168&quot;,</span><br><span class="line">  &quot;nTx&quot;: 2158,</span><br><span class="line">  &quot;previousblockhash&quot;: &quot;00000000000000000004cabf7ba2626c0da40182c19324ea12c13b2aac8ade98&quot;,</span><br><span class="line">  &quot;nextblockhash&quot;: &quot;000000000000000000058960a47748b02e4b659ba529a0e9c6fb9e1991158f6f&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含以下数据:</p><table><thead><tr><th style="text-align:center">字节长度</th><th style="text-align:center">字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">version</td><td style="text-align:center">区块版本号</td></tr><tr><td style="text-align:center">32</td><td style="text-align:center">previousblockhash</td><td style="text-align:center">前一个区块头的哈希值</td></tr><tr><td style="text-align:center">32</td><td style="text-align:center">merkleroot</td><td style="text-align:center">Merkle根哈希，交易列表生成的默克尔树根哈希</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">time</td><td style="text-align:center">时间戳，该区块产生的近似时间，精确到秒的UNIX时间戳</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">bits</td><td style="text-align:center">难度目标，挖矿难度值</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Nonce</td><td style="text-align:center">挖矿过程中使用的随机值</td></tr></tbody></table><p>区块头中的数据分成三不同的意义：</p><ol><li>区块元数据</li><li>打包相关元数据</li><li>交易树据根</li></ol><h4 id="1-区块元数据"><a href="#1-区块元数据" class="headerlink" title="1.区块元数据"></a>1.区块元数据</h4><ol><li>父哈希(前一个块）</li><li>版本号<br>即前区块的上一个区块，就是父区块(前一个块)的哈希值，父哈希值用来将该区块与它的前一区块相连接；</li></ol><h4 id="2-打包相关元数据"><a href="#2-打包相关元数据" class="headerlink" title="2.打包相关元数据"></a>2.打包相关元数据</h4><ol><li>难度</li><li>时间戳</li><li>Nonce(随机数）</li></ol><h4 id="3-交易树据根"><a href="#3-交易树据根" class="headerlink" title="3.交易树据根"></a>3.交易树据根</h4><p>这个根在区块头中就是根哈希值，即区块体中的默克尔树的根。</p><h3 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h3><p>区块体包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过默克尔（Merkle）树的哈希过程生成唯一的默克尔，根并记入区块头。<br>区块体，包含交易数据。<br>比特币中的交易比较简单，就是转账，A -&gt; B 转账，这笔交易从比特币客户端发起后，就会进行广播。<br>比特币的节点收到交易后，会将交易存储到交易队列当中，直到进行打包时才会将交易队列中的交易，打包其实是构建一个数据结构，包括：</p><p><strong>默克尔树</strong><br>当前区块的交易集合而生成的一颗树，目的是通过每一笔交易，从下往上生成一树哈希树。<br>自下往上看：<br><img src="/posts/38615/默克尔树.jpeg" alt="默克尔树"></p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>就是字面意思，由一个个区块组成的链条。<br>创世块：比特币网络中的第一个块。几乎所有的区块链服务，都有创有块。<br>学习区块链，就必须了解区块的本质，区块链的是由一个一个区块组成的链条。</p><p>区块链是逻辑上的链条，每一个区块之间通过确认父哈希的形式，来确定自己的父块。<br><img src="/posts/38615/区块链结构.jpeg" alt="区块链结构"></p><p>那么这样就会产生几个问题？</p><ol><li>区块链网络中有很多的节点同时产块，该确认谁才是下一个节点？</li><li>如果 A 先产块，B 后产块，但是 A 的网速有延迟，传输比 B 后到达，其他节点怎么处理 A 的区块？</li><li>如何保证传输过来的块一定是合法块，不是一个恶意节点广播过来的块 或者 没有被恶意修过过的块？</li></ol><p>比特币是如何解决上述这些问题的。</p><p>综上，比特币的区块头 和 区块体 是紧密相连的数据结构，缺一不可。</p><h2 id="bitcore-区块链钱包"><a href="#bitcore-区块链钱包" class="headerlink" title="bitcore 区块链钱包"></a>bitcore 区块链钱包</h2><p>比特币的工具有很多，PC端常用的工具就是比特币钱包。钱包的种类也有不少，可以查看比特币官网，这里用的是 bitcore。<br>通过命令行窗口，可以执行一些命令来看查看比特币相关的数据。<br><strong>查看区块信息</strong></p><blockquote><p>getblock 00000000000000000000bca6ccc2ef309fd814f80a55b3e08a4212326137d7d2</p></blockquote><p><img src="/posts/38615/工具.jpg" alt="钱包工具"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区块结构&quot;&gt;&lt;a href=&quot;#区块结构&quot; class=&quot;headerlink&quot; title=&quot;区块结构&quot;&gt;&lt;/a&gt;区块结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;区块链开发之前，先了解比特币的区块结构，有利于了解后续比特币的各种数据结构的做用。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="BTC" scheme="https://liukay.com/categories/blockchain/BTC/"/>
    
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="BTC" scheme="https://liukay.com/tags/BTC/"/>
    
      <category term="比特币" scheme="https://liukay.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链--02比特币技术体系</title>
    <link href="https://liukay.com/posts/17877.html"/>
    <id>https://liukay.com/posts/17877.html</id>
    <published>2021-04-17T03:53:03.000Z</published>
    <updated>2021-11-11T07:29:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习区块链技术，首先应该了解最经典的 比特币。比特币做为最早的分布式去中心化的区块链应用，其经典设计值得学习。</p></blockquote><h2 id="比特币架构"><a href="#比特币架构" class="headerlink" title="比特币架构"></a>比特币架构</h2><p>比特币通过将各项技术进行结合，创造出来的这个产品，其本质的功能是记账，副做用是炒。<br>比特币的设计是为了保证所有数据是分布式的、去中心化的保存数据，防止数据在中心的节点中保存。</p><p><img src="/posts/17877/BTC架构图.jpeg" alt="架构图"></p><p>自上而下，共分6层</p><ol><li>应用层</li><li>RPC 层</li><li>网络层</li><li>共识层</li><li>数据层</li><li>存储层</li></ol><h3 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1.应用层"></a>1.应用层</h3><p>包括比特币钱包、客户端等种上层的应用，一般是比特币程序本身的外部应用。<br>以比特币钱包为例，比特币钱包有很多种，可以上官网上下载不同钱包，比如最简单的钱包，早期这个钱包还保留有CPU挖矿功能。现在版本已不支持，可以参考官方 Github 文档:</p><p><a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.13.0.md">https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.13.0.md</a><br><img src="/posts/17877/BTC钱包.jpg" alt="PC钱包"></p><h3 id="2-RPC-层"><a href="#2-RPC-层" class="headerlink" title="2.RPC 层"></a>2.RPC 层</h3><p>RPC 层的作用是进行RPC 通信。测试可以使用 BitCore 这个工具来进行测试。</p><p>测试一个 RPC 命令，查看区块信息: <strong>getblockchaininfo</strong><br><strong>命令行</strong><br><img src="/posts/17877/命令行.jpg" alt="钱包"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;chain&quot;</span>: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;blocks&quot;</span>: <span class="number">680816</span>,</span><br><span class="line">  <span class="attr">&quot;headers&quot;</span>: <span class="number">680816</span>,</span><br><span class="line">  <span class="attr">&quot;bestblockhash&quot;</span>: <span class="string">&quot;0000000000000000000133b07fdf287ddca3cca80162b4a06a05d6904190cd37&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span>: <span class="number">23581981443663.85</span>,</span><br><span class="line">  <span class="attr">&quot;mediantime&quot;</span>: <span class="number">1619518237</span>,</span><br><span class="line">  <span class="attr">&quot;verificationprogress&quot;</span>: <span class="number">0.999995596389184</span>,</span><br><span class="line">  <span class="attr">&quot;initialblockdownload&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;chainwork&quot;</span>: <span class="string">&quot;00000000000000000000000000000000000000001c943902d1cf6cdd1387c75c&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;size_on_disk&quot;</span>: <span class="number">1904190175</span>,</span><br><span class="line">  <span class="attr">&quot;pruned&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;pruneheight&quot;</span>: <span class="number">679647</span>,</span><br><span class="line">  <span class="attr">&quot;automatic_pruning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prune_target_size&quot;</span>: <span class="number">1999634432</span>,</span><br><span class="line">  <span class="attr">&quot;softforks&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bip34&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;buried&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;active&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;height&quot;</span>: <span class="number">227931</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;bip66&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;buried&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;active&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;height&quot;</span>: <span class="number">363725</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;bip65&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;buried&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;active&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;height&quot;</span>: <span class="number">388381</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;csv&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;buried&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;active&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;height&quot;</span>: <span class="number">419328</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;segwit&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;buried&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;active&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;height&quot;</span>: <span class="number">481824</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;warnings&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h3><p>网络层使用 Peer-to-Peer，即点对点通信。每个BTC网络当中的节点中的通信，没有中心化的节点进行转发，需要通过节点发现，进行通信。<br>这也体现出BTC网络中当，每个节点都是平等的节点，没有哪个节点可以控制其他节点。</p><p>这种去中心化的好处就是可以做到节点之间的平等，但是也存在几个问题。</p><ol><li>网络延迟</li><li>联合作敝</li></ol><p>3.1 网络延迟很好理解，由于节点之间是平等的，每个节点都会呈现为网状的连接，当一个区块被生产出来后，会同步到相邻的网络节点当中，进行相邻转发。并不是通过中心节点订阅或转发的，一个区块到达所有的节点会有网络延迟。</p><p>3.2 联合作敝，去中心化的通信，节点间的数据只能依赖于依赖于各个节点间的验证，那就给做敝留下了空间。</p><h3 id="4-共识层"><a href="#4-共识层" class="headerlink" title="4.共识层"></a>4.共识层</h3><p>什么是共识，这个非常重要，非常重要。<br>因为在平等的网络当中，每个节点都是分散的，该如何保证每个节点的验证、转发是一致？<br>这就需要每个节点与节点之间达成共识。以此来保证所有节点的行为一致。</p><p><strong>什么是共识</strong><br>共识就是，共识即认可，比特币中有很多节点，要让这些节点达成一致性，比特币采用的是：POW 工作量证明。<br>比特币共识：说白点就是大家通过计算一个随机生成的Hash值的方式，来决定谁先打包。是不是感觉没什么，计算这个Hash并不是一件马上就可以算出来的事情。<br>大概流程：</p><ol><li>所有比特币中的交易会向所有节点广播，所有节点接收到交易后，放于交易队列当中</li><li>全世界所有节点通过计算 Hash 来决定谁交这些交易打包，先算出者，打包交易成一个区块并广播区块</li><li>打包者，将一个随机数加处块头中，使得计算的哈希结果小于或等于块头中目标值</li><li>其他节点收到区块后，验证区块和区块内的交易，验证正确保留该区块</li></ol><p><strong>为什么要给一个随机Hash数来给节点计算</strong><br>为了证明这个块的正确性。比特币的区块链当中，第一个节点产生的第一个块叫做：创世块，这个块是比特币运行时产生的第一个块，这个块会产生一个随机Hash数，打包进第一个块的块头中，然后广播。<br>其他节点收到区块后，对这个创世块进行验证。先验出者，证明了这个块是正确的，然后根据这个创建块，将收到的交易进行打包，并链接到这个创世块后面，就成了第二个块，并且这个节点也根据收到的交易产生了个随机Hash，广播给其它节点。<br>其他节点收到后，重复这个流程，证明这个块的正确性，并进行上链。这个就是 POW 的义意。</p><h3 id="5-数据层"><a href="#5-数据层" class="headerlink" title="5.数据层"></a>5.数据层</h3><p>数据层是指比特币的数据结构。比特币的数据结构比较典型，很多后来的区块链都借鉴这些数据模型。</p><ol><li>区块</li><li>区块链</li><li>Merkle树，也称，默克尔树</li><li>Hash</li><li>时间戳</li></ol><h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p>是指将交易进行打构的区块数据结构，包含：区块头、区块体、哈希、时间戳 等。</p><h4 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h4><p>是指由区块构成的链条，就是指区块链，比较直白。</p><h4 id="Merkle树，也称，默克尔树"><a href="#Merkle树，也称，默克尔树" class="headerlink" title="Merkle树，也称，默克尔树"></a>Merkle树，也称，默克尔树</h4><p>Merkle树的作用：防窜改。<br>这里仅需要知道即可，这些点每一个展开都是一个大点，后续会做很详细的讲解。<br>Merkle树的构成是通过将每一笔交易的哈希，自上而下，相邻两个节点向上构建出一个新的父哈希值，由此来构建一棵哈希树。</p><h3 id="6-存储层"><a href="#6-存储层" class="headerlink" title="6.存储层"></a>6.存储层</h3><p>存储主要使用的是 LevelDB，进行存储，LevelDB 是基于 SSTable 进行设计实现的一个数据引擎。很多数据库都是基 LevelDB 进开发。<br>LevelDB 本身具体高性能读写，通过在内存缓存 和 多层级文件存储而取名 LevelDB。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习区块链技术，首先应该了解最经典的 比特币。比特币做为最早的分布式去中心化的区块链应用，其经典设计值得学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;比特币架构&quot;&gt;&lt;a href=&quot;#比特币架构&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="BTC" scheme="https://liukay.com/categories/blockchain/BTC/"/>
    
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="比特币" scheme="https://liukay.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="技术体系" scheme="https://liukay.com/tags/%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>区块链--01区块链初识</title>
    <link href="https://liukay.com/posts/64659.html"/>
    <id>https://liukay.com/posts/64659.html</id>
    <published>2021-04-14T10:50:49.000Z</published>
    <updated>2021-11-10T06:32:50.231Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>区块链技术，发展到目前，主流的区块链有两个代表，一个是以 比特币(BTC) 为代表的分布式去中心化记账本，一个是以 以态坊(ETH) 为代表的图灵完备的分布式去中心化计算机。名词解释会放到下面。</p></blockquote><h2 id="为什么写这个文章"><a href="#为什么写这个文章" class="headerlink" title="为什么写这个文章"></a>为什么写这个文章</h2><p>投身加密货币研究有一段时间了，其间了解到了比特币的原理和应用，想把了解到的知识整理成一个简单直白的系列科普文章，希望可以帮助大家轻松简单学习并使用加密货币。<br>本篇作为开篇，仅提一些简单概念，以免概念太多，让人望而却步。</p><h2 id="加密货币"><a href="#加密货币" class="headerlink" title="加密货币"></a>加密货币</h2><p>加密货币当下有两种主流的技术模型：</p><ol><li>比特币</li><li>以太坊</li></ol><p>这两种加密货币有本质的区别，之所以很少听说以太坊，是因为以太坊出现的在比特币之后，出现在人们的视野里比较晚，但是其设计理念相较比特币较超前，当前和比特币并驾齐驱。<br>现在主流的一些币都是基于以太坊的基础上进行设计，还可以基于以太坊发行自己的货币，在这里不用深究，后续会深入讲解。</p><h2 id="比特币-Bitcoin"><a href="#比特币-Bitcoin" class="headerlink" title="比特币(Bitcoin)"></a>比特币(Bitcoin)</h2><blockquote><p>本质是分布式记账本</p></blockquote><p>比特币的宗旨是做为一个去中心化的分布试记账本，仅为了记账而存在。<br>比特币的由来就不赘述，可自行了解。<br>BTC是一种点对点（Peer-2-Peer）传输的数字加密货币。宗旨在于使用点网络节点，构成一个分布式、去中心化的加密货币网络。<br>机器只需要运行 BTC 程序，就可以加入到比特币网络当中，成为一个节点，每个节点同步保存全量数据，所以硬盘容量要大。</p><p><strong>官网</strong> <a href="https://bitcoin.org/zh_CN/">https://bitcoin.org/zh_CN/</a></p><h3 id="1-本质"><a href="#1-本质" class="headerlink" title="1.本质"></a>1.本质</h3><p>是一个分布式、去中心化账本！！<br>记账才是其主要功能，奖励的币仅是副产物。</p><h3 id="2-币是什么"><a href="#2-币是什么" class="headerlink" title="2.币是什么"></a>2.币是什么</h3><p>币，是每个机器运行比特币服务而获得的奖励，鼓励大家都运行节点，保存数据。就像是去玩某个游戏，每日登陆获取积分一样。<br>每个机器节点的硬盘上保留全量数据，就可以不依赖于中心化节点中的数据，从而实现去中心化。<br>每个用户下载 BTC 的钱包服务运行，注册钱包，生成私钥，私钥需要保管好。并配上自己的钱包地址。</p><h3 id="3-如何获得一个比特币"><a href="#3-如何获得一个比特币" class="headerlink" title="3.如何获得一个比特币"></a>3.如何获得一个比特币</h3><p>谁打包谁获得比特币奖励。<br>比特币的将励不是公平的，而是一有套获取奖励的规则，并不是运行的久的节点一定获得奖励。而在于你的计算机的算力。<br>比特币规定，所有记账节点都有资格打包，但是需要算出一道数学题，谁先算出来，谁就有资格打包，打包的节点就会获得奖励。<br>这种模式即：<strong>POW 工作量证明</strong></p><h3 id="4-比特币白皮书"><a href="#4-比特币白皮书" class="headerlink" title="4.比特币白皮书"></a>4.比特币白皮书</h3><p><a href="https://bitcoin.org/bitcoin.pdf">比特币白皮书原版</a><br>当然还有中文版。</p><h3 id="比特币泛汲到的技术"><a href="#比特币泛汲到的技术" class="headerlink" title="比特币泛汲到的技术"></a>比特币泛汲到的技术</h3><p><strong>结构图</strong><br><img src="/posts/64659/BTC.jpeg" alt="结构图"><br>比特币并没有发明什么新技术，而是将已有的技术进行一个融合。</p><ol><li>加密技术</li><li>P2P 通信(点对点)</li><li>共识</li><li>存储</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h2 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h2><blockquote><p>区块链世界中的计算机。</p></blockquote><p>如果说 比特币 是一个分布式、去中心化账本，那以太坊就是一台分布式去中心化，运行在计算机上的微型计算机。<br>其设计架构就是图灵完备的设计，本质是一套程序，但是它有计算机一样的：输入、输出、执行指令，因此可以说是图灵完备的。</p><h3 id="以太坊架构图"><a href="#以太坊架构图" class="headerlink" title="以太坊架构图"></a>以太坊架构图</h3><p><img src="/posts/64659/架构图.png" alt="架构图"></p><h3 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h3><ol><li>智能合约</li><li>加密技术</li><li>P2P 通信(点对点)</li><li>共识</li><li>存储</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>以太坊在设计上和比特币目的相同，但是在很多设计上又有很多的不同。</p><h4 id="1-可编程"><a href="#1-可编程" class="headerlink" title="1.可编程"></a>1.可编程</h4><p>以太坊的最大特点就是，它是一个<strong>可编程</strong>的区块链。<br>每个用户可自行编写自己业务逻辑代码，通过接口去触发自己编写的代码，这种代码官方叫做智能合约。<br>通过智能合约(编程代码)，用户可以实现很多功能，比如：分布式去中心化应用(DAPP)、分布式去中心化金融(DeFi) 等。<br>DAPP 包括一些游戏，目前国内 DAPP 数量较多的是波场(Tron)的 DAPP。</p><p>实现这些功能是因为设计了编程语言 Solidity 和 虚拟机EVM</p><p>和BTC 一样也是基于 POW 的区块链。但是 ETH2.0 正在转向 POS。什么是 POS 后面再说。</p><h4 id="2-账户模型"><a href="#2-账户模型" class="headerlink" title="2.账户模型"></a>2.账户模型</h4><p>以太坊的账户模型是基于账户系统，另外还有一个世界状态。这个世界状态也是有利有憋。</p><h4 id="3-奖励机制"><a href="#3-奖励机制" class="headerlink" title="3.奖励机制"></a>3.奖励机制</h4><p>这个和比特币不同，比特币只有产块的节点能获得比特币。以太坊采用叔块（Uncle Block）激励机制，即你产了这个块，但是最后确认不是你所产的这个块，未被确认的这个块叫(Uncle Block),也给你一定的奖励。</p><h4 id="4-燃汽-Gas"><a href="#4-燃汽-Gas" class="headerlink" title="4.燃汽 Gas"></a>4.燃汽 Gas</h4><p>以太坊还引入了 燃汽 Gas 的概念，转账需要消耗 Gas，就这让使用 ETH 币进行转账就需要成本。这个有利也有憋。<br>有了 Gas 之后，对于矿工来说，矿工们就可以选择将转账支付 Gas 较高的订单优先进行上链，矿工们收益好。但是对于用户来说，如果支付的低的话，那就要等上一些时间。<br>这样就造成拥堵。<br>Gas 还有个作用，控制每一次执行合约的消耗，即 GasLimit，看不明白的不用深究，后续都会深入说明。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当下区块链世界各种生态都在雨后春笋一般的建设中，BTC 是当之无愧的价值体现，以太坊也在奋起直追。币圈的运做也可以看做另一个世界的金融运做，币本身构建自己的生态，金融圈大庄操作币价。两相结合，推动币值，一边割韭菜，一边做技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;区块链技术，发展到目前，主流的区块链有两个代表，一个是以 比特币(BTC) 为代表的分布式去中心化记账本，一个是以 以态坊(ETH) 为代表的图灵完备的分布式去中心化计算机。名词解释会放到下面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
    
      <category term="架构" scheme="https://liukay.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
  </entry>
  
</feed>
