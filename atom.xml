<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思想家</title>
  
  <subtitle>有限的时间，编写先限的可能</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liukay.com/"/>
  <updated>2022-01-03T08:10:38.388Z</updated>
  <id>https://liukay.com/</id>
  
  <author>
    <name>咪雅先森</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔---十步学习法</title>
    <link href="https://liukay.com/posts/997e4410.html"/>
    <id>https://liukay.com/posts/997e4410.html</id>
    <published>2022-01-03T07:59:49.000Z</published>
    <updated>2022-01-03T08:10:38.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在IT行业，学习能力是一种必须的素养</p></blockquote><p>在开发行业中，技术的迭代是非常之快，如何保证自身的技术随之迭代更新，就需在强大的学习能力，我在多年的摸索中总结出自己的一套学习方法，中间参考过各种不同的学习方法，其中的十步学习法是最接近我自身总结的方法。分享出来让更多小伙伴能够从中吸收优秀的方法应用到实际学习中。</p><h2 id="第一步到第六步：概览全局，设定目标，搜寻资源，创建计划"><a href="#第一步到第六步：概览全局，设定目标，搜寻资源，创建计划" class="headerlink" title="第一步到第六步：概览全局，设定目标，搜寻资源，创建计划"></a>第一步到第六步：概览全局，设定目标，搜寻资源，创建计划</h2><p>集中精力完成足够的前期调研，确保自己明确知道学习的内容，以及如何确定自己达成目标，挑选最好的资源来帮助自己实现目标，制定学习计划。</p><h3 id="第一步：了解全局"><a href="#第一步：了解全局" class="headerlink" title="第一步：了解全局"></a>第一步：了解全局</h3><p>首先对需要学习的课题进行一些基础性研究，对该主题有一个全局性的了解。</p><h3 id="第二步：确定范围"><a href="#第二步：确定范围" class="headerlink" title="第二步：确定范围"></a>第二步：确定范围</h3><p>根据自身的需求，决定学习的重点和学习的范围，在此阶段容易犯的一个错误就是：试图解决太大的问题而让自己陷入困境中。结合从第一步中获得的信息，明确自己的学习范围，尽可能的保持专注；同时也需要阐述自己的学习理由来帮助自己界定学习的范围。学习的范围务必大小适当，既能符合学习理由，有能符合自己的时间限制。</p><h3 id="第三步：定义目标"><a href="#第三步：定义目标" class="headerlink" title="第三步：定义目标"></a>第三步：定义目标</h3><p>确定自己的学习目标，明确学习完成后应该达成的效果，根据简明清晰的目标，勾勒出勤奋学习后成功的图景。成功的标准应该是具体的，无二义性的。</p><h3 id="第四步：寻找资源"><a href="#第四步：寻找资源" class="headerlink" title="第四步：寻找资源"></a>第四步：寻找资源</h3><p>尽可能的尝试多种渠道和方式获取尽可能多的和主题相关资源，该阶段无需考虑这些资源的质量。</p><h3 id="第五步：创建学习计划"><a href="#第五步：创建学习计划" class="headerlink" title="第五步：创建学习计划"></a>第五步：创建学习计划</h3><p>需要在最短的时间内找到正确的学习路径，并找到和到达路径中重要的地标。打造自己的学习计划，一个好的方法是观察别人是如何教授你感兴趣的主题的。通览收到到的全部资源，就可以对自己需要那些内容以及如何组织这些内容有更清晰的认识。</p><h3 id="第六步：筛选资源"><a href="#第六步：筛选资源" class="headerlink" title="第六步：筛选资源"></a>第六步：筛选资源</h3><p>对找到的资源进行筛选，挑选出最有价值的几项来帮助你实现自己的目标。</p><hr><h2 id="第七步到第十步：循环往复"><a href="#第七步到第十步：循环往复" class="headerlink" title="第七步到第十步：循环往复"></a>第七步到第十步：循环往复</h2><p>通过 “学习——实践——掌握——教授”(LDLT)的方式来真正领悟知识。通过掌握恰到好处的基础知识开始，通过动手实践来学习，同时通过自我探索收集问题。之后，掌握了足够多的有用知识。最后，将自己所学教给他人，以此来弥补自己在学习过程中的不足，同时通过深入思考巩固知识。</p><h3 id="第七步：开始学习，浅尝辄止"><a href="#第七步：开始学习，浅尝辄止" class="headerlink" title="第七步：开始学习，浅尝辄止"></a>第七步：开始学习，浅尝辄止</h3><p>专注与掌握自己所需，能在下一步动手操作的最小量的知识。</p><h3 id="第八步：动手操作，边玩边学"><a href="#第八步：动手操作，边玩边学" class="headerlink" title="第八步：动手操作，边玩边学"></a>第八步：动手操作，边玩边学</h3><p>在掌握操作动手最小量的知识的情况下亲自操作和亲身体验。通过在探索和实践过程中，会产生的各种问题。这些问题会引导着你走向真正重要的方向。当回头寻找问题的答案时，不只是这些问题迎刃而解，而且你记得的东西比你学习的东西要多得多，因为你所学到的都是对你很重要的东西。</p><p>把那些暂时还没有答案的问题记录下来，在下一步中就会有机会找出这些问题的答案。</p><h3 id="第九步：全面掌握，学以致用"><a href="#第九步：全面掌握，学以致用" class="headerlink" title="第九步：全面掌握，学以致用"></a>第九步：全面掌握，学以致用</h3><p>好奇心是学习特别是自学的重要组成部分。为了有效利用自己选择的资料，为了上一步生产的问题寻求答案（带着问题学习）。不用担心回头再去操作，付出更多，因为这不仅能够让你找到问题的答案，也能让你学习新东西。给自己足够多的时间去深入理解自己的主题，你可以阅读，可以实验，可以观察，也可以操作。试着把自己正在学习的内容与最终目标关联起来。</p><h3 id="第十步：乐为人师，融会贯通"><a href="#第十步：乐为人师，融会贯通" class="headerlink" title="第十步：乐为人师，融会贯通"></a>第十步：乐为人师，融会贯通</h3><p>要想深入掌握一门学问，并且融会贯通，那么必须要做到能够教授给别人，在这一过程中，你要切实刨析并理解自己所学的知识，将其内化到自己的思想；同时，也要用能够让他人理解的方式精心组织这些信息。在这个过程中，你会发现很多自以为明白的知识点，其实并没有你想象的那么透彻。这一过程会将那些以前自己没太明白的东西联系起来，并简化到自己的大脑中已有的信息，将它们浓缩并经常复习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在IT行业，学习能力是一种必须的素养&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开发行业中，技术的迭代是非常之快，如何保证自身的技术随之迭代更新，就需在强大的学习能力，我在多年的摸索中总结出自己的一套学习方法，中间参考过各种不同的学习方法，其中的
      
    
    </summary>
    
      <category term="随笔" scheme="https://liukay.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="学习方法" scheme="https://liukay.com/categories/%E9%9A%8F%E7%AC%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="随笔" scheme="https://liukay.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="学习方法" scheme="https://liukay.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>shutdownHook 死锁解决</title>
    <link href="https://liukay.com/posts/247689d4.html"/>
    <id>https://liukay.com/posts/247689d4.html</id>
    <published>2021-12-02T12:15:08.000Z</published>
    <updated>2021-12-16T02:37:32.508Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个问题，通过脚本执行<code>kill -15</code>后，程序并没有退出，进程一直都在，最后被退出脚本的通过<code>kill -9</code>，杀死。导致数据完整性被破坏，程序再重启后不可用。通过排查认后发现是在执行<code>shutdownHook</code>时死锁程序死锁。</p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>导致问题的代码，</p><p>通过定位发现，程序在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Locking&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Locked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Exiting&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Exiting<br>Locking</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>排查原因<br>分析一下 addShutdownHook 这个方法是怎么执行的，重点是 ApplicationShutdownHooks，每一个 shutdownHook 都使用一个Thread包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addShutdownHook</span><span class="params">(Thread hook)</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点：hooks，每个 hook线程put到hooks中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread hook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hooks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line"></span><br><span class="line">    hooks.put(hook, hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加后谁来处理shutdown这个操作，是 Shutdown.add 这里起了一个线程，处理所以主要的逻辑在 runHooks</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Shutdown.add(<span class="number">1</span> <span class="comment">/* shutdown hook invocation order */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* not registered if shutdown in progress */</span>,</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    runHooks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        hooks = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        <span class="comment">// application shutdown hooks cannot be added if</span></span><br><span class="line">        <span class="comment">// shutdown is in progress.</span></span><br><span class="line">        hooks = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 hook.start(); 调用执行 hook的方法，之后调用 hook.join释放执行权。<br>问题就出在 hook.join上，程序执行到这里之后，卡住死锁，出不去了。<br>为什么，因为 join 实际就是 wait(0)，一旦当前线程调用wait(0)，就相当于释放执行权，等待其实线程notify()才能继续执行。<br>但是main线程调用System.exit(0)后，synchronized 当前线程为 main，hook.join拿不到被main未释放的锁，所以卡住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runHooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hook.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过工具排查，可以清楚的看到，Thread-0 即shutdown线程去引用已经被main线程持有的锁对象，而导至被 BLOCKED 住</p><p><img src="/posts/247689d4/死锁.png" alt="死锁"></p><p>再看线程状态</p><p><img src="/posts/247689d4/线程状态.png" alt="线程状态"></p><p>通过代码线程堆栈来确认就是这个原因</p><ol><li>main 方法是：WAIT 状态</li><li>Thread-0是：RUNNING 状态，但是进入synchronized之后就会BLOCKED住</li></ol><p>这里就对应上图的两个线程的状态</p><p><img src="/posts/247689d4/线程堆栈.png" alt="线程堆栈"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>即然已经知道原因了，那就好办：</p><ol><li>移除 shutdownHook 中不必要的加锁，shutdown 场景中很不需要用到加锁</li><li>使用不同的加锁对象，如果一定需要加锁，可以在 shutdownHook 的线程内使用一把新的锁，这样即可以保证安全性，又不会死锁。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到一个问题，通过脚本执行&lt;code&gt;kill -15&lt;/code&gt;后，程序并没有退出，进程一直都在，最后被退出脚本的通过&lt;code&gt;kill -9&lt;/code&gt;，杀死。导致数据完整性被破坏，程序再重启后不可用。通过排查认后发现是在执行&lt;code&gt;shutdownHoo
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="concurrent" scheme="https://liukay.com/categories/java/concurrent/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="并发" scheme="https://liukay.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="shutdownshutdownHook" scheme="https://liukay.com/tags/shutdownshutdownHook/"/>
    
  </entry>
  
  <entry>
    <title>matic checkpoint作用</title>
    <link href="https://liukay.com/posts/8ca79094.html"/>
    <id>https://liukay.com/posts/8ca79094.html</id>
    <published>2021-11-30T08:18:38.000Z</published>
    <updated>2021-11-30T08:53:34.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检查点-Checkpoint"><a href="#检查点-Checkpoint" class="headerlink" title="检查点 Checkpoint"></a>检查点 Checkpoint</h2><blockquote><p>RootHash is the Merkle hash of Bor block hashes from StartBlock to EndBlock<br>checkpoint 就是一开始区块到结束区块构建成的Merkle根hash。</p></blockquote><p>其实就是一组block区块的keccak256，再组装起来，生成一个Merkle的Hash。<br>然后提交到主链给合约验证合法性，以更新侧链状态。</p><h2 id="两个作用"><a href="#两个作用" class="headerlink" title="两个作用"></a>两个作用</h2><p>先说两个概念：</p><ol><li>铸币</li><li>燃烧</li></ol><p>用户从 ETH-&gt;MATIC 即，在ETH链上质押ETH到Matic链上，是存款操作，matic链上会进行相关的铸币操作。<br>用户从 MATIC-&gt;ETH 即，从Matic链上提现到ETH链上，是取款操作，Matic链上就会先燃烧Matic代币，再从ETH中释放对应ETH，就是燃烧。</p><p>1.通过提交到以太坊主链上的 checkpoint来决定，侧链上block的最终性(finality)。<br>2.在用户提现资产到主链上时，可以提供燃烧证明。</p><p>检查点很重要，因为它们在以太坊链上提供了最终性。<br>Heimdall 层允许将 Bor 生成的区块聚合到单个 Merkle 根中，并定期将其发布到以太坊主链。此已发布状态也称为检查点，因此整个过程称为检查点。</p><p>除了在主链上提供最终性之外，检查点（checkpoint）在取款中还可以发挥非常重要的作用，因为它们包含在用户取款时代币燃烧证明（取款）。<br>它允许用户使用 Patricia Merkle 证明和头块证明在根和约上证明其剩余代币。<br>注意，要证明剩余代币，必须通过PoS（权益持有人，就是 validtor）将头块提交到根链。<br>提款过程将照常收取以太坊gas费。<br>这些信息包含了用来验证用户在侧链上真实燃烧了一定数量代币的所需要的所有信息。</p><h2 id="燃烧证明"><a href="#燃烧证明" class="headerlink" title="燃烧证明"></a>燃烧证明</h2><p>取款，核心 Merkle 根<br>燃烧证明是什么：<br>简单说就是证明用户在侧链上确实发生了一笔资产提现的交易，验证这个燃烧证明有效的话，会将资产打到用户的地址，反之，如果验证不通过，则用户的这笔提现将失败。</p><p>用户等待checkpoint提交到主链上后，在侧链通过bttc sdk可以获取燃烧证明（the proof of burn trx）。</p><p>这里燃烧证明解决的是上面的第三个问题，即目标链上的信息传递到主链上的有效性问题。</p><h2 id="形成一个-checkpoint（工作原理）"><a href="#形成一个-checkpoint（工作原理）" class="headerlink" title="形成一个 checkpoint（工作原理）"></a>形成一个 checkpoint（工作原理）</h2><p>RootHash is the Merkle hash of Bor block hashes from StartBlock to EndBlock</p><p>一个区块内的多笔交易计算出blockhash</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockHash = keccak256([number, time, tx hash, receipt hash]) </span><br></pre></td></tr></table></figure><p>所有block hash参于生成 Merkle Hash</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pseudocode <span class="keyword">for</span> the root hash <span class="keyword">for</span> <span class="number">1</span> to n Bor blocks:</span><br><span class="line"></span><br><span class="line">B(<span class="number">1</span>) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line">B(<span class="number">2</span>) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">B(n) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpoint is Merkle root of all block hash</span></span><br><span class="line">checkpoint<span class="string">&#x27;s root hash = Merkel[B(1), B(2), ....., B(n)]</span></span><br></pre></td></tr></table></figure><p>而上面提到的这笔用来申请提现的燃烧交易，就被包含在这个区块当中，并且被用来计算出这个块的blockhash.当累计了一定数量的块之后(从startblock到endblock，参见上面checkpoint结构)，这些块被计算出各自的blockhash，然后用这些blockhash来计算出root hash,如下面共识所示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checkpoint block header struct</span></span><br><span class="line"><span class="keyword">type</span> Checkpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">        Proposer   HeimdallAddress <span class="string">`json:&quot;proposer&quot;`</span></span><br><span class="line">        StartBlock <span class="keyword">uint64</span>          <span class="string">`json:&quot;start_block&quot;`</span></span><br><span class="line">        EndBlock   <span class="keyword">uint64</span>          <span class="string">`json:&quot;end_block&quot;`</span></span><br><span class="line">        RootHash   HeimdallHash    <span class="string">`json:&quot;root_hash&quot;`</span></span><br><span class="line">        BorChainID <span class="keyword">string</span>          <span class="string">`json:&quot;bor_chain_id&quot;`</span></span><br><span class="line">        TimeStamp  <span class="keyword">uint64</span>          <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看默认是5分钟提一次checkpoint。<br>目前 侧链(BOR) 是2s 一个块，checkpoint最低提交256个快，checkpoint_poll_interval 最低合理值为8m32s，<br>最大值为1024<code>*</code>2s ，34m8s，可设置[9,30]分钟，如果有多条主链的的情况下，可根据各主链手续费不同，可以拆分此checkpoint_poll_interval分别设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefaultCheckpointerPollInterval = <span class="number">5</span> * time.Minute</span><br><span class="line">DefaultSyncerPollInterval       = <span class="number">1</span> * time.Minute</span><br><span class="line">DefaultNoACKPollInterval        = <span class="number">1010</span> * time.Second</span><br><span class="line">DefaultClerkPollInterval        = <span class="number">10</span> * time.Second</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;检查点-Checkpoint&quot;&gt;&lt;a href=&quot;#检查点-Checkpoint&quot; class=&quot;headerlink&quot; title=&quot;检查点 Checkpoint&quot;&gt;&lt;/a&gt;检查点 Checkpoint&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;RootHash 
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="polygon" scheme="https://liukay.com/categories/blockchain/polygon/"/>
    
      <category term="polygon" scheme="https://liukay.com/categories/polygon/"/>
    
      <category term="matic" scheme="https://liukay.com/categories/polygon/matic/"/>
    
    
      <category term="matic" scheme="https://liukay.com/tags/matic/"/>
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="polygon" scheme="https://liukay.com/tags/polygon/"/>
    
  </entry>
  
  <entry>
    <title>mysql 5.8 安装</title>
    <link href="https://liukay.com/posts/3d0988b0.html"/>
    <id>https://liukay.com/posts/3d0988b0.html</id>
    <published>2021-11-26T02:35:04.000Z</published>
    <updated>2021-11-26T03:37:11.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h2><p>mysql 这里通过rpm的方式安装，使用 MySQL 官方提供的安装包选择适合自己系统的包进行安装<br>到这个页面下选择适合自己系统的版本：<br><a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p><p>Select Operating System: 选择系统，如果是Linux CentOS 选 Red Hat即可，如果没有你的版本，选 Linux-generic。</p><p>Select OS Version: 选对应的版本，CentOS 7 选 Enterprise 7 x86, 64-bit。</p><p>最近添新增了一些CentOS7 的机器，就使用 Red Hat 的版本进行安装。</p><p><img src="/posts/3d0988b0/选择版本.png" alt="选择版本"></p><h2 id="御载旧版本"><a href="#御载旧版本" class="headerlink" title="御载旧版本"></a>御载旧版本</h2><p>一定要御载干净，否则安装过程中有版本问题！！！<br>yum 和 rpm 两种方式二选一:<br>列出所有已安装的，但不在rpm中的包<br>yum list installed mysql<br>结果</p><blockquote><p>mysql-libs.x86_64<br>yum -y remove mysql-libs.x86_64</p></blockquote><p>等价于上面的命令<br>rpm -qa | grep mysql<br>结果</p><blockquote><p>mysql80-community-release-el7-4.noarch<br>mysql-community-common-8.0.27-1.el7.x86_64</p></blockquote><p>阿里去自带 MariaDB，并不是需要的直接御载。<br>移除</p><blockquote><p>rpm -e mariadb-libs-5.5.60-1.el7_5.x86_64</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><blockquote><p>wget <a href="https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.27-1.el7.x86_64.rpm-bundle.tar">https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.27-1.el7.x86_64.rpm-bundle.tar</a></p></blockquote><p>EL是Red Hat Enterprise Linux的简写</p><ul><li>EL6 软件包用于在Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x进行安装</li><li>EL7 软件包用于在Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x的安装</li></ul><p><img src="/posts/3d0988b0/下载文件.png" alt="下载文件"></p><p>必须安装(注意顺序)</p><blockquote><p>yum install libaio<br>sudo rpm -ivh mysql-community-common-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-client-plugins-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-libs-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-client-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-server-8.0.27-1.el7.x86_64.rpm</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote><p>systemctl start  mysqld.service</p></blockquote><p>查看服务状态</p><blockquote><p>systemctl status mysqld.service</p></blockquote><p><img src="/posts/3d0988b0/查看状态.png" alt="查看状态"></p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>查看默认密码，这是一个生成的随机密码，复制出来后，修改成己的密码。</p><blockquote><p>grep “password” /var/log/mysqld.log</p></blockquote><blockquote><p>mysql -u root -p</p></blockquote><p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库<br>格式：</p><blockquote><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’;</p></blockquote><p>输入：</p><blockquote><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘abcdefg1234567’;</p></blockquote><p>成功提示：Query OK, 0 rows affected (0.01 sec)</p><p>如果提示：</p><blockquote><p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p></blockquote><p>说明密码不满足默认安全策略，把密码搞复杂一点，就是那种自己也记不住，只能靠复制粘贴的那种。<br>也可以调低安全策略：</p><blockquote><p>set global validate_password_policy=0;<br>set global validate_password_length=1;</p></blockquote><h2 id="安全策略，非常有必要"><a href="#安全策略，非常有必要" class="headerlink" title="安全策略，非常有必要"></a>安全策略，非常有必要</h2><p>要启动mysql服务的时候，有一些提示说明，在那里有一些有用的信息。<br>其中就有开启安全策略的方式:</p><blockquote><p>/usr/bin/mysql_secure_installation</p></blockquote><p>下面有很多选项，不用头疼：</p><p>Remove anonymous users? y 移除<br>移除 anonymous 用户</p><p>Disallow root login remotely? y<br>是否开启 root 远程访问？<br>选 Y 开启远程访问，这个需要考虑一下，如果是本地开发的话，不需要开，如果是不同机器上做主从复制的话，就开启</p><p>Remove test database? y<br>自带的测试数据库，移除。</p><p>Reload privilege tables now? y<br>重启数据库权限表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password for user root:</span><br><span class="line">The &#39;validate_password&#39; component is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration</span><br><span class="line">of the component.</span><br><span class="line">Using existing password for root.</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 100</span><br><span class="line">Change the password for root ? ((Press y|Y for Yes, any other key for No) : n</span><br><span class="line"></span><br><span class="line"> ... skipping.</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&#39;localhost&#39;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named &#39;test&#39; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line"> - Dropping test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br></pre></td></tr></table></figure><h2 id="开启远程登陆"><a href="#开启远程登陆" class="headerlink" title="开启远程登陆"></a>开启远程登陆</h2><blockquote><p>use mysql;</p></blockquote><p>host里指定ip，%是通配符，可以添加多条</p><blockquote><p>update user set host = ‘%’ where user = ‘root’;</p><p>#刷新，否则不成功<br>flush privileges;</p></blockquote><p>查看当前用户的 host</p><blockquote><p>select host, user from user;</p></blockquote><p><img src="/posts/3d0988b0/查看host.png" alt="查看host"></p><p>退出</p><blockquote><p>quit;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择版本&quot;&gt;&lt;a href=&quot;#选择版本&quot; class=&quot;headerlink&quot; title=&quot;选择版本&quot;&gt;&lt;/a&gt;选择版本&lt;/h2&gt;&lt;p&gt;mysql 这里通过rpm的方式安装，使用 MySQL 官方提供的安装包选择适合自己系统的包进行安装&lt;br&gt;到这个页面下选择
      
    
    </summary>
    
      <category term="mysql" scheme="https://liukay.com/categories/mysql/"/>
    
      <category term="database" scheme="https://liukay.com/categories/database/"/>
    
      <category term="mysql" scheme="https://liukay.com/categories/database/mysql/"/>
    
    
      <category term="安装" scheme="https://liukay.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="mysql" scheme="https://liukay.com/tags/mysql/"/>
    
      <category term="数据库" scheme="https://liukay.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>idea 2021 Debug卡住一直提示Collecting data</title>
    <link href="https://liukay.com/posts/ff7fe1c0.html"/>
    <id>https://liukay.com/posts/ff7fe1c0.html</id>
    <published>2021-11-24T06:37:11.000Z</published>
    <updated>2021-11-24T08:12:46.494Z</updated>
    
    <content type="html"><![CDATA[<p>还是IDEA 的问题 mac M1 加 IDEA2021的问题还真不少，debug时发现会一直卡住，在调用底层jar包时，创建一个对象就一直提示 Collecting data，并没有断点。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><img src="/posts/ff7fe1c0/解决.png" alt="解决"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是IDEA 的问题 mac M1 加 IDEA2021的问题还真不少，debug时发现会一直卡住，在调用底层jar包时，创建一个对象就一直提示 Collecting data，并没有断点。&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;head
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="idea" scheme="https://liukay.com/categories/java/idea/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="idea" scheme="https://liukay.com/tags/idea/"/>
    
      <category term="ide" scheme="https://liukay.com/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码阅读环境</title>
    <link href="https://liukay.com/posts/992b6df6.html"/>
    <id>https://liukay.com/posts/992b6df6.html</id>
    <published>2021-11-23T02:46:45.000Z</published>
    <updated>2021-11-27T08:20:16.916Z</updated>
    
    <content type="html"><![CDATA[<p>要进行源码阅读之前，强调需要先对一个产品有熟悉的使用，就好像你想要造车，要先会开车，再去学习如何造车，否则一切都是停在理轮上，完全不了解这个车是如何运行的，没有概念。<br>推荐对需要阅读的源码先保存在自己仓库中，并创建一个源码分支，可以在阅读分析的过程中对重要点进行注释帮助加深理解。</p><h2 id="fork源码"><a href="#fork源码" class="headerlink" title="fork源码"></a>fork源码</h2><p>Spring 官方github源码仓库</p><p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p><img src="/posts/992b6df6/fork源码.jpg" alt="fork源码"></p><h2 id="构建源码阅读环境"><a href="#构建源码阅读环境" class="headerlink" title="构建源码阅读环境"></a>构建源码阅读环境</h2><p>将代码 clone 到本地，克隆完成后，IDEA自动打开项目。</p><p><img src="/posts/992b6df6/clone代码.jpg" alt="clone代码"></p><p>报错处理，首次打开会报个错，别慌这是因为IDEA缺少必要插件，点右侧 gradle 的构建按钮构建一次。<br><img src="/posts/992b6df6/报错.jpg" alt="报错"></p><p>首次构建需要下载的包比较多，</p><p><img src="/posts/992b6df6/构建.jpg" alt="构建"></p><h2 id="直接使用-git-clone-方式"><a href="#直接使用-git-clone-方式" class="headerlink" title="直接使用 git clone 方式"></a>直接使用 git clone 方式</h2><p>直接使用命令行git clone 项目的话，拉完代码后，IDEA 通过导入的方式导入项目。</p><blockquote><p>file—&gt;new—&gt;Project from Exisitings Sources</p></blockquote><p>后续步骤相同。</p><h2 id="gradle-问题"><a href="#gradle-问题" class="headerlink" title="gradle 问题"></a>gradle 问题</h2><p>spring 是基于gradle进行构建的，如果没有安装gradle也没有关系，IDEA会在启动时，自动根据当前环境下载gradle及插件。</p><p><img src="/posts/992b6df6/gradle.jpg" alt="gradle"></p><h2 id="构建成功"><a href="#构建成功" class="headerlink" title="构建成功"></a>构建成功</h2><p><img src="/posts/992b6df6/成功.jpg" alt="成功"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要进行源码阅读之前，强调需要先对一个产品有熟悉的使用，就好像你想要造车，要先会开车，再去学习如何造车，否则一切都是停在理轮上，完全不了解这个车是如何运行的，没有概念。&lt;br&gt;推荐对需要阅读的源码先保存在自己仓库中，并创建一个源码分支，可以在阅读分析的过程中对重要点进行注释帮
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/java/spring/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/spring/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/spring/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="code" scheme="https://liukay.com/categories/code/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/code/spring/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="spring" scheme="https://liukay.com/tags/spring/"/>
    
      <category term="源码" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>gradle 安装</title>
    <link href="https://liukay.com/posts/d723a7c4.html"/>
    <id>https://liukay.com/posts/d723a7c4.html</id>
    <published>2021-11-23T02:13:46.000Z</published>
    <updated>2021-11-23T02:31:58.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网</p><p><a href="https://gradle.org/">https://gradle.org/</a></p><p>下载页面<br><a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p><p>选择自己需要的版本，下载已经编译好的二进制文件<br>Download: binary-only</p><p><img src="/posts/d723a7c4/安装.jpg" alt="安装"></p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>设置 .bash_profile 文件添加</p><blockquote><p>export PATH=$PATH:/Users/liukai/workspaces/application/gradle-6.6.1/bin</p></blockquote><p>验证一下</p><p><img src="/posts/d723a7c4/验证.jpg" alt="验证"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;官网&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gradle.org/&quot;&gt;https://gradle.org/&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="gradle" scheme="https://liukay.com/categories/java/gradle/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="安装" scheme="https://liukay.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="gradle" scheme="https://liukay.com/tags/gradle/"/>
    
      <category term="项目构建" scheme="https://liukay.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA2021使用tomcat启动时间超长</title>
    <link href="https://liukay.com/posts/719ff018.html"/>
    <id>https://liukay.com/posts/719ff018.html</id>
    <published>2021-11-22T08:40:22.000Z</published>
    <updated>2021-11-23T02:11:07.292Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了 mac M1 加 IDEA2021 后，发现问题还真不少，先是解决了卡顿问题后，tomcat 启动时间从原来的十几秒，变成20分钟！！！超不正常。</p><p>新电脑问题多。</p><p>直接说怎么解决的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>scutil –set HostName “localhost”</p></blockquote><h2 id="无效的偿试-修改生成随机数"><a href="#无效的偿试-修改生成随机数" class="headerlink" title="无效的偿试-修改生成随机数"></a>无效的偿试-修改生成随机数</h2><p>IDEA2021 添加tomcat启动参数，JRE默认使用 /dev/random作为随机数来源，当熵池大小不够的时候，random会很慢，造成随机数生成调用阻塞。</p><blockquote><p>JAVA_OPTS=”-Djava.security.egd=file:/dev/urandom”<br>无效，依然该怎么慢还怎么慢。</p></blockquote><h2 id="真正原因-Jvm需要很长时间解析localhost的IP地址"><a href="#真正原因-Jvm需要很长时间解析localhost的IP地址" class="headerlink" title="真正原因 Jvm需要很长时间解析localhost的IP地址"></a>真正原因 Jvm需要很长时间解析localhost的IP地址</h2><p>原因分析<br><a href="https://www.codenong.com/39636792/">https://www.codenong.com/39636792/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近换了 mac M1 加 IDEA2021 后，发现问题还真不少，先是解决了卡顿问题后，tomcat 启动时间从原来的十几秒，变成20分钟！！！超不正常。&lt;/p&gt;
&lt;p&gt;新电脑问题多。&lt;/p&gt;
&lt;p&gt;直接说怎么解决的。&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="idea" scheme="https://liukay.com/categories/java/idea/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="idea" scheme="https://liukay.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>hexo 分类或标签单词开头大写出现404</title>
    <link href="https://liukay.com/posts/4631c4c2.html"/>
    <id>https://liukay.com/posts/4631c4c2.html</id>
    <published>2021-11-21T06:21:06.000Z</published>
    <updated>2021-11-21T06:27:51.841Z</updated>
    
    <content type="html"><![CDATA[<p>最近搬运笔记到博客，编辑的文章多了，今天突然发现，有一个分类点进去404，本地运行正常没有问题。查了一圈发现是git的大小写区分问题。</p><p>将大写字母改成小写，hexo 部署正确，但是博客上还是不正确出现404</p><p>网上查了许多资料，才发现，git中设置了大小写不敏感。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>修改 git 设置不忽略大小写</p><p>进入博客文件夹，进入 git 目录：<code>.deploy_git</code>，修改 .git 文件中的配置文件 config，将ignorecase=true 改为 ignorecase=false</p><blockquote><p>vim . deploy_git/.git/config<br>ignorecase = false</p></blockquote><p>重写清空部署项目</p><p>如果还没有解决，清空部署到 github 上的文件，重新发布：</p><blockquote><p>cd .deploy_git<br>git rm -rf *<br>git commit -m ‘clean all file’<br>git push</p></blockquote><p>进入博客文件夹，用 hexo 重新生成部署</p><blockquote><p>hexo clean &amp;&amp; hexo g -d</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近搬运笔记到博客，编辑的文章多了，今天突然发现，有一个分类点进去404，本地运行正常没有问题。查了一圈发现是git的大小写区分问题。&lt;/p&gt;
&lt;p&gt;将大写字母改成小写，hexo 部署正确，但是博客上还是不正确出现404&lt;/p&gt;
&lt;p&gt;网上查了许多资料，才发现，git中设置
      
    
    </summary>
    
      <category term="hexo" scheme="https://liukay.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://liukay.com/tags/hexo/"/>
    
      <category term="404" scheme="https://liukay.com/tags/404/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 2021 CPU 超100% 问题解决</title>
    <link href="https://liukay.com/posts/f271493a.html"/>
    <id>https://liukay.com/posts/f271493a.html</id>
    <published>2021-11-20T13:44:47.000Z</published>
    <updated>2021-11-21T01:06:06.149Z</updated>
    
    <content type="html"><![CDATA[<p>用了IDEA 2021之后cpu超过200，打开一个类文件就卡住一会，起初以为是语法检查的问题，把所有语法检查一个不留全关闭，还是没解决。</p><p>最终解决方式，配置IDEA 的JVM参数：</p><p><img src="/posts/f271493a/1.png" alt="修改参数"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#堆栈设置</span><br><span class="line">-Xms4096m</span><br><span class="line">-Xmx4096m</span><br><span class="line">-Xmn3072m</span><br><span class="line">-XX:MetaspaceSize&#x3D;1024m</span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;1024m</span><br><span class="line">-XX:+AlwaysPreTouch</span><br><span class="line">-XX:InitialCodeCacheSize&#x3D;1200m</span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;1200m</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-Dfile.encoding&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line"># 采用何种垃圾回收参数</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:ParallelGCThreads&#x3D;4</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB&#x3D;50</span><br><span class="line">-ea</span><br><span class="line"># JIT 参数</span><br><span class="line">-XX:CICompilerCount&#x3D;2</span><br><span class="line">-XX:TieredStopAtLevel&#x3D;1</span><br><span class="line">-XX:MaxInlineLevel&#x3D;3</span><br><span class="line">-XX:Tier4MinInvocationThreshold&#x3D;100000</span><br><span class="line">-XX:Tier4InvocationThreshold&#x3D;110000</span><br><span class="line">-XX:Tier4CompileThreshold&#x3D;120000</span><br><span class="line"></span><br><span class="line">-Dsun.io.useCanonPrefixCache&#x3D;false</span><br><span class="line">-Djava.net.preferIPv4Stack&#x3D;true</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot;</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Djdk.attach.allowAttachSelf</span><br><span class="line">-Xverify:none</span><br><span class="line"></span><br><span class="line">-XX:ErrorFile&#x3D;$USER_HOME&#x2F;java_error_in_idea_%p.log</span><br><span class="line">-XX:HeapDumpPath&#x3D;$USER_HOME&#x2F;java_error_in_idea.hprof</span><br></pre></td></tr></table></figure><p>立杆见影，原因不是垃圾回收造成的cpu负载过高 而是由于JIT Compiler 及时编译将class文件编译成本地机器代码占用了大量的cpu资源导致的卡顿。</p><p>具体请参考国外idea bug追踪他们的idea cpu 100% 讨论<br><a href="https://youtrack.jetbrains.com/issue/IDEA-207243">https://youtrack.jetbrains.com/issue/IDEA-207243</a></p><p>参考：<a href="https://www.jianshu.com/p/ac72a14afc24">https://www.jianshu.com/p/ac72a14afc24</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了IDEA 2021之后cpu超过200，打开一个类文件就卡住一会，起初以为是语法检查的问题，把所有语法检查一个不留全关闭，还是没解决。&lt;/p&gt;
&lt;p&gt;最终解决方式，配置IDEA 的JVM参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/f271493a/1.png
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="idea" scheme="https://liukay.com/categories/java/idea/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="idea" scheme="https://liukay.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>netty 构建一个简易服务</title>
    <link href="https://liukay.com/posts/fab0cb81.html"/>
    <id>https://liukay.com/posts/fab0cb81.html</id>
    <published>2021-11-19T08:08:20.000Z</published>
    <updated>2021-11-19T08:51:28.496Z</updated>
    
    <content type="html"><![CDATA[<p>使用 IDEA + netty + gradle 构建一个简单的HTTP服务，用来学习netty。</p><h2 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h2><p>netty 构建一个服务，需要三个角色参与</p><ol><li>Server 运行服务</li><li>Initializer 组装组件</li><li>Handle 业秋处理</li></ol><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>添加 build.gradle，复制内容</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插件管理</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//座标</span></span><br><span class="line"><span class="keyword">group</span> <span class="string">&#x27;com.liukai.netty&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//源和目标编译版本</span></span><br><span class="line"><span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"><span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仓库，这里使用 maven 远程仓库，也就是说本没有，就去远程获取</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖管理</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">//测试用名，不用打到生产包中</span></span><br><span class="line">    <span class="comment">//group是 maven 的 group, name 是 artifactId, version 相同</span></span><br><span class="line">    testCompile <span class="keyword">group</span>: <span class="string">&#x27;junit&#x27;</span>, name: <span class="string">&#x27;junit&#x27;</span>, version: <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">    <span class="comment">//等价写法，推荐 group:artifactId:version</span></span><br><span class="line">    testCompile(</span><br><span class="line">            <span class="string">&quot;junit:junit:4.12&quot;</span></span><br><span class="line">            <span class="comment">//多行逗号隔开</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//编译的包</span></span><br><span class="line">    <span class="keyword">compile</span>(</span><br><span class="line">            <span class="string">&quot;io.netty:netty-all:4.1.10.Final&quot;</span></span><br><span class="line">            <span class="comment">//多行逗号隔开</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器-NettyServer"><a href="#服务器-NettyServer" class="headerlink" title="服务器 NettyServer"></a>服务器 NettyServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liukai.netty.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 http 服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu kai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-12-29 22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> NettyChannelInitializer());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8889</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组装组件-NettyChannelInitializer"><a href="#组装组件-NettyChannelInitializer" class="headerlink" title="组装组件 NettyChannelInitializer"></a>组装组件 NettyChannelInitializer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liukai.netty.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渠道构建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu kai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-12-29 22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个回调的方法，在channel被注册时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">//这里看一下源码</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;httpServerCodec&quot;</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//增加一个自己定义的处理器handel</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;testHttpServerHandler&quot;</span>, <span class="keyword">new</span> NettyServerHandle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Handle-业务处理器-NettyServerHandle"><a href="#Handle-业务处理器-NettyServerHandle" class="headerlink" title="Handle 业务处理器 NettyServerHandle"></a>Handle 业务处理器 NettyServerHandle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liukai.netty.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu kai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-12-29 22:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandle</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承InboundHandler类，代表处理进入的请求，还有OutboundHandler,处理出去请求</span></span><br><span class="line"><span class="comment">     * 其中里面的泛型表示msg的类型，如果指定了HttpObject，表明这是个HTTP连接的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//channelRead0读取客户端请求，并返回响应的方法</span></span><br><span class="line">        <span class="comment">//如果不加这个判断使用curl 测试会报错，使用curl测试命令curl &quot;http://localhost:8899&quot;</span></span><br><span class="line">        <span class="comment">//判断这个是不是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            System.out.println(msg.getClass());</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.getUri());</span><br><span class="line">            ctx.channel().closeFuture();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;chrome 请求 favicon&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求方法名: &quot;</span> + httpRequest.getMethod().name());</span><br><span class="line">            <span class="comment">//ByteBuf 是netty中的重要概念，代表响应返回的数据</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;Hello World&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            <span class="comment">//如果只是调用write方法，他仅仅是存在缓冲区里，并不会返回客户端</span></span><br><span class="line">            <span class="comment">//调用writeAndFlush可以</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="/posts/fab0cb81/1.jpg" alt="验证"></p><p>控制台输出</p><p><img src="/posts/fab0cb81/2.jpg" alt="控制台输出"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 IDEA + netty + gradle 构建一个简单的HTTP服务，用来学习netty。&lt;/p&gt;
&lt;h2 id=&quot;主要角色&quot;&gt;&lt;a href=&quot;#主要角色&quot; class=&quot;headerlink&quot; title=&quot;主要角色&quot;&gt;&lt;/a&gt;主要角色&lt;/h2&gt;&lt;p&gt;netty
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="netty" scheme="https://liukay.com/categories/java/netty/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="通信" scheme="https://liukay.com/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="netty" scheme="https://liukay.com/tags/netty/"/>
    
      <category term="服务" scheme="https://liukay.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>netty 简述</title>
    <link href="https://liukay.com/posts/9321f70b.html"/>
    <id>https://liukay.com/posts/9321f70b.html</id>
    <published>2021-11-16T07:07:38.000Z</published>
    <updated>2021-11-20T13:04:36.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是netty"><a href="#什么是netty" class="headerlink" title="什么是netty"></a>什么是netty</h2><p>Netty是一个异步的基于事件驱动(Reactor)的网络框架。<br>Netty是一个NIO客户服务器框架，它能够快速和容易地开发网络应用，如协议服务器和客户端。它大大简化了网络编程，如TCP和UDP套接字服务器。</p><h2 id="为什么选择netty"><a href="#为什么选择netty" class="headerlink" title="为什么选择netty"></a>为什么选择netty</h2><p>主要原因是 netty 简化了使用nio时对网络编程的复杂性，提供更多的抽象性和功能方便网络编程开发。</p><p>列举一个特点：<br>1.Netty支持三种IO模型同时支持三种Reactor模式。</p><p>2.Netty支持很多应用层的协议，提供了很多decoder和encoder。</p><p>3.Netty能够解决TCP长连接所带来的缺陷（粘包、半包等）</p><p>4.Netty支持应用层的KeepAlive。</p><p>5.Netty规避了JAVA NIO中的很多BUG，性能更好。</p><h2 id="使用-netty-能做什么"><a href="#使用-netty-能做什么" class="headerlink" title="使用 netty 能做什么"></a>使用 netty 能做什么</h2><p>1.实现节点间通信<br>2.实现自己的协议<br> dubbo、rocketmq 等底层都使用 netty 实现自己的协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是netty&quot;&gt;&lt;a href=&quot;#什么是netty&quot; class=&quot;headerlink&quot; title=&quot;什么是netty&quot;&gt;&lt;/a&gt;什么是netty&lt;/h2&gt;&lt;p&gt;Netty是一个异步的基于事件驱动(Reactor)的网络框架。&lt;br&gt;Netty是一个NI
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="netty" scheme="https://liukay.com/categories/java/netty/"/>
    
    
      <category term="netty" scheme="https://liukay.com/tags/netty/"/>
    
      <category term="简述" scheme="https://liukay.com/tags/%E7%AE%80%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>go 函数多个返回值</title>
    <link href="https://liukay.com/posts/b9c503bd.html"/>
    <id>https://liukay.com/posts/b9c503bd.html</id>
    <published>2021-11-16T06:03:51.000Z</published>
    <updated>2021-11-16T06:09:05.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>结构和别的语言略有不同。<br>go 的特点，返回可以有多个返回值。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单个返回值方法"><a href="#单个返回值方法" class="headerlink" title="单个返回值方法"></a>单个返回值方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个返回值方法"><a href="#两个返回值方法" class="headerlink" title="两个返回值方法"></a>两个返回值方法</h2><p>实际上可以返回多个值，这里演示，所以只写两个返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;p&gt;结构和别的语言略有不同。&lt;br&gt;go 的特点，返回可以有多个返回值。&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
      <category term="语法" scheme="https://liukay.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="函数" scheme="https://liukay.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>go 函数介绍</title>
    <link href="https://liukay.com/posts/b9c503bd.html"/>
    <id>https://liukay.com/posts/b9c503bd.html</id>
    <published>2021-11-16T02:13:52.000Z</published>
    <updated>2021-11-16T06:43:14.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数是基本的代码块。<br>Go是编译型语言，函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的底部，类似于C语言的习惯。</p><p>Go 语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>func：函数声明关键字，函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表。</li><li>return_types：返回类型，函数返回一列值。<br>return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><h2 id="Go-里面拥三种类型的函数"><a href="#Go-里面拥三种类型的函数" class="headerlink" title="Go 里面拥三种类型的函数"></a>Go 里面拥三种类型的函数</h2><ul><li>普通函数</li><li>匿名函数或者lambda函数</li><li>方法（Methods）<br>说下方法，确实有这种类型。go是为了兼容面向对象的特性，实现了方法这种特性。</li></ul><h2 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    getTest()</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带入参返回值"><a href="#带入参返回值" class="headerlink" title="带入参返回值"></a>带入参返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数定义&quot;&gt;&lt;a href=&quot;#函数定义&quot; class=&quot;headerlink&quot; title=&quot;函数定义&quot;&gt;&lt;/a&gt;函数定义&lt;/h2&gt;&lt;p&gt;函数是基本的代码块。&lt;br&gt;Go是编译型语言，函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文
      
    
    </summary>
    
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go defer关键字</title>
    <link href="https://liukay.com/posts/20130.html"/>
    <id>https://liukay.com/posts/20130.html</id>
    <published>2021-11-05T03:15:34.000Z</published>
    <updated>2021-11-05T03:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="defer-延时机制"><a href="#defer-延时机制" class="headerlink" title="defer 延时机制"></a>defer 延时机制</h1><p>在函数执行过后执行。<br>作用：在函数执行过后及时释放资源。<br>最佳的实践在于，做一些执行后的操作，释放资源，比如：数据库连接、文件句柄、锁等。</p><p>在 golang 中的通常做法是，创建资源后，立即使用 defer 进行释放。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><p>原理是使用了 defer 关键字后，会将修饰语句加入到一个栈中，这里称为 defer 栈中，直到程序执行后，最后执行，当函数执行完毕后，在从 defer 栈中，依次从栈顶取出语句执行，先入后出的机制。<br>defer对执行流程的改变，只是在本函数内有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;n1=%d, n2=%d\n&quot;</span>,n1, n2)</span><br><span class="line">  res := n1 + n2</span><br><span class="line">  <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;res1=%d\n&quot;</span>, res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  res := sum(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;res2=%d&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>res1=30<br>n1=10, n2=20<br>res2=30</p></blockquote><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><p>defer 拷贝入栈后，值是拷贝进去的，后续的操作，不影响已拷贝的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum2</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1)</span><br><span class="line">  <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n2=&quot;</span>, n2)</span><br><span class="line">  n1++</span><br><span class="line">  n2++</span><br><span class="line">  res := n1 + n2</span><br><span class="line">  <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;res1=%d\n&quot;</span>, res)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  res2 := sum2(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;res2=%d&quot;</span>, res2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><blockquote><p>res1=32<br>n2= 20<br>n1= 10<br>res2=32</p></blockquote><h2 id="3-defer-的意义"><a href="#3-defer-的意义" class="headerlink" title="3.defer 的意义"></a>3.defer 的意义</h2><p>在于可以及时的释放函数创建的资源。很多时间在开发中，打开了资源后，就忘了关闭，defer 的机制可以让程序员在开发时，使用资源后立即加上关闭操作，也不影响后续的代码执行。类似于 java 的<code>finally</code>的作用，不同在于语法上defer可以写在前面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;defer-延时机制&quot;&gt;&lt;a href=&quot;#defer-延时机制&quot; class=&quot;headerlink&quot; title=&quot;defer 延时机制&quot;&gt;&lt;/a&gt;defer 延时机制&lt;/h1&gt;&lt;p&gt;在函数执行过后执行。&lt;br&gt;作用：在函数执行过后及时释放资源。&lt;br&gt;最佳的
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="golang" scheme="https://liukay.com/tags/golang/"/>
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
      <category term="defer" scheme="https://liukay.com/tags/defer/"/>
    
      <category term="关键字" scheme="https://liukay.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>go 空白标识符</title>
    <link href="https://liukay.com/posts/29773.html"/>
    <id>https://liukay.com/posts/29773.html</id>
    <published>2021-11-05T03:08:40.000Z</published>
    <updated>2021-11-05T03:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用于抛弃不需要接收的变量值</p></blockquote><h1 id="空白标识符"><a href="#空白标识符" class="headerlink" title="空白标识符 _"></a>空白标识符 _</h1><p>作用：在接收多个变量返回时，抛弃不需要的返回值<br><code>_</code> 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  _,numb,strs := numbers() <span class="comment">//只获取函数返回值的后两个</span></span><br><span class="line">  fmt.Println(numb, strs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个可以返回多个值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">  a , b , c := <span class="number">1</span> , <span class="number">2</span> , <span class="string">&quot;str&quot;</span></span><br><span class="line">  <span class="keyword">return</span> a,b,c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>2 str</p><p>a 因为使用 _ 被抛弃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;用于抛弃不需要接收的变量值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;空白标识符&quot;&gt;&lt;a href=&quot;#空白标识符&quot; class=&quot;headerlink&quot; title=&quot;空白标识符 _&quot;&gt;&lt;/a&gt;空白标识符 _&lt;/h1&gt;&lt;p&gt;作用：在接收
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
      <category term="语法" scheme="https://liukay.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="空白标识符" scheme="https://liukay.com/tags/%E7%A9%BA%E7%99%BD%E6%A0%87%E8%AF%86%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint 共识源码分析</title>
    <link href="https://liukay.com/posts/4334.html"/>
    <id>https://liukay.com/posts/4334.html</id>
    <published>2021-11-03T07:59:17.000Z</published>
    <updated>2021-11-03T07:59:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Tendermint的共识算法可以看成是POS+BFT，Tendermint在进行BFT共识算法确认区块前，首先使用POS算法从Validators中选举出Proposer。<br>然后由Proposer进行提案，最后使用BFT算法生成区块。Tendermint 的共识协议使用的gossip协议。</p><p>另外，源码分析部分由于代码篇幅太长，会省略部分源码，不影响阅读。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Tendermint 共识网络中有两个重要角色</p><ol><li><strong>Validator</strong>: 网络的参与者，也是区块的验证者（预先配置的网络中的一般验证者账户们）</li><li><strong>Proposer</strong>: 从validator中选举出一个节点成为出块人（选举出的出块人），选举不需要网络通信，这点后面从源码中说明。</li></ol><h2 id="共识5个阶段"><a href="#共识5个阶段" class="headerlink" title="共识5个阶段"></a>共识5个阶段</h2><ol><li>NewHeight</li><li>propose</li><li>prevote</li><li>precommit</li><li>commit</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                        +--------------------------------------+</span><br><span class="line">                        v                                      |(Wait til `CommmitTime+timeoutCommit`)</span><br><span class="line">                   +-----------+                         +-----+-----+</span><br><span class="line">      +----------&gt; |  Propose  +--------------+          | NewHeight |</span><br><span class="line">      |            +-----------+              |          +-----------+</span><br><span class="line">      |                                       |                ^</span><br><span class="line">      |(Else, after timeoutPrecommit)         v                |</span><br><span class="line">+-----+-----+                           +-----------+          |</span><br><span class="line">| Precommit |  &lt;------------------------+  Prevote  |          |</span><br><span class="line">+-----+-----+                           +-----------+          |</span><br><span class="line">      |(When +2/3 Precommits for block found)                  |</span><br><span class="line">      v                                                        |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">|  Commit                                                            |</span><br><span class="line">|                                                                    |</span><br><span class="line">|  * Set CommitTime = now;                                           |</span><br><span class="line">|  * Wait for block, then stage/save/commit block;                   |</span><br><span class="line">+--------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>阶段：Propose阶段、Prevote阶段、Precommit阶段<br>投票种类：prevote、precommit、commit</p><h2 id="round-based-协议"><a href="#round-based-协议" class="headerlink" title="round-based 协议"></a>round-based 协议</h2><p>整个Tendermint区块链网络需要通过Round-based协议来决定下一个区块，在区块链中共识的直接目的就是确定下一个区块内容、链接下一个区块</p><p>round-based 协议是一个状态机，主要有:</p><blockquote><p>NewHeigh -&gt; Propose -&gt; Prevote -&gt; Precommit -&gt; Commit</p></blockquote><p>上述每个状态都被称为一个 Step。首尾的 NewHeigh 和 Commit ，这两个 Steps 被称为特殊的 Step。</p><h3 id="Round"><a href="#Round" class="headerlink" title="Round"></a>Round</h3><p>而中间循环三个 Steps则被称为一个 <code>Round</code>(<code>Propose</code> -&gt; <code>Prevote</code> -&gt; <code>Precommit</code>)，是<code>共识阶段</code>，也是算法的核心原理所在。</p><p>一个块的最终提交（Commit）可能需要多个 Round 过程，这是因为有许多原因可能会导致当前 Round 不成功（比如出块节点 Offline，提出的块是无效块，收到的 Prevote 或者 Precommit 票数不够 +2/3 等等）。</p><h3 id="共识失败怎么办"><a href="#共识失败怎么办" class="headerlink" title="共识失败怎么办"></a>共识失败怎么办</h3><p>如果出块节点 Offline，提出的块是无效块，收到的 Prevote 或者 Precommit 票数不够 +2/3<br>出现这些情况的话，解决方案就是移步到下一轮，或者增加 timeout 时间。</p><h3 id="共识流程"><a href="#共识流程" class="headerlink" title="共识流程"></a>共识流程</h3><ol><li><strong>NewHeight 阶段：</strong>当区块链达到一个新的高度时进入 NewHeight 阶段。</li><li><strong>propose 阶段：</strong>接下来 Propose 阶段会提交一个 proposal ，</li><li><strong>prevote 阶段：</strong>prevote 阶段会对收到的 proposal 进行 prevote 投票。</li><li><strong>precommit 阶段：</strong>在 precommit 阶段收集到+⅔ prevote 投票后，对 block 进行 precommit 投票。</li><li><strong>commit阶段：</strong><ul><li>如果收集到+⅔ precommit 投票后则进入 commit 阶段，</li><li>如果没有收集到+⅔ precommit 投票，会再次进入 propose 段。<br>在共识阶段期间如果收到+⅔ commit 投票那么直接进入 commit 阶段。<br>以上就是算法运行的整体过程，接下来分阶段来阐述各个阶段。</li></ul></li></ol><h2 id="Round0-首轮共识分析"><a href="#Round0-首轮共识分析" class="headerlink" title="Round0 首轮共识分析"></a>Round0 首轮共识分析</h2><p>服务刚启动时，节点进入第一轮状态共识，Tendenmint 称之为<code>Round0</code>。<br>启动流程如下</p><p><img src="/posts/4334/启动首论共识.png" alt="启动首论共识"></p><h3 id="Round0-是什么做用？做了哪些事"><a href="#Round0-是什么做用？做了哪些事" class="headerlink" title="Round0 是什么做用？做了哪些事"></a>Round0 是什么做用？做了哪些事</h3><p>主要是通过监听消息，来处理对应消息类型携带的事件。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>OnStart</li><li>receiveRoutine 启动接收程序<br>go cs.receiveRoutine</li><li>scheduleRound0: 注意，这个发送的是内部消息，不是 peer消息</li><li>scheduleTimeout 发送<code>round0</code> 的事件，事件类型：<code>receiveRoutine</code></li><li>receiveRoutine: 处理事件</li></ol><h4 id="共识核心方法说明"><a href="#共识核心方法说明" class="headerlink" title="共识核心方法说明"></a>共识核心方法说明</h4><p>receiveRoutine 核心方法<br>这个函数就比较重要了，它处理了可能导致状态转换的消息。<br>其中超时消息、完成一个提案和超过2/3的投票都会导致状态转换。<br>通过监听各种 Queue 的消息类型来处理</p><p>state.go 源码分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OnStart loads the latest state via the WAL, and starts the timeout and</span></span><br><span class="line"><span class="comment">// receive routines.</span></span><br><span class="line"><span class="comment">// OnStart通过WAL加载最新状态，并启动超时和接收程序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// We may set the WAL in testing before calling Start, so only OpenWAL if its</span></span><br><span class="line">    <span class="comment">// still the nilWAL.</span></span><br><span class="line">    <span class="comment">// 在测试中，我们可能会在调用Start之前设置WAL，所以只有在其仍然是nilWAL的情况下才会打开WAL。</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := cs.wal.(nilWAL); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> err := cs.loadWalFile(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We may have lost some votes if the process crashed reload from consensus</span></span><br><span class="line">    <span class="comment">// log to catchup.</span></span><br><span class="line">    <span class="comment">// 如果从共识日志到追赶的过程中崩溃重新加载，我们可能会失去一些票数。</span></span><br><span class="line">    <span class="keyword">if</span> cs.doWALCatchup &#123;</span><br><span class="line">        repairAttempted := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    LOOP:</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            err := cs.catchupReplay(cs.Height)</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> !IsDataCorruptionError(err):</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;error on catchup replay; proceeding to start state anyway&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> repairAttempted:</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cs.Logger.Error(<span class="string">&quot;the WAL file is corrupted; attempting repair&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1) prep work</span></span><br><span class="line">            <span class="keyword">if</span> err := cs.wal.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            repairAttempted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2) backup original WAL file</span></span><br><span class="line">            corruptedFile := fmt.Sprintf(<span class="string">&quot;%s.CORRUPTED&quot;</span>, cs.config.WalFile())</span><br><span class="line">            <span class="keyword">if</span> err := tmos.CopyFile(cs.config.WalFile(), corruptedFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cs.Logger.Debug(<span class="string">&quot;backed up WAL file&quot;</span>, <span class="string">&quot;src&quot;</span>, cs.config.WalFile(), <span class="string">&quot;dst&quot;</span>, corruptedFile)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3) try to repair (WAL file will be overwritten!)</span></span><br><span class="line">            <span class="keyword">if</span> err := repairWalFile(corruptedFile, cs.config.WalFile()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;the WAL repair failed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cs.Logger.Info(<span class="string">&quot;successful WAL repair&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reload WAL file</span></span><br><span class="line">            <span class="keyword">if</span> err := cs.loadWalFile(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EventSwitch 只监听 EventNewRoundStep、EventValidBlock和EventVote 这三种事件</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.evsw.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need the timeoutRoutine for replay so</span></span><br><span class="line">    <span class="comment">// we don&#x27;t block on the tick chan.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we will get a build up of garbage go routines</span></span><br><span class="line">    <span class="comment">// firing on the tockChan until the receiveRoutine is started</span></span><br><span class="line">    <span class="comment">// to deal with them (by that point, at most one will be valid)</span></span><br><span class="line">    <span class="comment">// 我们需要重放的timeoutRoutine，这样我们就不会在tick chan上阻塞。</span></span><br><span class="line">    <span class="comment">// 注意：我们将得到大量的垃圾程序</span></span><br><span class="line">    <span class="comment">// 直到receiveRoutine开始处理它们（到那时，最多只有一个是有效的）来处理它们（到那时，最多只有一个是有效的）。</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.timeoutTicker.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Double Signing Risk Reduction</span></span><br><span class="line">    <span class="comment">// 检查双重验签</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.checkDoubleSigningRisk(cs.Height); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now start the receiveRoutine</span></span><br><span class="line">    <span class="comment">// 启动接收程序</span></span><br><span class="line">    <span class="keyword">go</span> cs.receiveRoutine(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedule the first round!</span></span><br><span class="line">    <span class="comment">// use GetRoundState so we don&#x27;t race the receiveRoutine for access</span></span><br><span class="line">    <span class="comment">// 安排第一轮!</span></span><br><span class="line">    <span class="comment">// 使用GetRoundState，这样我们就不会和receiveRoutine争夺访问权了。</span></span><br><span class="line">    cs.scheduleRound0(cs.GetRoundState())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送内部消息-cs-scheduleRound0"><a href="#发送内部消息-cs-scheduleRound0" class="headerlink" title="发送内部消息 cs.scheduleRound0"></a>发送内部消息 cs.scheduleRound0</h2><p>scheduleRound0 的作用是将消息发送到内部的 chan 当中，receiveRoutine 负责监听不同类型事件，会监听到这个事件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enterNewRound(height, 0) at cs.StartTime.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">scheduleRound0</span><span class="params">(rs *cstypes.RoundState)</span></span> &#123;</span><br><span class="line">    <span class="comment">// cs.Logger.Info(&quot;scheduleRound0&quot;, &quot;now&quot;, tmtime.Now(), &quot;startTime&quot;, cs.StartTime)</span></span><br><span class="line">    sleepDuration := rs.StartTime.Sub(tmtime.Now())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一轮是发送了 cstypes.RoundStepNewHeight 事件类型</span></span><br><span class="line">    cs.scheduleTimeout(sleepDuration, rs.Height, <span class="number">0</span>, cstypes.RoundStepNewHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送内部消息，最终将消息发送到 chan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduleTimeout schedules a new timeout by sending on the internal tickChan.</span></span><br><span class="line"><span class="comment">// The timeoutRoutine is always available to read from tickChan, so this won&#x27;t block.</span></span><br><span class="line"><span class="comment">// The scheduling may fail if the timeoutRoutine has already scheduled a timeout for a later height/round/step.</span></span><br><span class="line"><span class="comment">// ScheduleTimeout通过在内部tickChan上发送来安排一个新的超时。</span></span><br><span class="line"><span class="comment">// timeoutRoutine总是可以从tickChan中读取，所以这不会阻塞。</span></span><br><span class="line"><span class="comment">// 如果timeoutRoutine已经为以后的高度/轮次/步长安排了一个超时，则调度可能会失败。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timeoutTicker)</span> <span class="title">ScheduleTimeout</span><span class="params">(ti timeoutInfo)</span></span> &#123;</span><br><span class="line">    t.tickChan &lt;- ti</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="核心处理逻辑"><a href="#核心处理逻辑" class="headerlink" title="核心处理逻辑"></a>核心处理逻辑</h2><h3 id="主要是-receiveRoutine-处理"><a href="#主要是-receiveRoutine-处理" class="headerlink" title="主要是 receiveRoutine 处理"></a>主要是 receiveRoutine 处理</h3><p>receiveRoutine 处理消息类型</p><ol><li>peerMsgQueue 来自节点的消息</li><li>internalMsgQueue 内部消息</li><li>timeoutTicker 超时的消息<br>timeoutTicker 这个消息，就是被上面流程中<code>scheduleRound0</code>发出的消息</li></ol><h3 id="receiveRoutine-处理流程"><a href="#receiveRoutine-处理流程" class="headerlink" title="receiveRoutine 处理流程"></a>receiveRoutine 处理流程</h3><ol><li>根据类型选把处理器<br>cs.timeoutTicker.Chan()</li><li>handleTimeout 处理<br>处理具体类型</li></ol><h3 id="handleTimeout-处理具体事件类型"><a href="#handleTimeout-处理具体事件类型" class="headerlink" title="handleTimeout 处理具体事件类型"></a>handleTimeout 处理具体事件类型</h3><ol><li>监听<code>RoundStepNewHeight</code>事件<br>case cstypes.RoundStepNewHeight:</li><li>进入 Round 流程<br>这个就重点了，概据官方文档说明，每一次共识都有 5 个步骤，这个是第一步。<br>cs.enterNewRound(ti.Height, 0)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">// the main go routines</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// receiveRoutine handles messages which may cause state transitions.</span></span><br><span class="line"><span class="comment">// it&#x27;s argument (n) is the number of messages to process before exiting - use 0 to run forever</span></span><br><span class="line"><span class="comment">// It keeps the RoundState and is the only thing that updates it.</span></span><br><span class="line"><span class="comment">// Updates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.</span></span><br><span class="line"><span class="comment">// State must be locked before any internal state is updated.</span></span><br><span class="line"><span class="comment">// receiveRoutine处理可能导致状态转换的消息。</span></span><br><span class="line"><span class="comment">// 它的参数(n)是退出前要处理的消息的数量--用0表示永远运行。</span></span><br><span class="line"><span class="comment">// 它保持RoundState，并且是唯一能更新它的东西。</span></span><br><span class="line"><span class="comment">// 更新（状态转换）发生在超时、完整提案和2/3多数的情况下。</span></span><br><span class="line"><span class="comment">// 在任何内部状态被更新之前，状态必须被锁定。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">receiveRoutine</span><span class="params">(maxSteps <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 拿到当前链状态</span></span><br><span class="line">        rs := cs.RoundState</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，这个是接收的 reactor 的消息</span></span><br><span class="line">        <span class="keyword">var</span> mi msgInfo</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理三种类型的消息</span></span><br><span class="line">        <span class="comment">// 1.peerMsgQueue 来自节点的消息</span></span><br><span class="line">        <span class="comment">// 2.internalMsgQueue 内部消息</span></span><br><span class="line">        <span class="comment">// 3.timeoutTicker 超时的消息</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-cs.txNotifier.TxsAvailable():</span><br><span class="line">            cs.handleTxsAvailable()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// peer 节点消息</span></span><br><span class="line">        <span class="keyword">case</span> mi = &lt;-cs.peerMsgQueue:</span><br><span class="line">            <span class="keyword">if</span> err := cs.wal.Write(mi); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;failed writing to WAL&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// handles proposals, block parts, votes</span></span><br><span class="line">            <span class="comment">// may generate internal events (votes, complete proposals, 2/3 majorities)</span></span><br><span class="line">            cs.handleMsg(mi)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//监听内部队列消息</span></span><br><span class="line">        <span class="keyword">case</span> mi = &lt;-cs.internalMsgQueue:</span><br><span class="line">            err := cs.wal.WriteSync(mi) <span class="comment">// <span class="doctag">NOTE:</span> fsync</span></span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(fmt.Sprintf(</span><br><span class="line">                    <span class="string">&quot;failed to write %v msg to consensus WAL due to %v; check your file system and restart the node&quot;</span>,</span><br><span class="line">                    mi, err,</span><br><span class="line">                ))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// handles proposals, block parts, votes</span></span><br><span class="line">            <span class="comment">// 核心的状态逻辑处理，处理 proposals, block parts, votes</span></span><br><span class="line">            cs.handleMsg(mi)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这个监听，ScheduleTimeout 的 channel</span></span><br><span class="line">        <span class="keyword">case</span> ti := &lt;-cs.timeoutTicker.Chan(): <span class="comment">// tockChan:</span></span><br><span class="line">            <span class="keyword">if</span> err := cs.wal.Write(ti); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                cs.Logger.Error(<span class="string">&quot;failed writing to WAL&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the timeout is relevant to the rs</span></span><br><span class="line">            <span class="comment">// go to the next step</span></span><br><span class="line">            cs.handleTimeout(ti, rs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-cs.Quit():</span><br><span class="line">            onExit(cs)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="handleTimeout-分析"><a href="#handleTimeout-分析" class="headerlink" title="handleTimeout 分析"></a>handleTimeout 分析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入新一轮</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *State)</span> <span class="title">enterNewRound</span><span class="params">(height <span class="keyword">int64</span>, round <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    logger := cs.Logger.With(<span class="string">&quot;height&quot;</span>, height, <span class="string">&quot;round&quot;</span>, round)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cs.Height != height || round &lt; cs.Round || (cs.Round == round &amp;&amp; cs.Step != cstypes.RoundStepNewHeight) &#123;</span><br><span class="line">        logger.Debug(</span><br><span class="line">            <span class="string">&quot;entering new round with invalid args&quot;</span>,</span><br><span class="line">            <span class="string">&quot;current&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v/%v/%v&quot;</span>, cs.Height, cs.Round, cs.Step),</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> now := tmtime.Now(); cs.StartTime.After(now) &#123;</span><br><span class="line">        logger.Debug(<span class="string">&quot;need to set a buffer and log message here for sanity&quot;</span>, <span class="string">&quot;start_time&quot;</span>, cs.StartTime, <span class="string">&quot;now&quot;</span>, now)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.Debug(<span class="string">&quot;entering new round&quot;</span>, <span class="string">&quot;current&quot;</span>, fmt.Sprintf(<span class="string">&quot;%v/%v/%v&quot;</span>, cs.Height, cs.Round, cs.Step))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment validators if necessary</span></span><br><span class="line">    <span class="comment">// 必要时增加 validator</span></span><br><span class="line">    validators := cs.Validators</span><br><span class="line">    <span class="keyword">if</span> cs.Round &lt; round &#123;</span><br><span class="line">        validators = validators.Copy()</span><br><span class="line">        validators.IncrementProposerPriority(tmmath.SafeSubInt32(round, cs.Round))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup new round</span></span><br><span class="line">    <span class="comment">// we don&#x27;t fire newStep for this step,</span></span><br><span class="line">    <span class="comment">// but we fire an event, so update the round step first</span></span><br><span class="line">    <span class="comment">// 只是 set 值，并没有接口调用</span></span><br><span class="line">    cs.updateRoundStep(round, cstypes.RoundStepNewRound)</span><br><span class="line">    ...<span class="comment">//省略部分代码</span></span><br><span class="line">    cs.Votes.SetRound(tmmath.SafeAddInt32(round, <span class="number">1</span>)) <span class="comment">// also track next round (round+1) to allow round-skipping</span></span><br><span class="line">    cs.TriggeredTimeoutPrecommit = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件？？</span></span><br><span class="line">    <span class="keyword">if</span> err := cs.eventBus.PublishEventNewRound(cs.NewRoundEvent()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        cs.Logger.Error(<span class="string">&quot;failed publishing new round&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cs.metrics.Rounds.Set(<span class="keyword">float64</span>(round))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for txs to be available in the mempool</span></span><br><span class="line">    <span class="comment">// before we enterPropose in round 0. If the last block changed the app hash,</span></span><br><span class="line">    <span class="comment">// we may need an empty &quot;proof&quot; block, and enterPropose immediately.</span></span><br><span class="line">    <span class="comment">// 进入 round0 之前，等待mempool中的txs可用。</span></span><br><span class="line">    <span class="comment">// 如果最后一个区块改变了应用程序的哈希值，我们可能需要一个空的 &quot;证明 &quot;区块，并立即输入Propose。</span></span><br><span class="line">    waitForTxs := cs.config.WaitForTxs() &amp;&amp; round == <span class="number">0</span> &amp;&amp; !cs.needProofBlock(height)</span><br><span class="line">    <span class="keyword">if</span> waitForTxs &#123;</span><br><span class="line">        <span class="keyword">if</span> cs.config.CreateEmptyBlocksInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 构建空块证明，进入下一个阶段</span></span><br><span class="line">            cs.scheduleTimeout(cs.config.CreateEmptyBlocksInterval, height, round,</span><br><span class="line">                cstypes.RoundStepNewRound)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 进入 propose 阶段</span></span><br><span class="line">        cs.enterPropose(height, round)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;Tendermint的共识算法可以看成是POS+BFT，Tendermint在进行BFT共识算法确认区块前，首先使用POS算法从Valida
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/tendermint/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/Tendermint/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BlockChain" scheme="https://liukay.com/tags/BlockChain/"/>
    
      <category term="共识" scheme="https://liukay.com/tags/%E5%85%B1%E8%AF%86/"/>
    
      <category term="源码分析" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint 启动流程</title>
    <link href="https://liukay.com/posts/11173.html"/>
    <id>https://liukay.com/posts/11173.html</id>
    <published>2021-11-03T06:31:52.000Z</published>
    <updated>2021-11-03T06:31:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>Tendermint 的启动流程比较清析明了，各业务启动流程都在对应的实现代码，主启动流程加载所需配置，由各启动实现类启动自己对应业务，如节点启动相关在 nodeImpl，共识相关处理是 state 中进行处理。</p><p>流程大致：</p><ol><li>加载配置 <code>node.NewDefault</code></li><li>启动运行 <code>Start</code></li><li>启动相关实现的 <code>OnStart</code></li></ol><p>先看启动流程</p><p><img src="/posts/11173/服务启动.png" alt="服务启动"></p><p>启动入口代码，这里使用到了一个命令行工具：<code>cobra</code>。<br>代码位置：<code>cmd/tendermint/main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...省略部份代码</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">    <span class="comment">// Users wishing to:</span></span><br><span class="line">    <span class="comment">//    * Use an external signer for their validators</span></span><br><span class="line">    <span class="comment">//    * Supply an in-proc abci app</span></span><br><span class="line">    <span class="comment">//    * Supply a genesis doc file from another source</span></span><br><span class="line">    <span class="comment">//    * Provide their own DB implementation</span></span><br><span class="line">    <span class="comment">// can copy this file and use something other than the</span></span><br><span class="line">    <span class="comment">// node.NewDefault function</span></span><br><span class="line">    <span class="comment">// 创建节点为默认动行节点，这里是函数引用，并未执行</span></span><br><span class="line">    <span class="comment">// 在 cmd.NewRunNodeCmd 调用</span></span><br><span class="line">    nodeFunc := node.NewDefault</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create &amp; start node</span></span><br><span class="line">    <span class="comment">// 主要方法 cmd.NewRunNodeCmd</span></span><br><span class="line">    rootCmd.AddCommand(cmd.NewRunNodeCmd(nodeFunc))</span><br><span class="line"></span><br><span class="line">    cmd := cli.PrepareBaseCmd(rootCmd, <span class="string">&quot;TM&quot;</span>, os.ExpandEnv(filepath.Join(<span class="string">&quot;$HOME&quot;</span>, config.DefaultTendermintDir)))</span><br><span class="line">    <span class="keyword">if</span> err := cmd.Execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建运行节点"><a href="#创建运行节点" class="headerlink" title="创建运行节点"></a>创建运行节点</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewRunNodeCmd returns the command that allows the CLI to start a node.</span></span><br><span class="line"><span class="comment">// It can be used with a custom PrivValidator and in-process ABCI application.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRunNodeCmd</span><span class="params">(nodeProvider cfg.ServiceProvider)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="comment">// 添加到命令行</span></span><br><span class="line">    cmd := &amp;cobra.Command&#123;</span><br><span class="line">        Use:     <span class="string">&quot;start&quot;</span>,</span><br><span class="line">        Aliases: []<span class="keyword">string</span>&#123;<span class="string">&quot;node&quot;</span>, <span class="string">&quot;run&quot;</span>&#125;,</span><br><span class="line">        Short:   <span class="string">&quot;Run the tendermint node&quot;</span>,</span><br><span class="line">        RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err := checkGenesisHash(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里调用 node.NewDefault 这个方法实现</span></span><br><span class="line">            <span class="comment">// 创建了节点</span></span><br><span class="line">            n, err := nodeProvider(config, logger)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create node: %w&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动服务</span></span><br><span class="line">            <span class="keyword">if</span> err := n.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to start node: %w&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.Info(<span class="string">&quot;started node&quot;</span>, <span class="string">&quot;node&quot;</span>, n.String())</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Stop upon receiving SIGTERM or CTRL-C.</span></span><br><span class="line">            tmos.TrapSignal(logger, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> n.IsRunning() &#123;</span><br><span class="line">                    <span class="keyword">if</span> err := n.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        logger.Error(<span class="string">&quot;unable to stop the node&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Run forever.</span></span><br><span class="line">            <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddNodeFlags(cmd)</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动需的默认配置一目了然</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultConfig returns a default configuration for a Tendermint node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultConfig</span><span class="params">()</span> *<span class="title">Config</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Config&#123;</span><br><span class="line">        BaseConfig:      DefaultBaseConfig(),</span><br><span class="line">        RPC:             DefaultRPCConfig(),</span><br><span class="line">        P2P:             DefaultP2PConfig(),</span><br><span class="line">        Mempool:         DefaultMempoolConfig(),</span><br><span class="line">        StateSync:       DefaultStateSyncConfig(),</span><br><span class="line">        BlockSync:       DefaultBlockSyncConfig(),</span><br><span class="line">        Consensus:       DefaultConsensusConfig(),</span><br><span class="line">        TxIndex:         DefaultTxIndexConfig(),</span><br><span class="line">        Instrumentation: DefaultInstrumentationConfig(),</span><br><span class="line">        PrivValidator:   DefaultPrivValidatorConfig(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>启动服务接口 <code>Service</code> 主要实现类是<code>BaseService</code>。</p><p>service.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service defines a service that can be started, stopped, and reset.</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Start the service.</span></span><br><span class="line">    <span class="comment">// If it&#x27;s already started or stopped, will return an error.</span></span><br><span class="line">    <span class="comment">// If OnStart() returns an error, it&#x27;s returned by Start()</span></span><br><span class="line">    Start() error</span><br><span class="line">    OnStart() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动-node"><a href="#启动-node" class="headerlink" title="启动 node"></a>启动 node</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start implements Service by calling OnStart (if defined). An error will be</span></span><br><span class="line"><span class="comment">// returned if the service is already running or stopped. Not to start the</span></span><br><span class="line"><span class="comment">// stopped service, you need to call Reset.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *BaseService)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapUint32(&amp;bs.started, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> atomic.LoadUint32(&amp;bs.stopped) == <span class="number">1</span> &#123;</span><br><span class="line">            bs.Logger.Error(<span class="string">&quot;not starting service; already stopped&quot;</span>, <span class="string">&quot;service&quot;</span>, bs.name, <span class="string">&quot;impl&quot;</span>, bs.impl.String())</span><br><span class="line">            atomic.StoreUint32(&amp;bs.started, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ErrAlreadyStopped</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bs.Logger.Info(<span class="string">&quot;starting service&quot;</span>, <span class="string">&quot;service&quot;</span>, bs.name, <span class="string">&quot;impl&quot;</span>, bs.impl.String())</span><br><span class="line">        <span class="comment">// 启动节点。BaseService 有很多实，都实现 OnStart。</span></span><br><span class="line">        <span class="comment">// 服务启动是：node.go OnStart</span></span><br><span class="line">        <span class="comment">// 共识启动是: state.go OnStart</span></span><br><span class="line">        <span class="keyword">if</span> err := bs.impl.OnStart(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// revert flag</span></span><br><span class="line">            atomic.StoreUint32(&amp;bs.started, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs.Logger.Debug(<span class="string">&quot;not starting service; already started&quot;</span>, <span class="string">&quot;service&quot;</span>, bs.name, <span class="string">&quot;impl&quot;</span>, bs.impl.String())</span><br><span class="line">    <span class="keyword">return</span> ErrAlreadyStarted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nodeImpl 实现启动流程，总的来说还是比较清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// OnStart starts the Node. It implements service.Service.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *nodeImpl)</span> <span class="title">OnStart</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    now := tmtime.Now()</span><br><span class="line">    genTime := n.genesisDoc.GenesisTime</span><br><span class="line">    <span class="keyword">if</span> genTime.After(now) &#123;</span><br><span class="line">        n.Logger.Info(<span class="string">&quot;Genesis time is in the future. Sleeping until then...&quot;</span>, <span class="string">&quot;genTime&quot;</span>, genTime)</span><br><span class="line">        time.Sleep(genTime.Sub(now))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the RPC server before the P2P server</span></span><br><span class="line">    <span class="comment">// so we can eg. receive txs for the first block</span></span><br><span class="line">    <span class="comment">// 这里顺带说下，tendermint 的3种节点为类型</span></span><br><span class="line">    <span class="comment">//     ModeFull      = &quot;full&quot; 数据转发节点</span></span><br><span class="line">    <span class="comment">//    ModeValidator = &quot;validator&quot;  数据验证节点</span></span><br><span class="line">    <span class="comment">//    ModeSeed      = &quot;seed&quot;   用来做节点发现</span></span><br><span class="line">    <span class="keyword">if</span> n.config.RPC.ListenAddress != <span class="string">&quot;&quot;</span> &amp;&amp; n.config.Mode != config.ModeSeed &#123;</span><br><span class="line">        <span class="comment">// 启动 RPC</span></span><br><span class="line">        listeners, err := n.startRPC()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        n.rpcListeners = listeners</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n.config.Instrumentation.Prometheus &amp;&amp;</span><br><span class="line">        n.config.Instrumentation.PrometheusListenAddr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        n.prometheusSrv = n.startPrometheusServer(n.config.Instrumentation.PrometheusListenAddr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the transport.</span></span><br><span class="line">    addr, err := types.NewNetAddressString(n.nodeKey.ID.AddressString(n.config.P2P.ListenAddress))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := n.transport.Listen(p2p.NewEndpoint(addr)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n.isListening = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p2p 路由</span></span><br><span class="line">    <span class="keyword">if</span> err = n.router.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n.config.Mode != config.ModeSeed &#123;</span><br><span class="line">        <span class="keyword">if</span> n.config.BlockSync.Enable &#123;</span><br><span class="line">            <span class="comment">// 开启区块同步</span></span><br><span class="line">            <span class="keyword">if</span> err := n.bcReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real consensus reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.consensusReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real state sync reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.stateSyncReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real mempool reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.mempoolReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the real evidence reactor separately since the switch uses the shim.</span></span><br><span class="line">        <span class="keyword">if</span> err := n.evidenceReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := n.pexReactor.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run state sync</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We shouldn&#x27;t run state sync if we already have state that has a</span></span><br><span class="line">    <span class="comment">// LastBlockHeight that is not InitialHeight</span></span><br><span class="line">    <span class="keyword">if</span> n.stateSync &#123;</span><br><span class="line">        bcR, ok := n.bcReactor.(consensus.BlockSyncReactor)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;this blockchain reactor does not support switching from state sync&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we need to get the genesis state to get parameters such as</span></span><br><span class="line">        state, err := sm.MakeGenesisState(n.genesisDoc)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to derive state: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> we may want to move these events within the respective</span></span><br><span class="line">        <span class="comment">// reactors.</span></span><br><span class="line">        <span class="comment">// At the beginning of the statesync start, we use the initialHeight as the event height</span></span><br><span class="line">        <span class="comment">// because of the statesync doesn&#x27;t have the concreate state height before fetched the snapshot.</span></span><br><span class="line">        d := types.EventDataStateSyncStatus&#123;Complete: <span class="literal">false</span>, Height: state.InitialHeight&#125;</span><br><span class="line">        <span class="keyword">if</span> err := n.eventBus.PublishEventStateSyncStatus(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            n.eventBus.Logger.Error(<span class="string">&quot;failed to emit the statesync start event&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> We shouldn&#x27;t allow state sync to silently error out without</span></span><br><span class="line">        <span class="comment">// bubbling up the error and gracefully shutting down the rest of the node</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            n.Logger.Info(<span class="string">&quot;starting state sync&quot;</span>)</span><br><span class="line">            state, err := n.stateSyncReactor.Sync(context.TODO())</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                n.Logger.Error(<span class="string">&quot;state sync failed; shutting down this node&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                <span class="comment">// stop the node</span></span><br><span class="line">                <span class="keyword">if</span> err := n.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    n.Logger.Error(<span class="string">&quot;failed to shut down node&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n.consensusReactor.SetStateSyncingMetrics(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            d := types.EventDataStateSyncStatus&#123;Complete: <span class="literal">true</span>, Height: state.LastBlockHeight&#125;</span><br><span class="line">            <span class="keyword">if</span> err := n.eventBus.PublishEventStateSyncStatus(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                n.eventBus.Logger.Error(<span class="string">&quot;failed to emit the statesync start event&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Some form of orchestrator is needed here between the state</span></span><br><span class="line">            <span class="comment">// advancing reactors to be able to control which one of the three</span></span><br><span class="line">            <span class="comment">// is running</span></span><br><span class="line">            <span class="keyword">if</span> n.config.BlockSync.Enable &#123;</span><br><span class="line">                <span class="comment">// FIXME Very ugly to have these metrics bleed through here.</span></span><br><span class="line">                n.consensusReactor.SetBlockSyncingMetrics(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> err := bcR.SwitchToBlockSync(state); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    n.Logger.Error(<span class="string">&quot;failed to switch to block sync&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                d := types.EventDataBlockSyncStatus&#123;Complete: <span class="literal">false</span>, Height: state.LastBlockHeight&#125;</span><br><span class="line">                <span class="keyword">if</span> err := n.eventBus.PublishEventBlockSyncStatus(d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    n.eventBus.Logger.Error(<span class="string">&quot;failed to emit the block sync starting event&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n.consensusReactor.SwitchToConsensus(state, <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;启动流程&quot;&gt;&lt;a href=&quot;#启动流程&quot; class=&quot;headerlink&quot; title=&quot;启动流程&quot;&gt;&lt;/a&gt;启动流程&lt;/h1&gt;&lt;p&gt;Tendermint 的启动流程比较清析明了，各业务启动流程都在对应的实现代码，主启动流程加载所需配置，由各启动实现类启动自
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BlockChain" scheme="https://liukay.com/tags/BlockChain/"/>
    
      <category term="源码分析" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="启动流程" scheme="https://liukay.com/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint ABCI概述</title>
    <link href="https://liukay.com/posts/6715.html"/>
    <id>https://liukay.com/posts/6715.html</id>
    <published>2021-11-02T03:35:30.000Z</published>
    <updated>2021-11-02T03:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABCI-概述-Application-BlockChain-Interface"><a href="#ABCI-概述-Application-BlockChain-Interface" class="headerlink" title="ABCI 概述 (Application BlockChain Interface)"></a>ABCI 概述 (Application BlockChain Interface)</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>让<code>应用程序层</code> 和 <code>共识层进行</code>解耦。可以理解为一套应用程序的接口标准，是<code>应用程序层</code>和<code>共识层进行</code>的桥梁。</p><p>应用程序区块链接口（ABCI） 允许用任何编程语言实现应用程序拜占庭容错复制。<br>区块链是多主状态机复制的系统。ABCI是一个接口，定义了复制引擎（区块链）和状态机（应用程序）之间的边界。使用Socket协议，运行在一个进程中的共识引擎可以管理运行在另一个进程中的应用程序状态。<br>以前，ABCI被称为TMSP。</p><p>官方github：<a href="https://github.com/tendermint/tendermint/tree/master/abci">ABCI</a></p><p><img src="/posts/6715/abci.png" alt="abci"></p><h2 id="开发动机"><a href="#开发动机" class="headerlink" title="开发动机"></a>开发动机</h2><p>目前为止，所有的区块链“技术栈”（如比特币）都是作为一个紧耦合的整体进行设计的。 换句话说，每一个区块链技术栈都是一个单独的程序，处理分布式账本的所有问题。 这些问题包括P2P连接、交易内存池广播、最新区块共识、账户余额、图灵完备合约、用户级权限管理等。</p><p>在计算机科学中，过高耦合度的程序架构通常不是好做法。 因为耦合度高会导致程序难以复用，并且这样做易导致代码库分叉进而维护困难。 当开发者没有对代码库进行模块化设计并遭受“意大利面代码”的困扰时，这种设计方式导致的问题更加明显。</p><p>高耦合度设计导致的另一个问题是所使用的开发语言受限于区块链技术栈（反之亦然）。在以太坊中，它提供一个图灵完备的字节码合约虚拟机，这就把开发者限制在了对应的合约语言上；<br>目前，这个合约语言是Serpent和Solidity。</p><p>相比之下，Tendermint分离了共识引擎和P2P层与特定区块链程序的应用状态细节。 Tendermint将应用程序的状态管理细节抽象到一个接口，并将该接口以socket协议的形式实现了出来。</p><p>所以，Tendermint拥有接口规范，即应用程序区块链接口（ABCI），并有了一个主要实现Tendermint socket协议（也叫TSP或Teaspoon）。</p><h2 id="ABCI介绍"><a href="#ABCI介绍" class="headerlink" title="ABCI介绍"></a>ABCI介绍</h2><p>ABCI 与 Tendermint Core 通信<br>Tendermint Core （“共识引擎”）通过满足<code>ABCI规范</code>的socket协议与应用程序通信。</p><h2 id="ABCI-应用"><a href="#ABCI-应用" class="headerlink" title="ABCI 应用"></a>ABCI 应用</h2><p>如果有人想在ABCI上创建一个类似比特币的系统，</p><h3 id="Tendermint-Core将会实现"><a href="#Tendermint-Core将会实现" class="headerlink" title="Tendermint Core将会实现"></a>Tendermint Core将会实现</h3><ul><li>在节点之间共享区块和交易</li><li>建立交易标准/不可更改的顺序（即区块链）</li></ul><h3 id="应用程序将会实现"><a href="#应用程序将会实现" class="headerlink" title="应用程序将会实现"></a>应用程序将会实现</h3><ul><li>维护UTXO数据库</li><li>验证交易签名</li><li>防止使用未产生的交易</li><li>允许客户端查询UTXO数据库</li></ul><p>Tendermint通过在应用程序进程和共识进程之间提供非常简单的API（即ABCI）来分解区块链设计。</p><p>ABI由3种主要消息类型组成，它们从Tendermint核心传递到应用程序，应用程序用相应的响应消息进行回复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABCI-概述-Application-BlockChain-Interface&quot;&gt;&lt;a href=&quot;#ABCI-概述-Application-BlockChain-Interface&quot; class=&quot;headerlink&quot; title=&quot;ABCI 概述 (App
      
    
    </summary>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
    
      <category term="概念" scheme="https://liukay.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/tags/Tendermint/"/>
    
      <category term="概述" scheme="https://liukay.com/tags/%E6%A6%82%E8%BF%B0/"/>
    
      <category term="快速入门" scheme="https://liukay.com/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    
      <category term="ABCI" scheme="https://liukay.com/tags/ABCI/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="BlockChain" scheme="https://liukay.com/tags/BlockChain/"/>
    
  </entry>
  
  <entry>
    <title>go 数组</title>
    <link href="https://liukay.com/posts/10187.html"/>
    <id>https://liukay.com/posts/10187.html</id>
    <published>2021-11-02T02:45:56.000Z</published>
    <updated>2021-11-02T02:45:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言数组声明有两种方式，1.定长数组，2.不定长度数组<br>注意：</p><ol><li>如果没有赋值，会有默认值<ul><li>int 数组，默认初始化为 0</li><li>string 就是空串</li></ul></li><li>数据类型必须相同，不能混用，int数组不能包含float 等，已验证</li><li>boolean 是false</li><li>数组越界是 panic 异常</li><li>数组是值类型，默认情况下是值拷贝，也就是说每次拷贝后是一个独立副本，数组间互不影响。</li><li>可以使用指针来实现引用传递</li></ol><h2 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h2><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  数组名 [数组大小]数据类型</span><br></pre></td></tr></table></figure><h3 id="1-定长数组"><a href="#1-定长数组" class="headerlink" title="1.定长数组"></a>1.定长数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> P01var</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest3</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> hens [<span class="number">6</span>]<span class="keyword">int</span></span><br><span class="line">   hens[<span class="number">0</span>] = <span class="number">111</span></span><br><span class="line">   hens[<span class="number">1</span>] = <span class="number">222</span></span><br><span class="line">   hens[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(hens); i++ &#123;</span><br><span class="line">           fmt.Printf(<span class="string">&quot;打印数组i=%d, 数据=%d\n&quot;</span>, i, hens[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打印数组i=0, 数据=111</span><br><span class="line">打印数组i=1, 数据=222</span><br><span class="line">打印数组i=2, 数据=333</span><br><span class="line">打印数组i=3, 数据=0</span><br><span class="line">打印数组i=4, 数据=0</span><br><span class="line">打印数组i=5, 数据=0</span><br></pre></td></tr></table></figure><p>如果输入超过实初始化的长度会越界，<br>//越界<br>hens[9] = 999</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../ArrayTest.go:11:6: invalid array index 9 (out of bounds for 6-element array)</span><br></pre></td></tr></table></figure><p>初始化二，类似java的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一般用这种方式</span></span><br><span class="line">  balance := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不定数组长度"><a href="#2-不定数组长度" class="headerlink" title="2.不定数组长度"></a>2.不定数组长度</h3><p>如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> balance = [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">  <span class="comment">//或</span></span><br><span class="line">  balance := [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通过下标初始化"><a href="#3-通过下标初始化" class="headerlink" title="3.通过下标初始化"></a>3.通过下标初始化</h3><p>如果设置了数组的长度，我们还可以通过指定下标来初始化元素：</p><p>1:2 和 3:7.0 就是初始化了 1 和 3 两个元素<br>初始化 balance[4]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  balance := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1</span>:<span class="number">2.0</span>,<span class="number">3</span>:<span class="number">7.0</span>&#125;</span><br><span class="line"></span><br><span class="line">  balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 [5]int 后，[…]int 后的个数要对上，否则报错，已测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  <span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125; <span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 4.遍历数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> n [<span class="number">10</span>]<span class="keyword">int</span> <span class="comment">/* n 是一个长度为 10 的数组 */</span></span><br><span class="line">   <span class="keyword">var</span> i,j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 为数组 n 初始化元素 */</span></span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      n[i] = i + <span class="number">100</span> <span class="comment">/* 设置元素为 i + 100 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">   <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Element[%d] = %d\n&quot;</span>, j, n[j] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Element[0] = 100</span><br><span class="line">Element[1] = 101</span><br><span class="line">Element[2] = 102</span><br><span class="line">Element[3] = 103</span><br><span class="line">Element[4] = 104</span><br><span class="line">Element[5] = 105</span><br><span class="line">Element[6] = 106</span><br><span class="line">Element[7] = 107</span><br><span class="line">Element[8] = 108</span><br><span class="line">Element[9] = 109</span><br></pre></td></tr></table></figure><h3 id="5-声明数组的同时快速初始化数组"><a href="#5-声明数组的同时快速初始化数组" class="headerlink" title="5.声明数组的同时快速初始化数组"></a>5.声明数组的同时快速初始化数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ArrayTest2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i,j,k <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 声明数组的同时快速初始化数组</span></span><br><span class="line">  balance := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 输出数组元素 */</span></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;balance[%d] = %f\n&quot;</span>, i, balance[i] )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  balance2 := [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">  <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">  <span class="keyword">for</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;balance2[%d] = %f\n&quot;</span>, j, balance2[j] )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line">  balance3 := [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1</span>:<span class="number">2.0</span>,<span class="number">3</span>:<span class="number">7.0</span>&#125;</span><br><span class="line">  <span class="keyword">for</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++ &#123;</span><br><span class="line">          fmt.Printf(<span class="string">&quot;balance3[%d] = %f\n&quot;</span>, k, balance3[k] )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go 语言数组声明有两种方式，1.定长数组，2.不定长度数组&lt;br&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果没有赋值，会有默认值&lt;ul&gt;
&lt;li&gt;int 数组，默认初始化为 0&lt;/li&gt;
&lt;li&gt;string 就是空串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据类型必须相
      
    
    </summary>
    
      <category term="go" scheme="https://liukay.com/categories/go/"/>
    
    
      <category term="数组" scheme="https://liukay.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="go" scheme="https://liukay.com/tags/go/"/>
    
  </entry>
  
</feed>
