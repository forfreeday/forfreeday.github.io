<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思想家</title>
  
  <subtitle>有限的时间，编写先限的可能</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liukay.com/"/>
  <updated>2022-01-21T03:06:16.762Z</updated>
  <id>https://liukay.com/</id>
  
  <author>
    <name>咪雅先森</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo markdown 单眼号变成中文单眼号解决</title>
    <link href="https://liukay.com/posts/8b5e960f.html"/>
    <id>https://liukay.com/posts/8b5e960f.html</id>
    <published>2022-01-21T02:25:46.000Z</published>
    <updated>2022-01-21T03:06:16.762Z</updated>
    
    <content type="html"><![CDATA[<p>最近写文章发现 markdown 中的单眼号被转换成了中文，查了一下发现是hexo的markdown插件的自动转换功能被开启了。<br>输入的是 <code>&#39;</code>（U+0027），被自动转换成了<code>’</code>（U+2019）</p><h2 id="问题插件"><a href="#问题插件" class="headerlink" title="问题插件"></a>问题插件</h2><p>在 <code>node_modules/</code> 目录中查看当前所使用的插件是哪个markdown插件，并修改配置文件<code>_config.yml</code><br>我这边使用到的是：</p><blockquote><p>hexo-renderer-marked</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>如果使用的时以下两个插件，修改方式如下:</p><blockquote><p>hexo-renderer-markdown-it 和 hexo-renderer-markdown-it-plus</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>如果没有这些配置，手动添加上配置就可以起效果。</p><p>参考链接: <a href="https://github.com/theme-next/hexo-theme-next/issues/462">https://github.com/theme-next/hexo-theme-next/issues/462</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近写文章发现 markdown 中的单眼号被转换成了中文，查了一下发现是hexo的markdown插件的自动转换功能被开启了。&lt;br&gt;输入的是 &lt;code&gt;&amp;#39;&lt;/code&gt;（U+0027），被自动转换成了&lt;code&gt;’&lt;/code&gt;（U+2019）&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="hexo" scheme="https://liukay.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://liukay.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>vim-插件06-模糊搜索ctrlpvim</title>
    <link href="https://liukay.com/posts/c5a1c2e0.html"/>
    <id>https://liukay.com/posts/c5a1c2e0.html</id>
    <published>2022-01-21T01:58:56.000Z</published>
    <updated>2022-01-21T02:51:51.536Z</updated>
    
    <content type="html"><![CDATA[<p>模糊搜索工具有很多，但是推荐装一下这个工具，这个工具是一个很好用的工具，而且如果你使用go开发中话，vim-go的跳转了依赖于这个工具，所以推荐装该插件。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>Plug &#39;ctrlpvim/ctrlp.vim&#39;</p></blockquote><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>普通模式下输入</p><blockquote><p>control + p</p></blockquote><p>直接在键盘上输入就可以进行模糊匹配，无需过多的配置。<br>上下选择</p><blockquote><p>control + j / k</p></blockquote><p><img src="/posts/c5a1c2e0/%E4%BD%BF%E7%94%A8.png" alt="使用"></p><p>查看最近使用</p><blockquote><p>:CtrlPMRUFiles</p></blockquote><p>一般使用的时候只需要记住常用的几个操作的，更多的操作，通过提示或者帮助来了解，我一般都用提示功能，输入:CtrlP 然后 table</p><p><img src="/posts/c5a1c2e0/%E6%8F%90%E7%A4%BA.jpeg" alt="提示"></p><h2 id="查看说明"><a href="#查看说明" class="headerlink" title="查看说明"></a>查看说明</h2><p>每个vim的完整功能几乎都可以在说明文档中找到完整说明。</p><blockquote><p>:help ctrlp.txt</p></blockquote><p><img src="/posts/c5a1c2e0/%E5%B8%AE%E5%8A%A9%E8%AF%B4%E6%98%8E1.png" alt="帮助说明1.png"><br><img src="/posts/c5a1c2e0/%E5%B8%AE%E5%8A%A9%E8%AF%B4%E6%98%8E2.png" alt="帮助说明2.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里 vim 已经具备了搜索功能，可以在 vim 的界面中，直接搜索文档，直接打开编辑，不用先进到目录再去打开文档。对于文本编辑来说又进一步的方便了操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;模糊搜索工具有很多，但是推荐装一下这个工具，这个工具是一个很好用的工具，而且如果你使用go开发中话，vim-go的跳转了依赖于这个工具，所以推荐装该插件。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;
      
    
    </summary>
    
      <category term="linux" scheme="https://liukay.com/categories/linux/"/>
    
      <category term="vim" scheme="https://liukay.com/categories/vim/"/>
    
      <category term="vim" scheme="https://liukay.com/categories/linux/vim/"/>
    
      <category term="插件" scheme="https://liukay.com/categories/vim/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="plugin" scheme="https://liukay.com/categories/vim/plugin/"/>
    
    
      <category term="vim" scheme="https://liukay.com/tags/vim/"/>
    
      <category term="插件" scheme="https://liukay.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="IDE" scheme="https://liukay.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>vim IDE进化 05 vim-startify</title>
    <link href="https://liukay.com/posts/a6430b8b.html"/>
    <id>https://liukay.com/posts/a6430b8b.html</id>
    <published>2022-01-15T05:55:20.000Z</published>
    <updated>2022-01-15T07:04:09.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>今天介绍一下vim的别一个非常好用的插件，启动界面插件 vim-startify。<br>这个插件有什么用呢，看效果：</p><p><img src="/posts/a6430b8b/%E5%90%AF%E5%8A%A8%E7%95%8C%E9%9D%A2.png" alt="启动界面"></p><p>中间是最近打开的文件，可能通过数字快数打开文件，界面可以设置找开和关闭。</p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="1-vim插件安装"><a href="#1-vim插件安装" class="headerlink" title="1.vim插件安装"></a>1.vim插件安装</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">&#x27;mhinz/vim-startify&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>配置不是必须项目，当然一般情况下，都会习惯自己一的快捷键。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot;=========================================</span></span><br><span class="line"><span class="comment">&quot; Startify 设置</span></span><br><span class="line"><span class="comment">&quot;=========================================</span></span><br><span class="line"><span class="comment">&quot; 修改其中的内容去获得更好的体验。</span></span><br><span class="line"><span class="comment">&quot;设置书签</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:startify_bookmarks</span>= [</span><br><span class="line">            \ <span class="string">&#x27;~//Workspace/&#x27;</span>,</span><br><span class="line">            \]</span><br><span class="line"><span class="comment">&quot;起始页显示的列表长度</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:startify_files_number</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">&quot;自动加载session</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:startify_session_autoload</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot;过滤列表，支持正则表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:startify_skiplist</span> = [</span><br><span class="line">       \ <span class="string">&#x27;^/tmp&#x27;</span>,</span><br><span class="line">       \ ]</span><br><span class="line"><span class="comment">&quot;自定义Header和Footer</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:startify_custom_header</span> = [</span><br><span class="line">            \ <span class="string">&#x27;+------------------------------+&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;|                              |&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;|    Still waters run deep!    |&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;|                              |&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;+----------------+-------------+&#x27;</span>,</span><br><span class="line">            \]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:startify_custom_footer</span> = [</span><br><span class="line">            \ <span class="string">&#x27;+------------------------------+&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;|     Keep an open mind!       |&#x27;</span>,</span><br><span class="line">            \ <span class="string">&#x27;+----------------+-------------+&#x27;</span>,</span><br><span class="line">            \]</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 自己完成的脚本，判断打开文件是否存在。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">SomeCheck</span><span class="params">()</span></span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;SpecificFile exists&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">autocmd</span> VimEnter * Startify</span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> SomeCheck()</span><br></pre></td></tr></table></figure><p>脚本中的代码部分是解决，在不同位置启动后，找不到文件时会报错<br>function!<br>endfunction 固定一对</p><p>内置函数，% 表示当前路径，也表示当前文件路径<br>expand(&quot;%&quot;)<br>call 执行函数</p><p>可以自行偿试注释掉脚本部份复现问题。</p><p>到这一步vim的IDE进行启动界面就完成了，通过这些插件提高平时写文档的效率是够用的。</p><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/mhinz/vim-startify">https://github.com/mhinz/vim-startify</a></p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><blockquote><p>:h startify<br>:h startify-faq</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;效果&quot;&gt;&lt;a href=&quot;#效果&quot; class=&quot;headerlink&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h2&gt;&lt;p&gt;今天介绍一下vim的别一个非常好用的插件，启动界面插件 vim-startify。&lt;br&gt;这个插件有什么用呢，看效果：&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="linux" scheme="https://liukay.com/categories/linux/"/>
    
      <category term="vim" scheme="https://liukay.com/categories/vim/"/>
    
      <category term="vim" scheme="https://liukay.com/categories/linux/vim/"/>
    
      <category term="插件" scheme="https://liukay.com/categories/vim/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="vim" scheme="https://liukay.com/tags/vim/"/>
    
      <category term="插件" scheme="https://liukay.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="IDE" scheme="https://liukay.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>jvm 使用CMS时FGC每次会跳2次</title>
    <link href="https://liukay.com/posts/1f5573a8.html"/>
    <id>https://liukay.com/posts/1f5573a8.html</id>
    <published>2022-01-12T08:32:42.000Z</published>
    <updated>2022-01-15T07:41:02.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>使用jstat -gc 观察CMS FullGC的时候，发现每次到阈值回收的时候，FGC每次会跳2次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">68096.0 68096.0  0.0   16853.2 545344.0 371165.3 8755648.0  5890791.6  62312.0 59746.5 7076.0 6608.5  43879 1312.752  60      5.206 1317.958</span><br><span class="line">68096.0 68096.0 19377.9  0.0   545344.0 420827.3 8755648.0  5891528.9  62312.0 59746.5 7076.0 6608.5  43880 1312.785  60      5.206 1317.991</span><br><span class="line">68096.0 68096.0  0.0   22147.2 545344.0 295435.0 8755648.0  5891577.4  62312.0 59746.5 7076.0 6608.5  43881 1312.816  60      5.206 1318.022</span><br><span class="line">68096.0 68096.0 21257.5  0.0   545344.0 461020.2 8755648.0  5898299.9  62312.0 59746.5 7076.0 6608.5  43882 1312.850  60      5.206 1318.056</span><br><span class="line">68096.0 68096.0  0.0   13895.9 545344.0 419534.8 8755648.0  5901746.3  62312.0 59746.5 7076.0 6608.5  43885 1312.961  60      5.206 1318.167</span><br><span class="line">68096.0 68096.0  0.0   17542.7 545344.0 63902.2  8755648.0  5906856.1  62312.0 59746.5 7076.0 6608.5  43887 1313.028  60      5.206 1318.234</span><br><span class="line">68096.0 68096.0  0.0   17542.7 545344.0 444878.0 8755648.0  5906856.1  62312.0 59746.5 7076.0 6608.5  43887 1313.028  60      5.206 1318.234</span><br><span class="line">68096.0 68096.0 15241.8  0.0   545344.0 403475.0 8755648.0  5909706.0  62312.0 59746.5 7076.0 6608.5  43890 1313.108  60      5.206 1318.314</span><br><span class="line">68096.0 68096.0 24031.2  0.0   545344.0 52019.0  8755648.0  5916571.4  62312.0 59746.5 7076.0 6608.5  43892 1313.174  60      5.206 1318.380</span><br><span class="line">68096.0 68096.0 17381.4  0.0   545344.0 349457.1 8755648.0  5919082.7  62312.0 59746.5 7076.0 6608.5  43894 1313.232  60      5.206 1318.438</span><br><span class="line">68096.0 68096.0  0.0   20887.7 545344.0 442091.1 8755648.0  5919151.3  62312.0 59746.5 7076.0 6608.5  43895 1313.261  60      5.206 1318.467</span><br></pre></td></tr></table></figure><p>看这个日志，无论多过多久，每次FullGC的次数，必然是两次一起出现，也就是说 FullGC 是连续执行两次？！<br>为什么会这样，其实跟CMS这个回收器的特殊工作机制有关。</p><h2 id="CMS的两次标记"><a href="#CMS的两次标记" class="headerlink" title="CMS的两次标记"></a>CMS的两次标记</h2><p>JVM 的FullGC通常需要先<code>stop-the-world</code>才进行回收。一次<code>stop-the-world</code>的时长就是整个GC回收的时长。<br>CMS的工作流程中，有两个阶段是会触发<code>STW</code>的：<code>initial mark</code>与<code>final remark</code>，这两个阶段都是&quot;stop the world&quot;，不过暂停时间较短</p><p>&quot;GC次数&quot;主要关心的其实是应用暂停次数。<br>要注意的是在CMS里&quot;暂停次数&quot;并不等同于&quot;GC次数&quot;，CMS并发GC的一个周期叫&quot;一次GC&quot;但暂停了两次。</p><p>如果CMS并发GC过程中出现了concurrent mode failure的话那么接下来就会做一次mark-sweep-compact的full GC，这个是完全stop-the-world的。</p><p>图右边是CMS的两次标记</p><p><img src="/posts/1f5573a8/cms%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B.png" alt="cms回收流程"></p><h2 id="GMS的设计特点"><a href="#GMS的设计特点" class="headerlink" title="GMS的设计特点"></a>GMS的设计特点</h2><h3 id="1-低延迟"><a href="#1-低延迟" class="headerlink" title="1.低延迟"></a>1.低延迟</h3><p>为了能达到低延迟的效果，CMS实际是把本来一次FullGC应该消息的时间，能过多次短的GC时间分滩了。就跟吃自助参一样，肚子就那么大，一次性拿一堆吃的可能要吃1个小时。如果一次拿一点点，一次吃10分钟，看上去次数多了，其实吃的量是一样的。</p><h3 id="2-牺牲吞吐量"><a href="#2-牺牲吞吐量" class="headerlink" title="2.牺牲吞吐量"></a>2.牺牲吞吐量</h3><p>这样做的优点是勤拿少取，吃完10分钟可以干别的事，但是每次吃的少。缺点也之这出来了，吞吐量小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;使用jstat -gc 观察CMS FullGC的时候，发现每次到阈值回收的时候，FGC每次会跳2次：&lt;/p&gt;
&lt;figure class=
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="jvm" scheme="https://liukay.com/categories/java/jvm/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="jvm" scheme="https://liukay.com/tags/jvm/"/>
    
      <category term="cms" scheme="https://liukay.com/tags/cms/"/>
    
      <category term="gc" scheme="https://liukay.com/tags/gc/"/>
    
      <category term="FullGC" scheme="https://liukay.com/tags/FullGC/"/>
    
  </entry>
  
  <entry>
    <title>CMS回收器执行流程</title>
    <link href="https://liukay.com/posts/ad216ba6.html"/>
    <id>https://liukay.com/posts/ad216ba6.html</id>
    <published>2022-01-12T08:16:40.000Z</published>
    <updated>2022-01-15T09:12:13.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h2><p>目标：获取最短回收停顿时间为目标的收集器。<br>算法：&quot;标记-清除&quot;算法实现</p><p>CMS是老年代垃圾收集器，在收集过程中可以与用户线程并发操作。<br>它可以与 Serial 收集器 和 Parallel New收集器搭配使用。<br>CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。<br>可以通过JVM启动参数，来开启CMS：</p><blockquote><p>-XX:+UseConcMarkSweepGC</p></blockquote><p>牺牲吞吐量，追求收集速度是什么意思</p><blockquote><p>其实实际使用过程中发现，CMS是将每次收集的时间减少，但是垃圾还是那么多，于是回收的工作方式就变成了跟吃自助餐常听到的一样&quot;勤拿少取&quot;，就是每次回收时间短，也并不完全回收全部的垃圾，通过多次回来处理。</p></blockquote><p><img src="/posts/ad216ba6/%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="执行流程"></p><h3 id="1-初始标记（CMS-initial-mark）"><a href="#1-初始标记（CMS-initial-mark）" class="headerlink" title="1.初始标记（CMS initial mark）"></a>1.初始标记（CMS initial mark）</h3><p>单线程，标记新生代可达老年代的对象。<br>为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。</p><h3 id="2-并发标记（CMS-concurrent-mark）"><a href="#2-并发标记（CMS-concurrent-mark）" class="headerlink" title="2.并发标记（CMS-concurrent-mark）"></a>2.并发标记（CMS-concurrent-mark）</h3><p>在第一个阶段（Initial Mark）被暂停的应用线程将恢复运行。<br>通过遍历第一个阶段（Initial Mark）标记出来的存活对象，继续递归遍历老年代，并标记可直接或间接到达的所有老年代存活对象。</p><p>这个过程可能存在的问题<br>应用线程和GC线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：</p><ol><li>新生代的对象晋升到老年代；</li><li>直接在老年代分配对象；</li><li>老年代对象的引用关系发生变更；<br>对于这些对象，需要重新标记以防止被遗漏。<br>为了提高重新标记的效率，本阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。</li></ol><h3 id="3-并发预清理（CMS-concurrent-preclean）"><a href="#3-并发预清理（CMS-concurrent-preclean）" class="headerlink" title="3.并发预清理（CMS-concurrent-preclean）"></a>3.并发预清理（CMS-concurrent-preclean）</h3><p>这个阶段就是用来处理：前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Dirty的Card<br>将会重新扫描前一个阶段标记的 Dirty 对象，并标记被 Dirty 对象直接或间接引用的对象，然后清除Card标识。<br>也就是让这个标记过后的对象，重新标记为存活。</p><h3 id="3-1-可被终止的预清理（CMS-concurrent-abortable-preclean）"><a href="#3-1-可被终止的预清理（CMS-concurrent-abortable-preclean）" class="headerlink" title="3.1.可被终止的预清理（CMS-concurrent-abortable-preclean）"></a>3.1.可被终止的预清理（CMS-concurrent-abortable-preclean）</h3><p>本阶段尽可能承担更多的并发预处理工作，从而减轻在Final Remark阶段的stop-the-world。<br>主要循环的做两件事：</p><ol><li>处理 From 和 To 区的对象，标记可达的老年代对象；</li><li>和上一个阶段一样，扫描处理Dirty Card中的对象。<br>具体执行多久，取决于许多因素，满足其中一个条件将会中止运行：</li></ol><p>1.执行循环次数达到了阈值；<br>2.执行时间达到了阈值；</p><h3 id="4-重新标记（CMS-Final-Remark）"><a href="#4-重新标记（CMS-Final-Remark）" class="headerlink" title="4.重新标记（CMS Final Remark）"></a>4.重新标记（CMS Final Remark）</h3><p>由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次<br>被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。<br>这一阶段十分重要，因为必须避免收集到仍被引用的对象。</p><h3 id="5-并发清除（CMS-concurrent-sweep）"><a href="#5-并发清除（CMS-concurrent-sweep）" class="headerlink" title="5.并发清除（CMS concurrent sweep）"></a>5.并发清除（CMS concurrent sweep）</h3><p>所有不再被应用的对象将从堆里清除掉。</p><h3 id="6-并发重置-CMS-concurrent-reset"><a href="#6-并发重置-CMS-concurrent-reset" class="headerlink" title="6.并发重置 (CMS-concurrent-reset)"></a>6.并发重置 (CMS-concurrent-reset)</h3><p>状态等待下次CMS的触发<br>做一些收尾的工作，以便下一次GC周期能有一个干净的状态。这是与用户线程同时运行；</p><h2 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h2><p>了解了几个特点之后，可以实际的看看CMS的运行状态。<br>上面说到的CMS的几个状态，我们从gc运行日志中去查看CMS的运行状态。<br>日志中以 CMS 开头的都是CMS各个执行阶段。<br>这里最需要注意的是：</p><ol><li>CMS Initial Mark</li><li>CMS-remark<br>这两个阶段分别会暂停应用，也是会让应用程序短暂的暂停也就是<code>STW</code>。</li></ol><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2022-01-11T05:48:34.975+0800: 1774622.038: [GC (Allocation Failure) 2022-01-11T05:48:34.975+0800: 1774622.038: [ParNew: 2570680K-&gt;58383K(2831168K), 0.0411295 secs] 8357286K-&gt;5848239K(9122624K), 0.0414169 secs] [Times: user=0.2</span><br><span class="line">      7 sys=0.04, real=0.04 secs]</span><br><span class="line">2022-01-11T05:48:35.030+0800: 1774622.093: [GC (CMS Initial Mark) [1 CMS-initial-mark: 5789855K(6291456K)] 5873624K(9122624K), 0.0093763 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br><span class="line">2022-01-11T05:48:35.039+0800: 1774622.103: [CMS-concurrent-mark-start]</span><br><span class="line">2022-01-11T05:48:38.826+0800: 1774625.889: [CMS-concurrent-mark: 3.785/3.786 secs] [Times: user=8.65 sys=0.18, real=3.79 secs]</span><br><span class="line">2022-01-11T05:48:38.826+0800: 1774625.889: [CMS-concurrent-preclean-start]</span><br><span class="line">2022-01-11T05:48:39.400+0800: 1774626.463: [CMS-concurrent-preclean: 0.572/0.574 secs] [Times: user=0.64 sys=0.14, real=0.57 secs]</span><br><span class="line">2022-01-11T05:48:39.400+0800: 1774626.463: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">  CMS: abort preclean due to time 2022-01-11T05:48:44.575+0800: 1774631.638: [CMS-concurrent-abortable-preclean: 5.169/5.175 secs] [Times: user=8.49 sys=0.52, real=5.18 secs]</span><br><span class="line">2022-01-11T05:48:44.576+0800: 1774631.640: [GC (CMS Final Remark) [YG occupancy: 1078481 K (2831168 K)]2022-01-11T05:48:44.577+0800: 1774631.640: [Rescan (parallel) , 0.1331046 secs]2022-01-11T05:48:44.710+0800: 1774631.773: [</span><br><span class="line">      weak refs processing, 0.1347760 secs]2022-01-11T05:48:44.844+0800: 1774631.908: [class unloading, 0.0376418 secs]2022-01-11T05:48:44.882+0800: 1774631.945: [scrub symbol table, 0.0092684 secs]2022-01-11T05:48:44.891+0800: 1774</span><br><span class="line">      631.955: [scrub string table, 0.0012191 secs][1 CMS-remark: 5789855K(6291456K)] 6868337K(9122624K), 0.3817515 secs] [Times: user=1.12 sys=0.18, real=0.38 secs]</span><br><span class="line">2022-01-11T05:48:44.959+0800: 1774632.022: [CMS-concurrent-sweep-start]</span><br><span class="line">2022-01-11T05:48:50.297+0800: 1774637.361: [CMS-concurrent-sweep: 5.333/5.339 secs] [Times: user=10.01 sys=1.01, real=5.34 secs]</span><br><span class="line">2022-01-11T05:48:50.298+0800: 1774637.361: [CMS-concurrent-reset-start]</span><br><span class="line">2022-01-11T05:48:50.312+0800: 1774637.375: [CMS-concurrent-reset: 0.014/0.014 secs] [Times: user=0.03 sys=0.01, real=0.02 secs]</span><br><span class="line">2022-01-11T05:48:57.315+0800: 1774644.378: [GC (Allocation Failure) 2022-01-11T05:48:57.315+0800: 1774644.378: [ParNew: 2574991K-&gt;57569K(2831168K), 0.1454595 secs] 4314737K-&gt;1800606K(9122624K), 0.1457231 secs] [Times: user=0.9</span><br><span class="line">      6 sys=0.17, real=0.14 secs]</span><br></pre></td></tr></table></figure><h2 id="CMS缺点"><a href="#CMS缺点" class="headerlink" title="CMS缺点"></a>CMS缺点</h2><p>这个不得不吐槽一下，这几个问题，还全让我碰到了。</p><ol><li>CMS收集器对CPU资源非常敏感</li><li>CMS收集器无法处理浮动垃圾</li><li>浮动垃圾</li></ol><h3 id="CMS收集器对CPU资源非常敏感"><a href="#CMS收集器对CPU资源非常敏感" class="headerlink" title="CMS收集器对CPU资源非常敏感"></a>CMS收集器对CPU资源非常敏感</h3><p>在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。<br>这个的实际产生的问题就是，用户线程在处理业务时，由于停顿导致的停顿时间，刚好使业务线程处理时间超时，导致业务处理超时失败。</p><h3 id="CMS收集器无法处理浮动垃圾"><a href="#CMS收集器无法处理浮动垃圾" class="headerlink" title="CMS收集器无法处理浮动垃圾"></a>CMS收集器无法处理浮动垃圾</h3><p>可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。<br>这个问题，是在检查服务性问题的时候发现的，频率一天几十次，最终调优解决。</p><h3 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h3><p>由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。<br>这个就是追求短的低停顿的代价，实际的问题是，内存空间会有大量的对象占用，如果是创建对象比较频繁的应用，就不太友好了，这样也会加大回收的频率。</p><p>CMS是一款“标记--清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CMS 是一款低可以实现短停顿的回收器，在停顿时间上确实是比较优秀的，一般来说没有最好的应用，只有最合适的应用，在选择GC时，根据自身的需求进行选择并对细节做过调整，来达到最优的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CMS（Concurrent-Mark-Sweep）&quot;&gt;&lt;a href=&quot;#CMS（Concurrent-Mark-Sweep）&quot; class=&quot;headerlink&quot; title=&quot;CMS（Concurrent Mark Sweep）&quot;&gt;&lt;/a&gt;CMS（Conc
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="jvm" scheme="https://liukay.com/categories/java/jvm/"/>
    
      <category term="cms" scheme="https://liukay.com/categories/java/jvm/cms/"/>
    
    
      <category term="jvm" scheme="https://liukay.com/tags/jvm/"/>
    
      <category term="cms" scheme="https://liukay.com/tags/cms/"/>
    
      <category term="gc" scheme="https://liukay.com/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>Tendermint-通过goland初始化和启动</title>
    <link href="https://liukay.com/posts/c43a12b2.html"/>
    <id>https://liukay.com/posts/c43a12b2.html</id>
    <published>2022-01-11T07:17:08.000Z</published>
    <updated>2022-01-21T02:03:49.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对 Tendermint 有了一个的了解之后，我们需要对 Tendermint 进行开发和操作，该如何运行这个项目。<br>Tendermint 使用的是 cobra 这个命令行框架，需要对 cobra 有一定的了解。</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><h3 id="配置IDEA"><a href="#配置IDEA" class="headerlink" title="配置IDEA"></a>配置IDEA</h3><p>我使用 goland开发调试，先将项目 clone 到本地，配置好go mod。</p><p><img src="/posts/c43a12b2/gomod.png" alt="goland配置gomod"></p><h3 id="安装内置命令-tendermint"><a href="#安装内置命令-tendermint" class="headerlink" title="安装内置命令: tendermint"></a>安装内置命令: tendermint</h3><p>git clone 之后，找开项目，Tendermint 是go项目，内置的一些功能需要先进行编译。</p><blockquote><p>make install</p></blockquote><p>这一步的操作是为了将内置命令: tendermint，安装到当前系统中。</p><p>验证命令正确安装，执行一下：tendermint</p><!-- ![tendermint命令](tendermint命令.png) --><p><img src="/posts/c43a12b2/tendermint%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E9%AA%8C%E8%AF%81.png" alt="tendermint命令安装验证"></p><p>这个图中展示了 tendermint 支持的各种命令，对节点运行来说，需要关注的是</p><ol><li>init</li><li>start</li></ol><h3 id="初始化-validator-节点"><a href="#初始化-validator-节点" class="headerlink" title="初始化 validator 节点"></a>初始化 validator 节点</h3><p>tendermint 可以初始化三种节点类型</p><ol><li>FullNode</li><li>seed</li><li>validator</li></ol><p><img src="/posts/c43a12b2/%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B.jpeg" alt="初始化节点类型"></p><p>这三种类型是常见的三种节点类型，FullNode 用于区块广播、查询等；seed 是种子节点，用来做节点发现；validator 是验证人节点，也就是产块节点(选举出Propose产块)。节点类型初始化以后，可以通过配置文件进行修改节点类型。</p><blockquote><p>tendermint init [validator|full|seed]</p></blockquote><p>我们初始化为 validator 节点</p><p><img src="/posts/c43a12b2/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BAvalidator%E8%8A%82%E7%82%B9.png" alt="初始化为validator节点"></p><p>生成了一套配置文件：</p><ol><li>validator 的key文件</li><li>priv_validator的状态文件</li><li>node_key 节点私钥</li><li>genesis 配置文件，实际就是链相关的初始化配置</li></ol><blockquote><p>validator keyFile=/Users/liukai/.tendermint/config/priv_validator_key.json<br>module=main stateFile=/Users/liukai/.tendermint/data/priv_validator_state.json<br>node key module=main path=/Users/liukai/.tendermint/config/node_key.json<br>genesis file module=main path=/Users/liukai/.tendermint/config/genesis.json<br>mode=validator module=main</p></blockquote><p>到这里，初始化工作就差不多完成了，可以直接启动，默认情况下，tendermint 服务会去连接一个 ABCI 的应用，如果没有 tendermint 启动后一直偿试去连接一个应用，这里我使用官方提供的内置<code>KV存储</code>应用，在启动时指定连接该应用。</p><p>完整命令</p><blockquote><p>tendermint node --proxy-app=kvstore</p></blockquote><p><img src="/posts/c43a12b2/%E8%BF%9E%E6%8E%A5%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8.png" alt="连接应用启动"></p><p>看一下这个日志，能从日志中看出什么来，下面的日志是共识模块打印出来的日志。</p><ol><li>Timed out dur: 执行周期，表示本次处理之间经过了多久时间</li><li>received proposal: 这里validator只有它自己一个，所有其实这个 proposal 就是当前节点自己</li><li>finalizing commit of block: 共识了commit阶段打印的日志，来自<code>state.go</code>的finalizeCommit这个方法，往上回溯是共识流程中的<code>commit阶段</code>中最后打印的日志，从这里分析出共识的代码。</li></ol><p>到这里，证明这个项目的代码是能正常初始化并启动的，我们开发的话，使用IDE来启动项目，方便一些。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">2022-01-15T18:09:12+08:00 INFO started node module=main node=Node</span><br><span class="line">2022-01-15T18:09:13+08:00 INFO Timed out dur=955.244 height=1 module=consensus round=0 step=1</span><br><span class="line">2022-01-15T18:09:13+08:00 INFO received proposal module=consensus proposal=&#123;&quot;Type&quot;:32,&quot;block_id&quot;:&#123;&quot;hash&quot;:&quot;602C388864F8CBF5F799ED7AAEE8A71F206F200719187CF6B918101F748F8438&quot;,&quot;parts&quot;:&#123;&quot;hash&quot;:&quot;3DC5C676DC9DAFC0EFB9EA5705D1FEAB57F4B89663FD57D8CA01885931C83C73&quot;,&quot;total&quot;:1&#125;&#125;,&quot;height&quot;:1,&quot;pol_round&quot;:-1,&quot;round&quot;:0,&quot;signature&quot;:&quot;UKRIZf+EKc73YFoDvvvet8pswiR/JWP7WT0ms+hmpqo/NgXX1Z+iLWtTRiryjNNoeTZOFESnyauzKa6z4HGiCQ==&quot;,&quot;timestamp&quot;:&quot;2022-01-15T10:09:13.046562Z&quot;&#125;</span><br><span class="line">2022-01-15T18:09:13+08:00 INFO received complete proposal block hash=602C388864F8CBF5F799ED7AAEE8A71F206F200719187CF6B918101F748F8438 height=1 module=consensus</span><br><span class="line">2022-01-15T18:09:13+08:00 INFO finalizing commit of block hash=602C388864F8CBF5F799ED7AAEE8A71F206F200719187CF6B918101F748F8438 height=1 module=consensus num_txs=0 root=</span><br><span class="line">2022-01-15T18:09:13+08:00 INFO executed block height=1 module=state num_invalid_txs=0 num_valid_txs=0</span><br><span class="line">2022-01-15T18:09:13+08:00 INFO committed state app_hash=0000000000000000 height=1 module=state num_txs=0</span><br><span class="line">2022-01-15T18:09:14+08:00 INFO Timed out dur=903.604 height=2 module=consensus round=0 step=1</span><br><span class="line">2022-01-15T18:09:14+08:00 INFO received proposal module=consensus proposal=&#123;&quot;Type&quot;:32,&quot;block_id&quot;:&#123;&quot;hash&quot;:&quot;5677777BE540DADC8D5C29238FCE04D60B8F37F694C3E2455E7C84211192BCD6&quot;,&quot;parts&quot;:&#123;&quot;hash&quot;:&quot;F14D63CF02B3E24873FB882DD14BB24451AC7C3B727C7E2B701187C4C1E0FB7D&quot;,&quot;total&quot;:1&#125;&#125;,&quot;height&quot;:2,&quot;pol_round&quot;:-1,&quot;round&quot;:0,&quot;signature&quot;:&quot;4dxc7YP4kj3kYxcAA+gVd45gzPm7OR+jjnEO/yysqjtPpNZShz/xNwQ1lGr/ez/VbQ6VYpyiWpfEkZ0yZzQvAw==&quot;,&quot;timestamp&quot;:&quot;2022-01-15T10:09:14.182702Z&quot;&#125;</span><br><span class="line">2022-01-15T18:09:14+08:00 INFO received complete proposal block hash=5677777BE540DADC8D5C29238FCE04D60B8F37F694C3E2455E7C84211192BCD6 height=2 module=consensus</span><br><span class="line">2022-01-15T18:09:14+08:00 INFO finalizing commit of block hash=5677777BE540DADC8D5C29238FCE04D60B8F37F694C3E2455E7C84211192BCD6 height=2 module=consensus num_txs=0 root=0000000000000000</span><br><span class="line">2022-01-15T18:09:14+08:00 INFO executed block height=2 module=state num_invalid_txs=0 num_valid_txs=0</span><br><span class="line">2022-01-15T18:09:14+08:00 INFO committed state app_hash=0000000000000000 height=2 module=state num_txs=0</span><br><span class="line">2022-01-15T18:09:15+08:00 INFO Timed out dur=916.435 height=3 module=consensus round=0 step=1</span><br><span class="line">2022-01-15T18:09:15+08:00 INFO received proposal module=consensus proposal=&#123;&quot;Type&quot;:32,&quot;block_id&quot;:&#123;&quot;hash&quot;:&quot;D0D03A1D4F18E4437BE7DC0A5A5CAEEC4AC60844812925FF49E5D100A1734EA7&quot;,&quot;parts&quot;:&#123;&quot;hash&quot;:&quot;162DFDBEAD99485E176D568C492B166BCB171050FEB687B6126F555920B49E47&quot;,&quot;total&quot;:1&#125;&#125;,&quot;height&quot;:3,&quot;pol_round&quot;:-1,&quot;round&quot;:0,&quot;signature&quot;:&quot;SISLt3TOCH1kMyMvdwzxUgM1Pt+iXcB/7erNo1Hoz/etJ/bES4+yHT/NLpUMxR4/6yuItCl5tLCnn7lAkiOrDA==&quot;,&quot;timestamp&quot;:&quot;2022-01-15T10:09:15.317317Z&quot;&#125;</span><br><span class="line">2022-01-15T18:09:15+08:00 INFO received complete proposal block hash=D0D03A1D4F18E4437BE7DC0A5A5CAEEC4AC60844812925FF49E5D100A1734EA7 height=3 module=consensus</span><br><span class="line">2022-01-15T18:09:15+08:00 INFO finalizing commit of block hash=D0D03A1D4F18E4437BE7DC0A5A5CAEEC4AC60844812925FF49E5D100A1734EA7 height=3 module=consensus num_txs=0 root=0000000000000000</span><br><span class="line">2022-01-15T18:09:15+08:00 INFO executed block height=3 module=state num_invalid_txs=0 num_valid_txs=0</span><br><span class="line">2022-01-15T18:09:15+08:00 INFO committed state app_hash=0000000000000000 height=3 module=state num_txs=0</span><br><span class="line">2022-01-15T18:09:16+08:00 INFO Timed out dur=913.594 height=4 module=consensus round=0 step=1</span><br><span class="line">2022-01-15T18:09:16+08:00 INFO received proposal module=consensus proposal=&#123;&quot;Type&quot;:32,&quot;block_id&quot;:&#123;&quot;hash&quot;:&quot;CBD114A414D57D92273EDCAEE541088B745606B989891B8B486A62846F451146&quot;,&quot;parts&quot;:&#123;&quot;hash&quot;:&quot;752DE3634222AC0150B8A2187D2559149B85599693A52F0BB3539B3C4E3D1573&quot;,&quot;total&quot;:1&#125;&#125;,&quot;height&quot;:4,&quot;pol_round&quot;:-1,&quot;round&quot;:0,&quot;signature&quot;:&quot;kIzWuc2D/0NmQG2n6dIZmD0RFIwSF9Yra9+bPgkpZCS2oM5B1v6yT9HKj71r0lExaVbvNQ66TRKmaSftBUCKBg==&quot;,&quot;timestamp&quot;:&quot;2022-01-15T10:09:16.429801Z&quot;&#125;</span><br><span class="line">2022-01-15T18:09:16+08:00 INFO received complete proposal block hash=CBD114A414D57D92273EDCAEE541088B745606B989891B8B486A62846F451146 height=4 module=consensus</span><br><span class="line">2022-01-15T18:09:16+08:00 INFO finalizing commit of block hash=CBD114A414D57D92273EDCAEE541088B745606B989891B8B486A62846F451146 height=4 module=consensus num_txs=0 root=0000000000000000</span><br><span class="line">2022-01-15T18:09:16+08:00 INFO executed block height=4 module=state num_invalid_txs=0 num_valid_txs=0</span><br><span class="line">2022-01-15T18:09:16+08:00 INFO committed state app_hash=0000000000000000 height=4 module=state num_txs=0</span><br></pre></td></tr></table></figure><h2 id="goland中配置"><a href="#goland中配置" class="headerlink" title="goland中配置"></a>goland中配置</h2><p>添加启动参数: node --proxy-app=kvstore</p><p><img src="/posts/c43a12b2/goland%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE.png" alt="goland启动参数配置"></p><p>tendermint的启动依赖于<code>cobra</code>这个命仅行框架，通过源码可以看到，启动命令start的别名就是 node、run，所以使用 start 和 node 是等价就是，node只是start的一个别名。</p><p><img src="/posts/c43a12b2/start%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81.png" alt="start启动源码"></p><h2 id="通过debug启动"><a href="#通过debug启动" class="headerlink" title="通过debug启动"></a>通过debug启动</h2><p>到这里，通过debug就可以正常进行开发调试了。</p><p><img src="/posts/c43a12b2/debug%E5%90%AF%E5%8A%A8.png" alt="debug启动"></p><h2 id="vim-go-启动项目"><a href="#vim-go-启动项目" class="headerlink" title="vim-go 启动项目"></a>vim-go 启动项目</h2><p>有时候，习惯于在vim-go进行开发，我很多时间是用vim-go在开发，这里介绍一个使用vim-go进行启动和调试。</p><h3 id="vim-go启动"><a href="#vim-go启动" class="headerlink" title="vim-go启动"></a>vim-go启动</h3><p>tendermint 的启动服务命令在：<code>cmd/tendermint</code> 目录下。<br>在命令模式下输入:</p><blockquote><p>:GoRun main.go node --proxy-app=kvstore</p></blockquote><p><img src="/posts/c43a12b2/vim-go%E5%90%AF%E5%8A%A8.png" alt="vim-go启动"><br>启动输出<br><img src="/posts/c43a12b2/%E5%90%AF%E5%8A%A8%E8%BE%93%E5%87%BA.png" alt="启动输出.png"></p><h3 id="vim-go-debug启动"><a href="#vim-go-debug启动" class="headerlink" title="vim-go debug启动"></a>vim-go debug启动</h3><blockquote><p>:GoDebug main.go node --proxy-app=kvstore</p></blockquote><p><img src="/posts/c43a12b2/vim-godebug%E5%90%AF%E5%8A%A8tendermint.png" alt="vim-godebug启动tendermint"></p><h3 id="查看节点状态"><a href="#查看节点状态" class="headerlink" title="查看节点状态"></a>查看节点状态</h3><blockquote><p>curl -s localhost:26657/status</p></blockquote><p><img src="/posts/c43a12b2/%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81.png" alt="查看节点状态"></p><p>OK，基本上 tendermint 项目的启动方式都介绍完毕，使用基于tendermint 开发的小伙伴应该能解决一些小问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;对 Tendermint 有了一个的了解之后，我们需要对 Tendermint 进行开发和操作，该如何运行这个项目。&lt;br&gt;Tendermi
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="tendermint" scheme="https://liukay.com/categories/blockchain/tendermint/"/>
    
      <category term="tendermint" scheme="https://liukay.com/categories/tendermint/"/>
    
      <category term="Tendermint" scheme="https://liukay.com/categories/Tendermint/"/>
    
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="区块链" scheme="https://liukay.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="tendermint" scheme="https://liukay.com/tags/tendermint/"/>
    
      <category term="初始化" scheme="https://liukay.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>随笔---十步学习法</title>
    <link href="https://liukay.com/posts/997e4410.html"/>
    <id>https://liukay.com/posts/997e4410.html</id>
    <published>2022-01-03T07:59:49.000Z</published>
    <updated>2022-01-03T08:10:38.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在IT行业，学习能力是一种必须的素养</p></blockquote><p>在开发行业中，技术的迭代是非常之快，如何保证自身的技术随之迭代更新，就需在强大的学习能力，我在多年的摸索中总结出自己的一套学习方法，中间参考过各种不同的学习方法，其中的十步学习法是最接近我自身总结的方法。分享出来让更多小伙伴能够从中吸收优秀的方法应用到实际学习中。</p><h2 id="第一步到第六步：概览全局，设定目标，搜寻资源，创建计划"><a href="#第一步到第六步：概览全局，设定目标，搜寻资源，创建计划" class="headerlink" title="第一步到第六步：概览全局，设定目标，搜寻资源，创建计划"></a>第一步到第六步：概览全局，设定目标，搜寻资源，创建计划</h2><p>集中精力完成足够的前期调研，确保自己明确知道学习的内容，以及如何确定自己达成目标，挑选最好的资源来帮助自己实现目标，制定学习计划。</p><h3 id="第一步：了解全局"><a href="#第一步：了解全局" class="headerlink" title="第一步：了解全局"></a>第一步：了解全局</h3><p>首先对需要学习的课题进行一些基础性研究，对该主题有一个全局性的了解。</p><h3 id="第二步：确定范围"><a href="#第二步：确定范围" class="headerlink" title="第二步：确定范围"></a>第二步：确定范围</h3><p>根据自身的需求，决定学习的重点和学习的范围，在此阶段容易犯的一个错误就是：试图解决太大的问题而让自己陷入困境中。结合从第一步中获得的信息，明确自己的学习范围，尽可能的保持专注；同时也需要阐述自己的学习理由来帮助自己界定学习的范围。学习的范围务必大小适当，既能符合学习理由，有能符合自己的时间限制。</p><h3 id="第三步：定义目标"><a href="#第三步：定义目标" class="headerlink" title="第三步：定义目标"></a>第三步：定义目标</h3><p>确定自己的学习目标，明确学习完成后应该达成的效果，根据简明清晰的目标，勾勒出勤奋学习后成功的图景。成功的标准应该是具体的，无二义性的。</p><h3 id="第四步：寻找资源"><a href="#第四步：寻找资源" class="headerlink" title="第四步：寻找资源"></a>第四步：寻找资源</h3><p>尽可能的尝试多种渠道和方式获取尽可能多的和主题相关资源，该阶段无需考虑这些资源的质量。</p><h3 id="第五步：创建学习计划"><a href="#第五步：创建学习计划" class="headerlink" title="第五步：创建学习计划"></a>第五步：创建学习计划</h3><p>需要在最短的时间内找到正确的学习路径，并找到和到达路径中重要的地标。打造自己的学习计划，一个好的方法是观察别人是如何教授你感兴趣的主题的。通览收到到的全部资源，就可以对自己需要那些内容以及如何组织这些内容有更清晰的认识。</p><h3 id="第六步：筛选资源"><a href="#第六步：筛选资源" class="headerlink" title="第六步：筛选资源"></a>第六步：筛选资源</h3><p>对找到的资源进行筛选，挑选出最有价值的几项来帮助你实现自己的目标。</p><hr><h2 id="第七步到第十步：循环往复"><a href="#第七步到第十步：循环往复" class="headerlink" title="第七步到第十步：循环往复"></a>第七步到第十步：循环往复</h2><p>通过 “学习——实践——掌握——教授”(LDLT)的方式来真正领悟知识。通过掌握恰到好处的基础知识开始，通过动手实践来学习，同时通过自我探索收集问题。之后，掌握了足够多的有用知识。最后，将自己所学教给他人，以此来弥补自己在学习过程中的不足，同时通过深入思考巩固知识。</p><h3 id="第七步：开始学习，浅尝辄止"><a href="#第七步：开始学习，浅尝辄止" class="headerlink" title="第七步：开始学习，浅尝辄止"></a>第七步：开始学习，浅尝辄止</h3><p>专注与掌握自己所需，能在下一步动手操作的最小量的知识。</p><h3 id="第八步：动手操作，边玩边学"><a href="#第八步：动手操作，边玩边学" class="headerlink" title="第八步：动手操作，边玩边学"></a>第八步：动手操作，边玩边学</h3><p>在掌握操作动手最小量的知识的情况下亲自操作和亲身体验。通过在探索和实践过程中，会产生的各种问题。这些问题会引导着你走向真正重要的方向。当回头寻找问题的答案时，不只是这些问题迎刃而解，而且你记得的东西比你学习的东西要多得多，因为你所学到的都是对你很重要的东西。</p><p>把那些暂时还没有答案的问题记录下来，在下一步中就会有机会找出这些问题的答案。</p><h3 id="第九步：全面掌握，学以致用"><a href="#第九步：全面掌握，学以致用" class="headerlink" title="第九步：全面掌握，学以致用"></a>第九步：全面掌握，学以致用</h3><p>好奇心是学习特别是自学的重要组成部分。为了有效利用自己选择的资料，为了上一步生产的问题寻求答案（带着问题学习）。不用担心回头再去操作，付出更多，因为这不仅能够让你找到问题的答案，也能让你学习新东西。给自己足够多的时间去深入理解自己的主题，你可以阅读，可以实验，可以观察，也可以操作。试着把自己正在学习的内容与最终目标关联起来。</p><h3 id="第十步：乐为人师，融会贯通"><a href="#第十步：乐为人师，融会贯通" class="headerlink" title="第十步：乐为人师，融会贯通"></a>第十步：乐为人师，融会贯通</h3><p>要想深入掌握一门学问，并且融会贯通，那么必须要做到能够教授给别人，在这一过程中，你要切实刨析并理解自己所学的知识，将其内化到自己的思想；同时，也要用能够让他人理解的方式精心组织这些信息。在这个过程中，你会发现很多自以为明白的知识点，其实并没有你想象的那么透彻。这一过程会将那些以前自己没太明白的东西联系起来，并简化到自己的大脑中已有的信息，将它们浓缩并经常复习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在IT行业，学习能力是一种必须的素养&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开发行业中，技术的迭代是非常之快，如何保证自身的技术随之迭代更新，就需在强大的学习能力，我在多年的摸索中总结出自己的一套学习方法，中间参考过各种不同的学习方法，其中的
      
    
    </summary>
    
      <category term="随笔" scheme="https://liukay.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="学习方法" scheme="https://liukay.com/categories/%E9%9A%8F%E7%AC%94/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="随笔" scheme="https://liukay.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="学习方法" scheme="https://liukay.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码01 开始阅读</title>
    <link href="https://liukay.com/posts/8cad0e75.html"/>
    <id>https://liukay.com/posts/8cad0e75.html</id>
    <published>2021-12-12T10:05:57.000Z</published>
    <updated>2022-01-28T03:13:26.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在开始源码阅读之前，一定要使用过这个产品，了解这个产品的功能、特点。</p></blockquote><p>在开始源码阅读之前，需要先明白几个事</p><ol><li>是否足够了解</li><li>要阅读到什么程序</li><li>如何开始、从哪里开始</li></ol><h2 id="开始前"><a href="#开始前" class="headerlink" title="开始前"></a>开始前</h2><p>最好是带着问题去阅读源码，不纠结于小细节。<br>我一般读源码就是碰到问题后，带着问题去看，效果更好，不要想着假大空，把源码当小说一样看。<br>单个问题解决后，再向外延伸，就可以把一些点串起来。<br>最后，需要反复看一些重点部份，消失对源码的陌生感之后就会能看进去。<br>熟悉之后就会一种想要了解更多的感觉就会一直往下看，这个就是自动驱动的动力。</p><p>如果看不下去，不要责怪自己懒，人对看不见短期收益的事提不起兴趣这才是正常的一个人，趋利避害是正常的。<br>看不下去，该干嘛干，强迫自己看效果很差。不要骗自己，假装努力是在浪费时间，干IT的都很忙，看不去就看改改bug。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ol><li>对说某个功能，在看之前，可以有自己的推测，想像后续的流程是如何执行的。</li><li>切一个 read_code 分支用来作注释，写上自己的见解，也方便以后再回到这块代码时能快速理解。</li><li>找到真实阅读源码的动力，如：<ul><li>准备跳槽、面试</li><li>想了解原理</li><li>解决项目中的问题</li><li>装逼</li></ul></li><li>跑测试用例，好的开源软件有非常详细的测试用例，可以验证到每一个细节，跑测试用例就可以让人学到不东西。</li><li>阅读后的输出整理，这个不用多说，学习就是输入 + 输出。</li><li>尽量找机会跟同事、同行讨论你看过的源码。<ul><li>如果你看过了，就让你装到了。</li><li>如果你没看过不了解，别人帮你查缺补漏</li></ul></li></ol><h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><h3 id="从哪里开始"><a href="#从哪里开始" class="headerlink" title="从哪里开始"></a>从哪里开始</h3><p>Spring 模块之么多、项目这么大，到哪里开始合适？<br>如果你是想解决问题，直接定位需要阅读的部份；<br>如果你是想深入了解，那有两种方式：</p><ol><li>从关键最重要的几个概念开始，然后延伸</li><li>了解了整个框架的脉络后，从最基础的部分往上看</li></ol><p>另外，看代码不是看小说，不是要一字一句的陷入到细节，切记。当然如果你就是喜欢这样。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>这个是我比较荐的一个方法，看完一遍之后，通过测试用例可以跟着代码走一遍，调细节。</p><h2 id="阅读安排"><a href="#阅读安排" class="headerlink" title="阅读安排"></a>阅读安排</h2><p>打开 Spring 项目，先来罗列一下整个项目。这个可太多了，分一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">spring-aop</span><br><span class="line">spring-aspects</span><br><span class="line">spring-beans</span><br><span class="line">spring-context</span><br><span class="line">spring-context-indexer</span><br><span class="line">spring-context-support</span><br><span class="line">spring-core</span><br><span class="line">spring-expression</span><br><span class="line">spring-instrument</span><br><span class="line">spring-jcl</span><br><span class="line">spring-jdbc</span><br><span class="line">spring-jms</span><br><span class="line">spring-messaging</span><br><span class="line">spring-orm</span><br><span class="line">spring-oxm</span><br><span class="line">spring-r2dbc</span><br><span class="line">spring-test</span><br><span class="line">spring-tx</span><br><span class="line">spring-web</span><br><span class="line">spring-webflux</span><br><span class="line">spring-webmvc</span><br><span class="line">spring-websocket</span><br></pre></td></tr></table></figure><h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><blockquote><p>spring-core<br>spring-beans<br>spring-context<br>spring-context-support<br>spring-expression</p></blockquote><h3 id="切面编程"><a href="#切面编程" class="headerlink" title="切面编程"></a>切面编程</h3><blockquote><p>spring-aop<br>spring-aspects</p></blockquote><h3 id="代理模块"><a href="#代理模块" class="headerlink" title="代理模块"></a>代理模块</h3><blockquote><p>spring-instrument</p></blockquote><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><blockquote><p>spring-web<br>spring-webflux<br>spring-webmvc<br>spring-websocket</p></blockquote><p>从最基础的核心模块开始学习，了解最基本的原理，中间会遇到各种其它的基础知识和技术，就可以顺便拓展一下技能树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在开始源码阅读之前，一定要使用过这个产品，了解这个产品的功能、特点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开始源码阅读之前，需要先明白几个事&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是否足够了解&lt;/li&gt;
&lt;li&gt;要阅读到什么程序&lt;/li&gt;
&lt;li&gt;如何
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/java/spring/"/>
    
      <category term="源码阅读" scheme="https://liukay.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="spring" scheme="https://liukay.com/tags/spring/"/>
    
      <category term="源码分析" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="源码" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码阅读" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>shutdownHook 死锁解决</title>
    <link href="https://liukay.com/posts/247689d4.html"/>
    <id>https://liukay.com/posts/247689d4.html</id>
    <published>2021-12-02T12:15:08.000Z</published>
    <updated>2022-01-17T09:04:57.537Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到一个问题，通过脚本执行<code>kill -15</code>后，程序并没有退出，进程一直都在，最后被退出脚本的通过<code>kill -9</code>，杀死。导致数据完整性被破坏，程序再重启后不可用。通过排查认后发现是在执行<code>shutdownHook</code>时死锁程序死锁。</p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>导致问题的代码，通过定位发现，程序在退出时卡住，线上代码敏感，写一个demo来复现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Locking&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Locked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Exiting&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>Exiting<br>Locking</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>排查原因<br>分析一下 addShutdownHook 这个方法是怎么执行的，重点是 ApplicationShutdownHooks，每一个 shutdownHook 都使用一个Thread包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addShutdownHook</span><span class="params">(Thread hook)</span> </span>&#123;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点：hooks，每个 hook线程put到hooks中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread hook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hooks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line"></span><br><span class="line">    hooks.put(hook, hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加后谁来处理shutdown这个操作，是 Shutdown.add 这里起了一个线程，处理所以主要的逻辑在 runHooks</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Shutdown.add(<span class="number">1</span> <span class="comment">/* shutdown hook invocation order */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* not registered if shutdown in progress */</span>,</span><br><span class="line">            <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    runHooks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        hooks = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        <span class="comment">// application shutdown hooks cannot be added if</span></span><br><span class="line">        <span class="comment">// shutdown is in progress.</span></span><br><span class="line">        hooks = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中 hook.start(); 调用执行 hook的方法，之后调用 hook.join释放执行权。<br>问题就出在 hook.join上，程序执行到这里之后，卡住死锁，出不去了。<br>为什么，因为 join 实际就是 wait(0)，一旦当前线程调用wait(0)，就相当于释放执行权，等待其实线程notify()才能继续执行。<br>但是main线程调用System.exit(0)后，synchronized 当前线程为 main，hook.join拿不到被main未释放的锁，所以卡住</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runHooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                hook.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过工具排查，可以清楚的看到，Thread-0 即shutdown线程去引用已经被main线程持有的锁对象，而导至被 BLOCKED 住</p><p><img src="/posts/247689d4/%E6%AD%BB%E9%94%81.png" alt="死锁"></p><p>再看线程状态</p><p><img src="/posts/247689d4/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p><p>通过代码线程堆栈来确认就是这个原因</p><ol><li>main 方法是：WAIT 状态</li><li>Thread-0是：RUNNING 状态，但是进入synchronized之后就会BLOCKED住</li></ol><p>这里就对应上图的两个线程的状态</p><p><img src="/posts/247689d4/%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88.png" alt="线程堆栈"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>即然已经知道原因了，那就好办：</p><ol><li>移除 shutdownHook 中不必要的加锁，shutdown 场景中很不需要用到加锁</li><li>使用不同的加锁对象，如果一定需要加锁，可以在 shutdownHook 的线程内使用一把新的锁，这样即可以保证安全性，又不会死锁。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到一个问题，通过脚本执行&lt;code&gt;kill -15&lt;/code&gt;后，程序并没有退出，进程一直都在，最后被退出脚本的通过&lt;code&gt;kill -9&lt;/code&gt;，杀死。导致数据完整性被破坏，程序再重启后不可用。通过排查认后发现是在执行&lt;code&gt;shutdownHoo
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="concurrent" scheme="https://liukay.com/categories/java/concurrent/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="并发" scheme="https://liukay.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="shutdownshutdownHook" scheme="https://liukay.com/tags/shutdownshutdownHook/"/>
    
  </entry>
  
  <entry>
    <title>matic checkpoint作用</title>
    <link href="https://liukay.com/posts/8ca79094.html"/>
    <id>https://liukay.com/posts/8ca79094.html</id>
    <published>2021-11-30T08:18:38.000Z</published>
    <updated>2021-11-30T08:53:34.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检查点-Checkpoint"><a href="#检查点-Checkpoint" class="headerlink" title="检查点 Checkpoint"></a>检查点 Checkpoint</h2><blockquote><p>RootHash is the Merkle hash of Bor block hashes from StartBlock to EndBlock<br>checkpoint 就是一开始区块到结束区块构建成的Merkle根hash。</p></blockquote><p>其实就是一组block区块的keccak256，再组装起来，生成一个Merkle的Hash。<br>然后提交到主链给合约验证合法性，以更新侧链状态。</p><h2 id="两个作用"><a href="#两个作用" class="headerlink" title="两个作用"></a>两个作用</h2><p>先说两个概念：</p><ol><li>铸币</li><li>燃烧</li></ol><p>用户从 ETH-&gt;MATIC 即，在ETH链上质押ETH到Matic链上，是存款操作，matic链上会进行相关的铸币操作。<br>用户从 MATIC-&gt;ETH 即，从Matic链上提现到ETH链上，是取款操作，Matic链上就会先燃烧Matic代币，再从ETH中释放对应ETH，就是燃烧。</p><p>1.通过提交到以太坊主链上的 checkpoint来决定，侧链上block的最终性(finality)。<br>2.在用户提现资产到主链上时，可以提供燃烧证明。</p><p>检查点很重要，因为它们在以太坊链上提供了最终性。<br>Heimdall 层允许将 Bor 生成的区块聚合到单个 Merkle 根中，并定期将其发布到以太坊主链。此已发布状态也称为检查点，因此整个过程称为检查点。</p><p>除了在主链上提供最终性之外，检查点（checkpoint）在取款中还可以发挥非常重要的作用，因为它们包含在用户取款时代币燃烧证明（取款）。<br>它允许用户使用 Patricia Merkle 证明和头块证明在根和约上证明其剩余代币。<br>注意，要证明剩余代币，必须通过PoS（权益持有人，就是 validtor）将头块提交到根链。<br>提款过程将照常收取以太坊gas费。<br>这些信息包含了用来验证用户在侧链上真实燃烧了一定数量代币的所需要的所有信息。</p><h2 id="燃烧证明"><a href="#燃烧证明" class="headerlink" title="燃烧证明"></a>燃烧证明</h2><p>取款，核心 Merkle 根<br>燃烧证明是什么：<br>简单说就是证明用户在侧链上确实发生了一笔资产提现的交易，验证这个燃烧证明有效的话，会将资产打到用户的地址，反之，如果验证不通过，则用户的这笔提现将失败。</p><p>用户等待checkpoint提交到主链上后，在侧链通过bttc sdk可以获取燃烧证明（the proof of burn trx）。</p><p>这里燃烧证明解决的是上面的第三个问题，即目标链上的信息传递到主链上的有效性问题。</p><h2 id="形成一个-checkpoint（工作原理）"><a href="#形成一个-checkpoint（工作原理）" class="headerlink" title="形成一个 checkpoint（工作原理）"></a>形成一个 checkpoint（工作原理）</h2><p>RootHash is the Merkle hash of Bor block hashes from StartBlock to EndBlock</p><p>一个区块内的多笔交易计算出blockhash</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockHash = keccak256([number, time, tx hash, receipt hash]) </span><br></pre></td></tr></table></figure><p>所有block hash参于生成 Merkle Hash</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pseudocode <span class="keyword">for</span> the root hash <span class="keyword">for</span> <span class="number">1</span> to n Bor blocks:</span><br><span class="line"></span><br><span class="line">B(<span class="number">1</span>) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line">B(<span class="number">2</span>) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">B(n) := keccak256([number, time, tx hash, receipt hash])</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkpoint is Merkle root of all block hash</span></span><br><span class="line">checkpoint<span class="string">&#x27;s root hash = Merkel[B(1), B(2), ....., B(n)]</span></span><br></pre></td></tr></table></figure><p>而上面提到的这笔用来申请提现的燃烧交易，就被包含在这个区块当中，并且被用来计算出这个块的blockhash.当累计了一定数量的块之后(从startblock到endblock，参见上面checkpoint结构)，这些块被计算出各自的blockhash，然后用这些blockhash来计算出root hash,如下面共识所示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Checkpoint block header struct</span></span><br><span class="line"><span class="keyword">type</span> Checkpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">        Proposer   HeimdallAddress <span class="string">`json:&quot;proposer&quot;`</span></span><br><span class="line">        StartBlock <span class="keyword">uint64</span>          <span class="string">`json:&quot;start_block&quot;`</span></span><br><span class="line">        EndBlock   <span class="keyword">uint64</span>          <span class="string">`json:&quot;end_block&quot;`</span></span><br><span class="line">        RootHash   HeimdallHash    <span class="string">`json:&quot;root_hash&quot;`</span></span><br><span class="line">        BorChainID <span class="keyword">string</span>          <span class="string">`json:&quot;bor_chain_id&quot;`</span></span><br><span class="line">        TimeStamp  <span class="keyword">uint64</span>          <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看默认是5分钟提一次checkpoint。<br>目前 侧链(BOR) 是2s 一个块，checkpoint最低提交256个快，checkpoint_poll_interval 最低合理值为8m32s，<br>最大值为1024<code>*</code>2s ，34m8s，可设置[9,30]分钟，如果有多条主链的的情况下，可根据各主链手续费不同，可以拆分此checkpoint_poll_interval分别设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DefaultCheckpointerPollInterval = <span class="number">5</span> * time.Minute</span><br><span class="line">DefaultSyncerPollInterval       = <span class="number">1</span> * time.Minute</span><br><span class="line">DefaultNoACKPollInterval        = <span class="number">1010</span> * time.Second</span><br><span class="line">DefaultClerkPollInterval        = <span class="number">10</span> * time.Second</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;检查点-Checkpoint&quot;&gt;&lt;a href=&quot;#检查点-Checkpoint&quot; class=&quot;headerlink&quot; title=&quot;检查点 Checkpoint&quot;&gt;&lt;/a&gt;检查点 Checkpoint&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;RootHash 
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="polygon" scheme="https://liukay.com/categories/blockchain/polygon/"/>
    
      <category term="polygon" scheme="https://liukay.com/categories/polygon/"/>
    
      <category term="matic" scheme="https://liukay.com/categories/polygon/matic/"/>
    
    
      <category term="matic" scheme="https://liukay.com/tags/matic/"/>
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="polygon" scheme="https://liukay.com/tags/polygon/"/>
    
  </entry>
  
  <entry>
    <title>mysql 5.8 安装</title>
    <link href="https://liukay.com/posts/3d0988b0.html"/>
    <id>https://liukay.com/posts/3d0988b0.html</id>
    <published>2021-11-26T02:35:04.000Z</published>
    <updated>2021-11-26T03:37:11.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h2><p>mysql 这里通过rpm的方式安装，使用 MySQL 官方提供的安装包选择适合自己系统的包进行安装<br>到这个页面下选择适合自己系统的版本：<br><a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p><p>Select Operating System: 选择系统，如果是Linux CentOS 选 Red Hat即可，如果没有你的版本，选 Linux-generic。</p><p>Select OS Version: 选对应的版本，CentOS 7 选 Enterprise 7 x86, 64-bit。</p><p>最近添新增了一些CentOS7 的机器，就使用 Red Hat 的版本进行安装。</p><p><img src="/posts/3d0988b0/%E9%80%89%E6%8B%A9%E7%89%88%E6%9C%AC.png" alt="选择版本"></p><h2 id="御载旧版本"><a href="#御载旧版本" class="headerlink" title="御载旧版本"></a>御载旧版本</h2><p>一定要御载干净，否则安装过程中有版本问题！！！<br>yum 和 rpm 两种方式二选一:<br>列出所有已安装的，但不在rpm中的包<br>yum list installed mysql<br>结果</p><blockquote><p>mysql-libs.x86_64<br>yum -y remove mysql-libs.x86_64</p></blockquote><p>等价于上面的命令<br>rpm -qa | grep mysql<br>结果</p><blockquote><p>mysql80-community-release-el7-4.noarch<br>mysql-community-common-8.0.27-1.el7.x86_64</p></blockquote><p>阿里去自带 MariaDB，并不是需要的直接御载。<br>移除</p><blockquote><p>rpm -e mariadb-libs-5.5.60-1.el7_5.x86_64</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><blockquote><p>wget <a href="https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.27-1.el7.x86_64.rpm-bundle.tar">https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.27-1.el7.x86_64.rpm-bundle.tar</a></p></blockquote><p>EL是Red Hat Enterprise Linux的简写</p><ul><li>EL6 软件包用于在Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x进行安装</li><li>EL7 软件包用于在Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x的安装</li></ul><p><img src="/posts/3d0988b0/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6.png" alt="下载文件"></p><p>必须安装(注意顺序)</p><blockquote><p>yum install libaio<br>sudo rpm -ivh mysql-community-common-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-client-plugins-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-libs-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-client-8.0.27-1.el7.x86_64.rpm<br>sudo rpm -ivh mysql-community-server-8.0.27-1.el7.x86_64.rpm</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote><p>systemctl start  mysqld.service</p></blockquote><p>查看服务状态</p><blockquote><p>systemctl status mysqld.service</p></blockquote><p><img src="/posts/3d0988b0/%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81.png" alt="查看状态"></p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>查看默认密码，这是一个生成的随机密码，复制出来后，修改成己的密码。</p><blockquote><p>grep &quot;password&quot; /var/log/mysqld.log</p></blockquote><blockquote><p>mysql -u root -p</p></blockquote><p>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库<br>格式：</p><blockquote><p>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;</p></blockquote><p>输入：</p><blockquote><p>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;abcdefg1234567&#39;;</p></blockquote><p>成功提示：Query OK, 0 rows affected (0.01 sec)</p><p>如果提示：</p><blockquote><p>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p></blockquote><p>说明密码不满足默认安全策略，把密码搞复杂一点，就是那种自己也记不住，只能靠复制粘贴的那种。<br>也可以调低安全策略：</p><blockquote><p>set global validate_password_policy=0;<br>set global validate_password_length=1;</p></blockquote><h2 id="安全策略，非常有必要"><a href="#安全策略，非常有必要" class="headerlink" title="安全策略，非常有必要"></a>安全策略，非常有必要</h2><p>要启动mysql服务的时候，有一些提示说明，在那里有一些有用的信息。<br>其中就有开启安全策略的方式:</p><blockquote><p>/usr/bin/mysql_secure_installation</p></blockquote><p>下面有很多选项，不用头疼：</p><p>Remove anonymous users? y 移除<br>移除 anonymous 用户</p><p>Disallow root login remotely? y<br>是否开启 root 远程访问？<br>选 Y 开启远程访问，这个需要考虑一下，如果是本地开发的话，不需要开，如果是不同机器上做主从复制的话，就开启</p><p>Remove test database? y<br>自带的测试数据库，移除。</p><p>Reload privilege tables now? y<br>重启数据库权限表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password for user root:</span><br><span class="line">The &#39;validate_password&#39; component is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration</span><br><span class="line">of the component.</span><br><span class="line">Using existing password for root.</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 100</span><br><span class="line">Change the password for root ? ((Press y|Y for Yes, any other key for No) : n</span><br><span class="line"></span><br><span class="line"> ... skipping.</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&#39;localhost&#39;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named &#39;test&#39; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line"> - Dropping test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br></pre></td></tr></table></figure><h2 id="开启远程登陆"><a href="#开启远程登陆" class="headerlink" title="开启远程登陆"></a>开启远程登陆</h2><blockquote><p>use mysql;</p></blockquote><p>host里指定ip，%是通配符，可以添加多条</p><blockquote><p>update user set host = &#39;%&#39; where user = &#39;root&#39;;<br>#刷新，否则不成功<br>flush privileges;</p></blockquote><p>查看当前用户的 host</p><blockquote><p>select host, user from user;</p></blockquote><p><img src="/posts/3d0988b0/%E6%9F%A5%E7%9C%8Bhost.png" alt="查看host"></p><p>退出</p><blockquote><p>quit;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;选择版本&quot;&gt;&lt;a href=&quot;#选择版本&quot; class=&quot;headerlink&quot; title=&quot;选择版本&quot;&gt;&lt;/a&gt;选择版本&lt;/h2&gt;&lt;p&gt;mysql 这里通过rpm的方式安装，使用 MySQL 官方提供的安装包选择适合自己系统的包进行安装&lt;br&gt;到这个页面下选择
      
    
    </summary>
    
      <category term="mysql" scheme="https://liukay.com/categories/mysql/"/>
    
      <category term="database" scheme="https://liukay.com/categories/database/"/>
    
      <category term="mysql" scheme="https://liukay.com/categories/database/mysql/"/>
    
    
      <category term="安装" scheme="https://liukay.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="mysql" scheme="https://liukay.com/tags/mysql/"/>
    
      <category term="数据库" scheme="https://liukay.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>tron波场 java-tron FullNode 节点启动</title>
    <link href="https://liukay.com/posts/632243fb.html"/>
    <id>https://liukay.com/posts/632243fb.html</id>
    <published>2021-11-25T09:48:37.000Z</published>
    <updated>2022-01-27T06:47:36.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>tron 有三种节点类型：</p><ol><li>SuperNode：负责生产区块。tron链是DPOS共识，只有27个SR能够产块。</li><li>FullNode: 节点负责广播区块，不进行产块，网络中的FullNode转发区块、广播区块。</li><li>SolidityNode: 该节点类型已经合并为其它两种节点类型，不会单独运行或部署，所以不再单独部署。</li></ol><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>保证以下环境正常使用</p><ol><li>JDK 1.8</li><li>gradle</li></ol><h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><p>项目的启动方式：</p><ol><li>官方脚本启动</li><li>手动指定参数启动</li><li>docker 启动</li></ol><h3 id="脚本方式"><a href="#脚本方式" class="headerlink" title="脚本方式"></a>脚本方式</h3><p>这种方式最简单，不过一般使用区块链的开发者都需要debug代码，所以一般在部署的时候使用脚本启动。</p><p>需要用到的文件，都可以从 java-tron 这个项目中获得。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tronprotocol/java-tron.git</span><br><span class="line">cd java-tron</span><br><span class="line">git checkout -t origin/master</span><br><span class="line">./gradlew build -x test</span><br></pre></td></tr></table></figure><p>使用gradle编译后，把主要的关键文件拿出来:</p><ol><li>配置文件 config.conf</li><li>主程序 FullNode.jar</li><li>启动脚本 start.sh，在项目根目录</li></ol><p>FullNode.jar</p><p>使用 gradle 编译后会在<code>java-tron/build</code>目录下生成 FullNode.jar文件。</p><blockquote><p>java-tron/build/libs/FullNode.jar</p></blockquote><p>config.conf</p><blockquote><p>java-tron/framework/src/main/resources/config.conf</p></blockquote><p>start.sh</p><blockquote><p>java-tron/start.sh</p></blockquote><p>准备好以上文件后，准备启动FullNode.jar，并查看日志</p><blockquote><p>sh start.sh</p></blockquote><p><img src="/posts/632243fb/FullNode%E5%90%AF%E5%8A%A8.png" alt="FullNode启动"></p><p>产块日志，到这个阶段大概卡了30秒左右</p><p><img src="/posts/632243fb/%E4%BA%A7%E5%9D%97%E6%97%A5%E5%BF%97.png" alt="产块日志"></p><p>所有启动前和启动后的文件</p><p><img src="/posts/632243fb/%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E6%96%87%E4%BB%B6.png" alt="所有节点文件"></p><h2 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h2><p>手动启动服务，就是jar包启动，先排除JVM相关的优化参数，看看哪些是必须的参数。<br>至于JVM的优化参数，可以参考启动脚本当中官方给出的调优参数。</p><p><strong>-c</strong>: config配置文件路径<br><strong>-d</strong>: 指定数据库存放路径</p><blockquote><p>java -jar FullNode.jar -c config.conf</p></blockquote><hr><h2 id="docker-方式启动"><a href="#docker-方式启动" class="headerlink" title="docker 方式启动"></a>docker 方式启动</h2><p>在系统中先保证 docker 正常使用。</p><h3 id="取拉项目代码"><a href="#取拉项目代码" class="headerlink" title="取拉项目代码"></a>取拉项目代码</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tronprotocol/java-tron.git</span><br><span class="line">cd java-tron</span><br></pre></td></tr></table></figure><h3 id="构建本地镜象"><a href="#构建本地镜象" class="headerlink" title="构建本地镜象"></a>构建本地镜象</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t tronprotocol/java-tron .</span><br></pre></td></tr></table></figure><p><img src="/posts/632243fb/docker%E6%9E%84%E5%BB%BA.png" alt="docker构建"></p><h3 id="查看本地镜象"><a href="#查看本地镜象" class="headerlink" title="查看本地镜象"></a>查看本地镜象</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="/posts/632243fb/%E6%9F%A5%E7%9C%8Bdocker_images.png" alt="查看docker_images"></p><h3 id="启动镜象"><a href="#启动镜象" class="headerlink" title="启动镜象"></a>启动镜象</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p 8090:8090 -p 8091:8091 -p 18888:18888 -p 50051:50051 --restart always tronprotocol/java-tron</span><br></pre></td></tr></table></figure><p><img src="/posts/632243fb/%E8%BF%90%E8%A1%8Cjava-tron%E7%9A%84docker%E9%95%9C%E8%B1%A1.png" alt="运行java-tron的docker镜象"></p><p>查看镜象运行情况，动行成功，状态 STATUS 是 Up 17 hours，这是因为我启动之后过了17个小时才回来查看状态。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                    COMMAND                  CREATED        STATUS        PORTS                                                                                  NAMES</span><br><span class="line">f181fab2948f   tronprotocol/java-tron   &quot;./bin/docker-entryp…&quot;   17 hours ago   Up 17 hours   0.0.0.0:8090-8091-&gt;8090-8091/tcp, 0.0.0.0:18888-&gt;18888/tcp, 0.0.0.0:50051-&gt;50051/tcp   optimistic_khayyam</span><br></pre></td></tr></table></figure><p>查看下日志，容器ID是: <code>f181fab2948f</code>，<code>number=26981</code> 这个是当前处理的块高，跑了17个小时才处理到这里。</p><blockquote><p>docker exec -it f181fab2948f tail -f /java-tron/logs/tron.log</p></blockquote><p><img src="/posts/632243fb/%E6%9F%A5%E7%9C%8Bjava-tron_docker%E8%BF%90%E8%A1%8C%E6%97%A5%E5%BF%97.png" alt="查看java-tron_docker运行日志"></p><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><blockquote><p>docker container kill f181fab2948f</p></blockquote><p><img src="/posts/632243fb/%E5%81%9C%E6%AD%A2java-tron%E7%9A%84docker%E9%95%9C%E8%B1%A1.png" alt="停止java-tron的docker镜象"></p><p>如果不使用了可以把容器和镜象完全删除，容器运行会产生很多的数据占磁盘空间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;tron 有三种节点类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SuperNode：负责生产区块。tron链是DPOS共识，只有27个SR能够产块。&lt;
      
    
    </summary>
    
      <category term="blockchain" scheme="https://liukay.com/categories/blockchain/"/>
    
      <category term="tron" scheme="https://liukay.com/categories/blockchain/tron/"/>
    
      <category term="tron" scheme="https://liukay.com/categories/tron/"/>
    
      <category term="fullNode" scheme="https://liukay.com/categories/tron/fullNode/"/>
    
    
      <category term="blockchain" scheme="https://liukay.com/tags/blockchain/"/>
    
      <category term="java-tron" scheme="https://liukay.com/tags/java-tron/"/>
    
      <category term="FullNode" scheme="https://liukay.com/tags/FullNode/"/>
    
  </entry>
  
  <entry>
    <title>idea 2021 Debug卡住一直提示Collecting data</title>
    <link href="https://liukay.com/posts/ff7fe1c0.html"/>
    <id>https://liukay.com/posts/ff7fe1c0.html</id>
    <published>2021-11-24T06:37:11.000Z</published>
    <updated>2021-11-24T08:12:46.494Z</updated>
    
    <content type="html"><![CDATA[<p>还是IDEA 的问题 mac M1 加 IDEA2021的问题还真不少，debug时发现会一直卡住，在调用底层jar包时，创建一个对象就一直提示 Collecting data，并没有断点。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><img src="/posts/ff7fe1c0/%E8%A7%A3%E5%86%B3.png" alt="解决"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是IDEA 的问题 mac M1 加 IDEA2021的问题还真不少，debug时发现会一直卡住，在调用底层jar包时，创建一个对象就一直提示 Collecting data，并没有断点。&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#解决&quot; class=&quot;head
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="idea" scheme="https://liukay.com/categories/java/idea/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="idea" scheme="https://liukay.com/tags/idea/"/>
    
      <category term="ide" scheme="https://liukay.com/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码阅读环境</title>
    <link href="https://liukay.com/posts/992b6df6.html"/>
    <id>https://liukay.com/posts/992b6df6.html</id>
    <published>2021-11-23T02:46:45.000Z</published>
    <updated>2021-11-27T08:20:16.916Z</updated>
    
    <content type="html"><![CDATA[<p>要进行源码阅读之前，强调需要先对一个产品有熟悉的使用，就好像你想要造车，要先会开车，再去学习如何造车，否则一切都是停在理轮上，完全不了解这个车是如何运行的，没有概念。<br>推荐对需要阅读的源码先保存在自己仓库中，并创建一个源码分支，可以在阅读分析的过程中对重要点进行注释帮助加深理解。</p><h2 id="fork源码"><a href="#fork源码" class="headerlink" title="fork源码"></a>fork源码</h2><p>Spring 官方github源码仓库</p><p><a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p><img src="/posts/992b6df6/fork%E6%BA%90%E7%A0%81.jpg" alt="fork源码"></p><h2 id="构建源码阅读环境"><a href="#构建源码阅读环境" class="headerlink" title="构建源码阅读环境"></a>构建源码阅读环境</h2><p>将代码 clone 到本地，克隆完成后，IDEA自动打开项目。</p><p><img src="/posts/992b6df6/clone%E4%BB%A3%E7%A0%81.jpg" alt="clone代码"></p><p>报错处理，首次打开会报个错，别慌这是因为IDEA缺少必要插件，点右侧 gradle 的构建按钮构建一次。<br><img src="/posts/992b6df6/%E6%8A%A5%E9%94%99.jpg" alt="报错"></p><p>首次构建需要下载的包比较多，</p><p><img src="/posts/992b6df6/%E6%9E%84%E5%BB%BA.jpg" alt="构建"></p><h2 id="直接使用-git-clone-方式"><a href="#直接使用-git-clone-方式" class="headerlink" title="直接使用 git clone 方式"></a>直接使用 git clone 方式</h2><p>直接使用命令行git clone 项目的话，拉完代码后，IDEA 通过导入的方式导入项目。</p><blockquote><p>file---&gt;new---&gt;Project from Exisitings Sources</p></blockquote><p>后续步骤相同。</p><h2 id="gradle-问题"><a href="#gradle-问题" class="headerlink" title="gradle 问题"></a>gradle 问题</h2><p>spring 是基于gradle进行构建的，如果没有安装gradle也没有关系，IDEA会在启动时，自动根据当前环境下载gradle及插件。</p><p><img src="/posts/992b6df6/gradle.jpg" alt="gradle"></p><h2 id="构建成功"><a href="#构建成功" class="headerlink" title="构建成功"></a>构建成功</h2><p><img src="/posts/992b6df6/%E6%88%90%E5%8A%9F.jpg" alt="成功"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要进行源码阅读之前，强调需要先对一个产品有熟悉的使用，就好像你想要造车，要先会开车，再去学习如何造车，否则一切都是停在理轮上，完全不了解这个车是如何运行的，没有概念。&lt;br&gt;推荐对需要阅读的源码先保存在自己仓库中，并创建一个源码分支，可以在阅读分析的过程中对重要点进行注释帮
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/java/spring/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/spring/"/>
    
      <category term="源码分析" scheme="https://liukay.com/categories/spring/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="code" scheme="https://liukay.com/categories/code/"/>
    
      <category term="spring" scheme="https://liukay.com/categories/code/spring/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="spring" scheme="https://liukay.com/tags/spring/"/>
    
      <category term="源码" scheme="https://liukay.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>gradle 安装</title>
    <link href="https://liukay.com/posts/d723a7c4.html"/>
    <id>https://liukay.com/posts/d723a7c4.html</id>
    <published>2021-11-23T02:13:46.000Z</published>
    <updated>2022-01-22T04:03:45.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网</p><p><a href="https://gradle.org/">https://gradle.org/</a></p><p>下载页面<br><a href="https://gradle.org/releases/">https://gradle.org/releases/</a></p><p>选择自己需要的版本，下载已经编译好的二进制文件<br>Download: binary-only</p><p><img src="/posts/d723a7c4/%E5%AE%89%E8%A3%85.jpg" alt="安装"></p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>设置 <code>.bash_profile</code> 文件添加</p><blockquote><p>export PATH=$PATH:/Users/liukai/workspaces/application/gradle-6.6.1/bin</p></blockquote><p>验证一下</p><p><img src="/posts/d723a7c4/%E9%AA%8C%E8%AF%81.jpg" alt="验证"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;官网&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gradle.org/&quot;&gt;https://gradle.org/&lt;/a&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="gradle" scheme="https://liukay.com/categories/java/gradle/"/>
    
    
      <category term="安装" scheme="https://liukay.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="gradle" scheme="https://liukay.com/tags/gradle/"/>
    
      <category term="项目构建" scheme="https://liukay.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA2021使用tomcat启动时间超长</title>
    <link href="https://liukay.com/posts/719ff018.html"/>
    <id>https://liukay.com/posts/719ff018.html</id>
    <published>2021-11-22T08:40:22.000Z</published>
    <updated>2021-11-23T02:11:07.292Z</updated>
    
    <content type="html"><![CDATA[<p>最近换了 mac M1 加 IDEA2021 后，发现问题还真不少，先是解决了卡顿问题后，tomcat 启动时间从原来的十几秒，变成20分钟！！！超不正常。</p><p>新电脑问题多。</p><p>直接说怎么解决的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>scutil --set HostName &quot;localhost&quot;</p></blockquote><h2 id="无效的偿试-修改生成随机数"><a href="#无效的偿试-修改生成随机数" class="headerlink" title="无效的偿试-修改生成随机数"></a>无效的偿试-修改生成随机数</h2><p>IDEA2021 添加tomcat启动参数，JRE默认使用 /dev/random作为随机数来源，当熵池大小不够的时候，random会很慢，造成随机数生成调用阻塞。</p><blockquote><p>JAVA_OPTS=&quot;-Djava.security.egd=file:/dev/urandom&quot;<br>无效，依然该怎么慢还怎么慢。</p></blockquote><h2 id="真正原因-Jvm需要很长时间解析localhost的IP地址"><a href="#真正原因-Jvm需要很长时间解析localhost的IP地址" class="headerlink" title="真正原因 Jvm需要很长时间解析localhost的IP地址"></a>真正原因 Jvm需要很长时间解析localhost的IP地址</h2><p>原因分析<br><a href="https://www.codenong.com/39636792/">https://www.codenong.com/39636792/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近换了 mac M1 加 IDEA2021 后，发现问题还真不少，先是解决了卡顿问题后，tomcat 启动时间从原来的十几秒，变成20分钟！！！超不正常。&lt;/p&gt;
&lt;p&gt;新电脑问题多。&lt;/p&gt;
&lt;p&gt;直接说怎么解决的。&lt;/p&gt;
&lt;h2 id=&quot;解决&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="idea" scheme="https://liukay.com/categories/java/idea/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="idea" scheme="https://liukay.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>hexo 分类或标签单词开头大写出现404</title>
    <link href="https://liukay.com/posts/4631c4c2.html"/>
    <id>https://liukay.com/posts/4631c4c2.html</id>
    <published>2021-11-21T06:21:06.000Z</published>
    <updated>2021-11-21T06:27:51.841Z</updated>
    
    <content type="html"><![CDATA[<p>最近搬运笔记到博客，编辑的文章多了，今天突然发现，有一个分类点进去404，本地运行正常没有问题。查了一圈发现是git的大小写区分问题。</p><p>将大写字母改成小写，hexo 部署正确，但是博客上还是不正确出现404</p><p>网上查了许多资料，才发现，git中设置了大小写不敏感。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>修改 git 设置不忽略大小写</p><p>进入博客文件夹，进入 git 目录：<code>.deploy_git</code>，修改 .git 文件中的配置文件 config，将ignorecase=true 改为 ignorecase=false</p><blockquote><p>vim . deploy_git/.git/config<br>ignorecase = false</p></blockquote><p>重写清空部署项目</p><p>如果还没有解决，清空部署到 github 上的文件，重新发布：</p><blockquote><p>cd .deploy_git<br>git rm -rf *<br>git commit -m &#39;clean all file&#39;<br>git push</p></blockquote><p>进入博客文件夹，用 hexo 重新生成部署</p><blockquote><p>hexo clean &amp;&amp; hexo g -d</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近搬运笔记到博客，编辑的文章多了，今天突然发现，有一个分类点进去404，本地运行正常没有问题。查了一圈发现是git的大小写区分问题。&lt;/p&gt;
&lt;p&gt;将大写字母改成小写，hexo 部署正确，但是博客上还是不正确出现404&lt;/p&gt;
&lt;p&gt;网上查了许多资料，才发现，git中设置
      
    
    </summary>
    
      <category term="hexo" scheme="https://liukay.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://liukay.com/tags/hexo/"/>
    
      <category term="404" scheme="https://liukay.com/tags/404/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 2021 CPU 超100% 问题解决</title>
    <link href="https://liukay.com/posts/f271493a.html"/>
    <id>https://liukay.com/posts/f271493a.html</id>
    <published>2021-11-20T13:44:47.000Z</published>
    <updated>2021-11-21T01:06:06.149Z</updated>
    
    <content type="html"><![CDATA[<p>用了IDEA 2021之后cpu超过200，打开一个类文件就卡住一会，起初以为是语法检查的问题，把所有语法检查一个不留全关闭，还是没解决。</p><p>最终解决方式，配置IDEA 的JVM参数：</p><p><img src="/posts/f271493a/1.png" alt="修改参数"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#堆栈设置</span><br><span class="line">-Xms4096m</span><br><span class="line">-Xmx4096m</span><br><span class="line">-Xmn3072m</span><br><span class="line">-XX:MetaspaceSize&#x3D;1024m</span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;1024m</span><br><span class="line">-XX:+AlwaysPreTouch</span><br><span class="line">-XX:InitialCodeCacheSize&#x3D;1200m</span><br><span class="line">-XX:ReservedCodeCacheSize&#x3D;1200m</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-Dfile.encoding&#x3D;UTF-8</span><br><span class="line"></span><br><span class="line"># 采用何种垃圾回收参数</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:ParallelGCThreads&#x3D;4</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB&#x3D;50</span><br><span class="line">-ea</span><br><span class="line"># JIT 参数</span><br><span class="line">-XX:CICompilerCount&#x3D;2</span><br><span class="line">-XX:TieredStopAtLevel&#x3D;1</span><br><span class="line">-XX:MaxInlineLevel&#x3D;3</span><br><span class="line">-XX:Tier4MinInvocationThreshold&#x3D;100000</span><br><span class="line">-XX:Tier4InvocationThreshold&#x3D;110000</span><br><span class="line">-XX:Tier4CompileThreshold&#x3D;120000</span><br><span class="line"></span><br><span class="line">-Dsun.io.useCanonPrefixCache&#x3D;false</span><br><span class="line">-Djava.net.preferIPv4Stack&#x3D;true</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes&#x3D;&quot;&quot;</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Djdk.attach.allowAttachSelf</span><br><span class="line">-Xverify:none</span><br><span class="line"></span><br><span class="line">-XX:ErrorFile&#x3D;$USER_HOME&#x2F;java_error_in_idea_%p.log</span><br><span class="line">-XX:HeapDumpPath&#x3D;$USER_HOME&#x2F;java_error_in_idea.hprof</span><br></pre></td></tr></table></figure><p>立杆见影，原因不是垃圾回收造成的cpu负载过高 而是由于JIT Compiler 及时编译将class文件编译成本地机器代码占用了大量的cpu资源导致的卡顿。</p><p>具体请参考国外idea bug追踪他们的idea cpu 100% 讨论<br><a href="https://youtrack.jetbrains.com/issue/IDEA-207243">https://youtrack.jetbrains.com/issue/IDEA-207243</a></p><p>参考：<a href="https://www.jianshu.com/p/ac72a14afc24">https://www.jianshu.com/p/ac72a14afc24</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了IDEA 2021之后cpu超过200，打开一个类文件就卡住一会，起初以为是语法检查的问题，把所有语法检查一个不留全关闭，还是没解决。&lt;/p&gt;
&lt;p&gt;最终解决方式，配置IDEA 的JVM参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/f271493a/1.png
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="idea" scheme="https://liukay.com/categories/java/idea/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="idea" scheme="https://liukay.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>netty 构建一个简易服务</title>
    <link href="https://liukay.com/posts/fab0cb81.html"/>
    <id>https://liukay.com/posts/fab0cb81.html</id>
    <published>2021-11-19T08:08:20.000Z</published>
    <updated>2021-11-19T08:51:28.496Z</updated>
    
    <content type="html"><![CDATA[<p>使用 IDEA + netty + gradle 构建一个简单的HTTP服务，用来学习netty。</p><h2 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h2><p>netty 构建一个服务，需要三个角色参与</p><ol><li>Server 运行服务</li><li>Initializer 组装组件</li><li>Handle 业秋处理</li></ol><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>添加 build.gradle，复制内容</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插件管理</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//座标</span></span><br><span class="line"><span class="keyword">group</span> <span class="string">&#x27;com.liukai.netty&#x27;</span></span><br><span class="line">version <span class="string">&#x27;1.0-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//源和目标编译版本</span></span><br><span class="line"><span class="keyword">sourceCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"><span class="keyword">targetCompatibility</span> = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//仓库，这里使用 maven 远程仓库，也就是说本没有，就去远程获取</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖管理</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">//测试用名，不用打到生产包中</span></span><br><span class="line">    <span class="comment">//group是 maven 的 group, name 是 artifactId, version 相同</span></span><br><span class="line">    testCompile <span class="keyword">group</span>: <span class="string">&#x27;junit&#x27;</span>, name: <span class="string">&#x27;junit&#x27;</span>, version: <span class="string">&#x27;4.12&#x27;</span></span><br><span class="line">    <span class="comment">//等价写法，推荐 group:artifactId:version</span></span><br><span class="line">    testCompile(</span><br><span class="line">            <span class="string">&quot;junit:junit:4.12&quot;</span></span><br><span class="line">            <span class="comment">//多行逗号隔开</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//编译的包</span></span><br><span class="line">    <span class="keyword">compile</span>(</span><br><span class="line">            <span class="string">&quot;io.netty:netty-all:4.1.10.Final&quot;</span></span><br><span class="line">            <span class="comment">//多行逗号隔开</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器-NettyServer"><a href="#服务器-NettyServer" class="headerlink" title="服务器 NettyServer"></a>服务器 NettyServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liukai.netty.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 http 服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu kai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-12-29 22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> NettyChannelInitializer());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">8889</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组装组件-NettyChannelInitializer"><a href="#组装组件-NettyChannelInitializer" class="headerlink" title="组装组件 NettyChannelInitializer"></a>组装组件 NettyChannelInitializer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liukai.netty.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渠道构建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu kai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-12-29 22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个回调的方法，在channel被注册时被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        <span class="comment">//这里看一下源码</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;httpServerCodec&quot;</span>, <span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//增加一个自己定义的处理器handel</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;testHttpServerHandler&quot;</span>, <span class="keyword">new</span> NettyServerHandle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Handle-业务处理器-NettyServerHandle"><a href="#Handle-业务处理器-NettyServerHandle" class="headerlink" title="Handle 业务处理器 NettyServerHandle"></a>Handle 业务处理器 NettyServerHandle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liukai.netty.test01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liu kai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-12-29 22:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandle</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承InboundHandler类，代表处理进入的请求，还有OutboundHandler,处理出去请求</span></span><br><span class="line"><span class="comment">     * 其中里面的泛型表示msg的类型，如果指定了HttpObject，表明这是个HTTP连接的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//channelRead0读取客户端请求，并返回响应的方法</span></span><br><span class="line">        <span class="comment">//如果不加这个判断使用curl 测试会报错，使用curl测试命令curl &quot;http://localhost:8899&quot;</span></span><br><span class="line">        <span class="comment">//判断这个是不是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            System.out.println(msg.getClass());</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.getUri());</span><br><span class="line">            ctx.channel().closeFuture();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;chrome 请求 favicon&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求方法名: &quot;</span> + httpRequest.getMethod().name());</span><br><span class="line">            <span class="comment">//ByteBuf 是netty中的重要概念，代表响应返回的数据</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;Hello World&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line">            <span class="comment">//如果只是调用write方法，他仅仅是存在缓冲区里，并不会返回客户端</span></span><br><span class="line">            <span class="comment">//调用writeAndFlush可以</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="/posts/fab0cb81/1.jpg" alt="验证"></p><p>控制台输出</p><p><img src="/posts/fab0cb81/2.jpg" alt="控制台输出"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 IDEA + netty + gradle 构建一个简单的HTTP服务，用来学习netty。&lt;/p&gt;
&lt;h2 id=&quot;主要角色&quot;&gt;&lt;a href=&quot;#主要角色&quot; class=&quot;headerlink&quot; title=&quot;主要角色&quot;&gt;&lt;/a&gt;主要角色&lt;/h2&gt;&lt;p&gt;netty
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="netty" scheme="https://liukay.com/categories/java/netty/"/>
    
    
      <category term="java" scheme="https://liukay.com/tags/java/"/>
    
      <category term="通信" scheme="https://liukay.com/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="netty" scheme="https://liukay.com/tags/netty/"/>
    
      <category term="服务" scheme="https://liukay.com/tags/%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>netty 简述</title>
    <link href="https://liukay.com/posts/9321f70b.html"/>
    <id>https://liukay.com/posts/9321f70b.html</id>
    <published>2021-11-16T07:07:38.000Z</published>
    <updated>2021-11-20T13:04:36.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是netty"><a href="#什么是netty" class="headerlink" title="什么是netty"></a>什么是netty</h2><p>Netty是一个异步的基于事件驱动(Reactor)的网络框架。<br>Netty是一个NIO客户服务器框架，它能够快速和容易地开发网络应用，如协议服务器和客户端。它大大简化了网络编程，如TCP和UDP套接字服务器。</p><h2 id="为什么选择netty"><a href="#为什么选择netty" class="headerlink" title="为什么选择netty"></a>为什么选择netty</h2><p>主要原因是 netty 简化了使用nio时对网络编程的复杂性，提供更多的抽象性和功能方便网络编程开发。</p><p>列举一个特点：<br>1.Netty支持三种IO模型同时支持三种Reactor模式。</p><p>2.Netty支持很多应用层的协议，提供了很多decoder和encoder。</p><p>3.Netty能够解决TCP长连接所带来的缺陷（粘包、半包等）</p><p>4.Netty支持应用层的KeepAlive。</p><p>5.Netty规避了JAVA NIO中的很多BUG，性能更好。</p><h2 id="使用-netty-能做什么"><a href="#使用-netty-能做什么" class="headerlink" title="使用 netty 能做什么"></a>使用 netty 能做什么</h2><p>1.实现节点间通信<br>2.实现自己的协议<br> dubbo、rocketmq 等底层都使用 netty 实现自己的协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是netty&quot;&gt;&lt;a href=&quot;#什么是netty&quot; class=&quot;headerlink&quot; title=&quot;什么是netty&quot;&gt;&lt;/a&gt;什么是netty&lt;/h2&gt;&lt;p&gt;Netty是一个异步的基于事件驱动(Reactor)的网络框架。&lt;br&gt;Netty是一个NI
      
    
    </summary>
    
      <category term="java" scheme="https://liukay.com/categories/java/"/>
    
      <category term="netty" scheme="https://liukay.com/categories/java/netty/"/>
    
    
      <category term="netty" scheme="https://liukay.com/tags/netty/"/>
    
      <category term="简述" scheme="https://liukay.com/tags/%E7%AE%80%E8%BF%B0/"/>
    
  </entry>
  
</feed>
