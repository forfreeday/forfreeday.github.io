{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"About","text":"关于我 刘凯，技术控热爱技术、猫、音乐、运动、赚钱。目前在北京，从事架构工作。喜欢学习各种技术，没事搞搞新鲜的东西。玩过几年安全技术，搞过web、免杀、渗透。现在喜欢写代码。 联系我 github: forfreeday","link":"/about/index.html"},{"title":"all-categories","text":"","link":"/all-categories/index.html"},{"title":"all-archives","text":"","link":"/all-archives/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"关于Reactor模型","text":"看了一些 Reactor 相关的文章和资料，列举的一些 Reactor 模型的优点，包括极客时间的文章也有讲过在架构中的Reactor中的优点和缺点。但是如果不使用 Reactor 模型的一般方式是什么样子的?会有什么问题？","link":"/2018/08/05/architecture--Reactor-%E6%A8%A1%E5%9E%8B/"},{"title":"什么是幂等","text":"幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。 幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。 这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，”setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现. 编程中的幂等 编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，”setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现. 白话：操作几次，结果都是一样。幂等与操作有关 幂等与你是不是分布式高并发还有JavaEE都没有关系。关键是你的操作是不是幂等的。一个幂等的操作典型如：把编号为5的记录的A字段设置为0这种操作不管执行多少次都是幂等的。一个非幂等的操作典型如：把编号为5的记录的A字段增加1这种操作显然就不是幂等的。要做到幂等性，从接口设计上来说不设计任何非幂等的操作即可。譬如说需求是：当用户点击赞同时，将答案的赞同数量+1。改为：当用户点击赞同时，确保答案赞同表中存在一条记录，用户、答案。赞同数量由答案赞同表统计出来。","link":"/2017/01/15/architecture--%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89/"},{"title":"Spring Gateway 静态路由--路径切割","text":"以代码 或 配置文件形式进行配置。RewritePath：路径匹配切割StripPrefix： 路径载取 参数说明1234id: 路由IDuri: 目标地址，可以是服务，如果服务Spring推荐用全大写，实际调用大小写不敏感，都可以调通。predicates: 匹配路径，以浏览器请求的端口号后面的第一级路径为起始。filters: 过滤器，包含Spring Gateway 内置过滤器，可以自定义过滤器。 1. 请求转发，转发到目标地址123456routes: # 跳转URL - id: 163_route uri: http://www.163.com/ predicates: - Path=/163 2.切路径1234567# oauth2 认证- id: OAUTH2 uri: lb://OAUTH-SERVER predicates: - Path=/oauth-server/** filters: - StripPrefix=1 参数说明 StripPrefix的意思是将路径切掉一级，这个例子中 oauth-server 被剪。 请求路径：localhost:9000/oauth-server/oauth-center/oauth/token?username=admin 最终结果：lb://OAUTH-SERVER/oauth-center/oauth/token?username=admin 3.请求重写 1234567# oauth2 认证- id: OAUTH2 uri: lb://OAUTH-SERVER/ predicates: - Path=/oauth-server/** filters: - RewritePath=/oauth-server/(?&lt;path&gt;.*), /$\\{path} 请求路径: localhost:9000/oauth-server/oauth-center/oauth/token?username=admin 最终结果: lb://OAUTH-SERVER/oauth-center/oauth/token?username=admin 验证了一下，RewritePath 的处理方式： RewritePath 找到自己的 /oauth-server/ 这一段，从 - Path 中去匹配，如果能匹配的到就是会将路径进行切割，注意是切割 切割方式将 /oauth-server/(?.*) ，中 中的路径切出来，也就是 oauth-server/后面的部份。 并将切的结果赋值到 {path} 中。 最后的拼接路径为 lb://SPRINGCLOUD-PROVIDER/path -Path 设置多个无效验证 predicates 的 -Path 设置多个无效，如果 -Path 中的路径匹配对了，但是 RewritePath 中的路径和 -Path 匹配不上会报 HTTP Status 404 4.路径重定–结果路径多一级1234567894.路径重写 这个测试，是在请求路径中不存在的url，添加到最终的请求路径中去 - id: OAUTH2 uri: lb://OAUTH-SERVER/ predicates: - Path=/oauth-server/** filters: - RewritePath=/oauth-server/(?&lt;path&gt;.*), /oauth-center/$\\{path} 请求路径: localhost:9000/oauth-server/oauth/token?username=admin 最终结果: lb://OAUTH-SERVER/oauth-center/oauth/token?username=adminoauth-center 在请求的路径中不存在，在 RewritePath 中进行重写，添加了一级路径。 总结： RewritePath: predicates 中的 - path 路径如果和 RewritePath 匹配则会被 RewritePath 剪切。 StripPrefix：剪取指定路径位数截取 1234567举个示例- id: rewritepath_route uri: http://example.org predicates: - Path=/a/b/** filters: - RewritePath=/a/b/(?&lt;segment&gt;.*), /f/$\\{segment} 结果:12请求的时为： /a/b/c最终结果为： /f/c","link":"/2019/07/22/Spring-Spring-Cloud-Gateway-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1-%E8%B7%AF%E5%BE%84%E5%88%87%E5%89%B2/"},{"title":"RSA 证书加解密通信","text":"经常有需要使用安全传输的场景，犹其是在一些泛及资金安全的行业，对数据的传输犹为重视安全性。一般常用的就是对前参的数据进行加密，再到后台进行解密。接口和接口之前的数据也用一样的方式进行加密和解密。 思路 生成公私钥证书 公钥对接口参数明文加密 私钥对接口参数明文解密 通信双方互相持有对方公私钥 如果所有的接口都需要加解密，可以放到拦截器中去统一处理，也可以用注解的方式，控制哪些接口需要加密，哪些接口不需要加密。","link":"/2017/04/09/architecture-%E8%AF%81%E4%B9%A6%E5%8A%A0%E8%A7%A3%E5%AF%86%E9%80%9A%E4%BF%A1/"},{"title":"集群容错模式","text":"Failfast Cluster模式这种模式称为快速失败模式，调用只执行一次，失败则立即报错。这种模式适用于非幂等性操作，每次调用的副作用是不同的，如写操作，比如交易系统我们要下订单，如果一次失败就应该让它失败，通常由服务消费方控制是否重新发起下订单操作请求（另一个新的订单）。-Failsafe Cluster模式失败安全模式，如果调用失败， 则直接忽略失败的调用，而是要记录下失败的调用到日志文件，以便后续审计。 Failback Cluster模式失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 Forking Cluster模式并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。 Broadcast Cluster模式广播调用所有提供者，逐个调用，任意一台报错则报错（2.1.0开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。","link":"/2020/05/06/architecture-%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99%E6%A8%A1%E5%BC%8F/"},{"title":"hadoop 1.0 和 NameNode 的一些回顾","text":"NameNode可以理解为主从模式： NameNode 是主节点 [Master]SecondaryNameNode[Master] DataNode 是从节点 [Worker] Hdfs 1.0 回顾1.NameNode 两种元数据映射：1.文件名—-&gt;block数据映射2.block 数据块 —&gt; datanode 节点地址的映射 细节： 1.是持久化到NN的磁盘上的（fsimage\\&lt;—edits log\\&lt;—NN的内存变化来的） 2.是通过心跳来组织起来的(DN—>NN) 注意：如果设置的副本数量小于DataNode的节点个数，其实是不会超过DataNode 的个数的。比如副本个数设3,DataNode只有两个，副本只会有两个。 2.就目前我们的环境（1个master，2个slaves）：虽然默认3个副本，期实是两个。3.NN倾向存储大数据：太小的话，block多，内存放不下，太大的话，MR作务执行慢。4.如果没有SNN，fsimage多久加载一次，只有重启时加载，如果有了SNN呢？SNN存在的意义？备份，数据恢复editlog 什么时候会合并到 fsimage中？（重启、定期）5.为什么在1.0只能有一个NN? (在zookeepeer 之前)6. 数据完整性校验的目的：检测数据是否损坏 用什么校验方法？ （crc32算法产生的校验合和）存在几种校验逻辑（1.client写校验和，DN校验， 2.DabablockScanner 后来进程） 7.HDFS 可靠性保证有哪些 心跳：DN–&gt;NN 块报告：检查数据有没有发生异常，存储情况 数据块完整性 空间回收 副本—数据冗余 SNN 快照 同步和异步的区别?以nameNode 写和为例： 同步写：一个 client 操作 节点写完即可，剩余节点一个一个写完 。 异步写：写完一个节点后，期余节点同步即可。 计算框架和任务调度管理部署同一台机器的好处？本地化，尽量减少数据移动的开销。","link":"/2018/07/14/bigdata--hadoop%201.0%20%E5%92%8C%20NameNode%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9B%9E%E9%A1%BE/"},{"title":"python 实现 map的分词原理","text":"Map 的作用，即数据的映射，用于把一组键值对映射成另一组新的键值对。白话就是对数据按照一定的格式进行归整。举个例子，有一遍文章，需要对文章中出现过的相同的单词进行归类，期望结果如下：将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。12{&quot;1&quot;, &quot;are&quot; : 1}{&quot;1&quot;, &quot;are&quot; : 1} 123456#encodeing=utf-8import sysfor line in sys.stdin: ss = line.strip().split(' ') for word in ss: print '\\t'.join([word.strip(), '1']) 测试数据： THE_MAN_OF_PROPERTY.txt，这里存一篇网上随机找的一篇英文长篇文章。 执行命令，并打印结果:1cat `THE_MAN_OF_PROPERTY.txt` | `python map.py` | `sort -k 1 &gt; 1.txt` 结果:12345678910111213to 1to 1to 1today 1tool 1topic 1two 1two 1···variants 1variants 1variants 1···","link":"/2018/08/19/bigdata--map%E4%BB%BB%E5%8A%A1python%E5%AE%9E%E7%8E%B0/"},{"title":"大数据常见业务","text":"常见业务1.搜索引擎三段式结构：1.检索系统2.索引系统3.spider爬虫 1.爬虫：由搜索引擎主动发起，去别人家的网站去爬数据关键是建索引 快速判重：布隆过滤器。给定数据排序：1.常见排序算法2.BitMap 算法， 数据量小的时间复杂度、空间复杂度比较大如(10、122、10万)。但是适应于密集的情况，有明显优势。 2.推荐系统NetFlix 推荐系统公司，很多公司的标杆，其他公司的系统多少都会抄这家公司。 推荐系统通常有三个部份： offline 部份，离线 nearline 部分，近线 online部分，在线 划分为以上三部分的理由： |___昨天__|__今天___| 离线：当天肯定无法将当天所有用户的行为数据拿到，所以将昨天的数据存储后进行计算。比如，用户9点看了鞋子的广告，但量不能确定10后用户还看了什么。离线挖掘出的数据，应快带提供出去，比如使用NOSQL做为中间介质传递出去。redis、mongo、hbase 等前端从nosql中去取数据。大至是这个流程。 在线：处理在线的时时的数据，对数据进行时时产生。如地图。为什么不用时实代替离线？？如果时实时系统做的很完备，可以不要离线。但是实时任务有个特点，时效性要求非常高，为了保证任务快速得到结果，所以必须做出妥协，所以实时任不能有复杂算法，否则一量有一个任务出现非实时性，则整个实时任务线将受到影响。离线不在乎时间，可以做复杂算法任务。所以两种任务，输入一样，输出并不一样。离线更准确，在线可以给一个近似的结果。 近线：类似在线，如 storm、spark 推荐数据放缓存数据库中，如：NOSQL 数据有两部分： 用户行为数据 物品元数据：即名称，描述，标签，颜色等等属性","link":"/2018/07/14/bigdata--%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B8%B8%E8%A7%81%E4%B8%9A%E5%8A%A1/"},{"title":"一级指针简单理解","text":"两个关键符号： &amp; : 取内存地址符 * : 取内存值符 指针的操作规律：121.声明的时候是往里放地址 int *p = &amp;num，2.直接拿的时候就是直接操作地址内的值 *p = 10; 在 C 中操作地址就可以操作值，就跟 java 中两个引用类型拿到引用可以操作内一个对象一样。123变量名 内存地址 值a [0x23fa32] 100*p [0x24aa34] [0x23fa32]指针存放的是 a 的内存地址，&amp;p则是自己的内存地址 [0x24aa34] 1.创建一个针指并使用1234567void main() { int num = 100; int *p = &amp;num; //将内存地址给 *p printf(&quot;%x, %x&quot;,&amp;num, &amp;p); *p = 10; printf(&quot;%d&quot;, num); //10} 分析过程：根据拿到的直址 分别查看 &amp;num，和 &amp;p。&amp;num 的地址以 带符号 4字节查看是100。查看&amp;p 的地址，以十六进制查看，因为存的是 &amp;num 的地址。并不是实际的值。这就证明了指针变量存的是地址。当程序再往下走 *p = 10 时，再回头看 &amp;num 的值，已经变红，修改成了10。 2.传递指针12345678void main() { int num = 100; change(&amp;num); //形参是指针类型，就可以将地址传递过去。}void change(int *p) { //创建一个指针用来接收地址 *p = 20;} 需要注意的是C当中的方法形参使用的是变量副本机制，也就是说，方法形参也是有个自己的内存地址。","link":"/2016/10/12/c-%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"},{"title":"使用 molloc 手动开辟内存","text":"手动开辟内存 主要使用的函数 molloc 进行操作。开启指定的内存空间。 while (1) { printf(\"%s\", \"自增内存\"); int *p = (int *)malloc(1024 * 1024 *10 ); //开10兆内存，并地址给一个指针。 Sleep(2000); } malloc 无效可能是杀毒软件拦截的原因。 malloc 用来创建动态的数组也是数组，跟普通的数组有什么区别呢：普通的数组是已知大小的情况下使用，malloc 的数组是在大小不确定的情况下使用，可以动态的分配指定大小，灵活度大。","link":"/2017/01/20/c-%E6%89%8B%E5%8A%A8%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98/"},{"title":"指针的初始化","text":"必须初始化才可以使用，未经初始化的指针会产生一个垃圾数据，这个数据是胡乱读取到的。不初始化先危险12int *p;*p = 5; //错误，必须先初始化NULL 空指针在 stdio.h 头文件中 NULL 是常量，表示不指向任何地址。if point == NULL 判断指针有没有被使用过。12int *p = NULL; //表示内存为 Ox000000;*p = 5; //访问冲突，0x000000 是操作系统使用的。VS 会报错，未经初始化的变量，但是有的IDE是不会报错的。","link":"/2016/10/12/c-%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"title":"指针类型不兼容","text":"类型不兼容不同类型的指针不可以赋值。否则赋值后，编译可以通过，但是执行后数据会变量错误数据。12345int a = 32138;int *p = &amp;a; //合法char *p1 = p; //合法，但是问题就在这里printf(&quot;%d,%d&quot;, *p, *p1);printf(&quot;\\n%d,%d&quot;, sizeof(*p), sizeof(*p1));指针都是4个字节存，这个没问题，问题在取，取的时候根据什么类型，就会读多大的长度，如果是 int 则会读4个字节，如果是 char 类型，则只会读一个字节，数据错误。 在 vs 上重现不出来，vs 直接报 类型不兼容。","link":"/2016/10/12/c-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%85%BC%E5%AE%B9/"},{"title":"空类型指针","text":"空类型指针malloc 查看底层源码中发现是空类型的指针，空类型的指针可以接收任意类型的指针，但是不能取出指针里的内容，如果要取出内容必须要强转。 1.验证空类型指针，可以接收任意类型指针，但不可以取值void testVoidPoint() { int a = 100; void *p = &amp;a; printf(\"%x, %x\", &amp;a, p); printf(\"%d\", *p); //error: invalid use of void expression getchar(); } 2.通过强转取值将值强转成对应的指针类型取出 void testVoidPoint2() { int a = 100; void *p = &amp;a; printf(\"%d\", *((int*)(p))); } 3.开辟空间，证明指针即是动态数组。void testVoidPoint3() { int intSize = sizeof(int); //得到4，证明 int 是 4 个字节 printf(\"%d\\n\", intSize); int *p = (int*) malloc(20 * sizeof(int)); //一开始就使用强转，开辟 20个4字节的空间，80个字节内存 for (int i = 0; i &lt; 20; ++i){ p[i] = i; //注意，指针本质上也可看成数组。指针的数组下标是可以动态分配的，数组不可以。 printf(\"%d,%x\\n\", &amp;p[i], i); } } 4.指针与动态数组的等价比较void testVoidPoint4() { int intSize = sizeof(int); printf(\"%d\\n\", intSize); int *p = (int*) malloc(20 * sizeof(int)); for (int i = 0; i &lt; 20; ++i){ p[i] = i; printf(\"%d,%x\\n\", p[i], &amp;p[i]); printf(\"%d,%x\\n\", *(p + i), p + i); } } p[i] 等价于 *(p + i)&amp;p[i] 等价于 p + i","link":"/2017/01/21/c-%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/"},{"title":"代理模式--静态代理模式","text":"静态代理静态代理的条件至少有三个角色： 真实角色(RealObject) 代理角色(ProxyObject) 接口这三个(AbstractObject) 要求: 真实角色与代理角色实现相同的接口。 代理类要持有真实角色的引用。重点：真实角色、代理角色、接口的关系。代理接口实际上是抽象出所有真实角色的共有方法。 用法：1.创建真实角色2.创建代理角色3.代理角色.方法()。 注意：代理模式是要让代理类来使用委托类，所以是通过 new 代理类，在代理类中使用委托类，有点像回调函数的用法。 测试方法12345678910111213/** * 功能描述：测试 * @author liukai * @date 2015年11月13日 下午3:47:33 * @version 1.0 */public class Test { public static void main(String[] args) { ServiceImpl serviceImpl = new ServiceImpl(); IService iService = (IService) Proxy.getInstance(serviceImpl); iService.say(); }} 代理类123456789101112131415161718192021222324252627/** * 功能描述：代理类 * @author liukai * @date 2015年11月13日 下午3:47:19 * @version 1.0 */public class Proxy implements IService{ private IService iService; public Proxy() { } public Proxy(IService iService) { this.iService = iService; } @Override public void say() { System.out.println(&quot;Proxy.say()&quot;); iService.say(); } public static IService getInstance(ServiceImpl object) { return new Proxy(object); }} 实现类12345678910111213141516/** * 功能描述：实现类 * @author liukai * @date 2015年11月13日 下午3:47:27 * @version 1.0 */public class ServiceImpl implements IService{ public ServiceImpl() { // TODO Auto-generated constructor stub } @Override public void say() { System.out.println(&quot;ServiceImpl.say()&quot;); }} 接口123456789/** * 功能描述：接口 * @author liukai * @date 2015年11月13日 下午3:47:06 * @version 1.0 */public interface IService { public abstract void say();} 静态代理类优缺点优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。缺点：1）代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。2）如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。","link":"/2015/11/13/design--%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"},{"title":"docker run 和 start 的区别","text":"1.docker rundocker run 只在第一次运行时使用，将镜像放到容器中，以后再次启动这个容器时，只需要使用命令docker start 即可。docker run相当于执行了两步操作：将镜像放入容器中（docker create）,然后将容器启动，使之变成运行时容器（docker start）。 2.docker startdocker start的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个容器的ID，或者这个容器的名字，我们可以使用docker ps找到这个容器的信息。 3.查看所有容器而要显示出所有容器，包括没有启动的，可以使用命令docker ps -a 4.重命名docker rename old_name new_name 5.启停docker [stop]|[start] name","link":"/2019/03/08/docker--run%E5%92%8Cstart%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"docker 基本操作","text":"最近在研究使用 docker 进行微服务改造，总结了一下常用的命令，docker 这东西，单个用简单，整体配合 k8s 和 spring cloud 坑还是不少，一个一个解决掉以后，他的易用性和高可用的特性确实很棒。 如果是业务日志需要输出到宿主机上，可以使用 -v 挂载。 1.查看 docker 信息 infodorker info ####2.运行 docker 容器 rundocker run IMAGE //启动容器docker run ubuntu echo “en heng”这种命令运行完就退出了。 3.启动交互式容器docker run -it IMAGE //交互式，即进入容器docker run -i -t ubuntu /bin/bash //进入容器ps -efexit //退出 4.查看容器 psdocker ps [-a] [-l]docker psdocker ps -a //-a 全部容器 CONTAINER ID //docker为容器分配的id，即守护进程IDNAME //docker 自动为镜象创建的名称 5.自定义容器名称 namedocker run –name=[自定义名称] -i -t ubuntu /bin/bashdocker run –name=container01 -i -t ubuntu /bin/bash 6.重新启动停止的容器 startdocker start [-i] 容器ID-i 交互模式docker start 8cf94828c8e6进入容器docker exec -it 8cf94828c8e6 bash 7.删除已经停止的容器docker rm [容器id | 容器名] //不能删除正在运行的容器","link":"/2019/03/04/docker--%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"eclipse+tomcat的问题能启动，但量不能访问","text":"今天还发现了一种情况tomcat起不来，配置是默认的，就是下面两张图的第一张图的配置。但是就是起不来，原因是web.xml配置有问题也会出现这种情况。 如果，按钮是灰的不能选择，那就把包含的项目先删掉，再clean一下就可以。 原来的解决方法：tomcat启动了但是却访问不了是因为：改成以下即可：","link":"/2015/10/06/eclipse-tomcat-start-question/"},{"title":"checkout 检出和切换","text":"这个命令是个多功能的命令用法很灵活。切换分支、撤消修改下面文中是 -- 两个杠框是连在一起，中间没有空格，因为字体太小，所说中间给个空格看着明显一些。 1.切换分支1git checkout &lt;name&gt; 2.创建并切换分支12git checkout -b &lt;name&gt;这其实可以拆解成两步操作 -b 应该就是branch 3.撤销工作区修改实际就是“以旧换新”的操作有两种情况：1.如果未添加到暂存区，则把版本库中的最新版本覆盖2.如果已添加到暂存区，则把暂存区中的修改拿出覆盖 撤销工作区修改:1git checkout - - &lt;file&gt;清除全部 - - 不能丢，不然就成了上面的切换切支命令了:1git checkout - - . 4.连招假如有一个文件，做了修改，但是不确定后面的修改是不是想要的。先添加到暂存区中，过了一会这个修改是不想要的，想要把工作区的文件从暂存区撤回覆盖。12git add //放一份当前写到一半觉得没问题的放到暂存区中git checkout - - file //将 版本库 中的修改替换到 工作区中没有 add 的情况下，直接拿版本来覆盖本地，这样搞的话，之前工作区的文件的修改就没了。用这招就看之前修改要不要了。1git checkout - - file","link":"/2016/09/06/git--checkout%E6%A3%80%E5%87%BA%E5%92%8C%E5%88%87%E6%8D%A2/"},{"title":"git push的一些总结","text":"git pull拉取并合并远程代码git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 1.拉取git pull origin fast:master把远程的next 分支 拉到 本 master。 2.拉取到当前分支git pull origin fast省略定法，表示拉取并合并自当前分支 3.等价上面的操作git fetch origingit merge origin/fast 4.手动建立跟踪跟踪不是只能跟踪 master，可以指定本地和远程不同的分支。意义在于可以使用简化命令 git push/pull，而不需要显示指定的版本库。git branch –set-upstream master origin/fastgit branch –set-upstream develop origin/develop","link":"/2016/08/07/git-push%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"},{"title":"git制造冲突","text":"冲突来源于合并不同分支的 commit 是不会产生冲突的，因为 commit 提交到的是当前分支的 本地库。只有将分不同分支的本地库进行合并才会产生冲突。所以： 合并本地库会产生冲突 拉远程分支的代码也会产生冲突 通常产生的情况： 两个人写同一个文件就可以先提交的不会有冲突，后拉取的会有冲突 同一个机器，不同分支，写同一个文件，也可以产生冲突 制造方法：A 、B 两分支操作同一个文件的同一行代码。A 分支 commitB 分支 commit B 合并 A，就会产生冲突","link":"/2017/06/24/git-%E5%88%B6%E9%80%A0%E5%86%B2%E7%AA%81/"},{"title":"git 取消跟踪","text":"取消跟踪 未提交文件忽略1git rm --cached FILENAME 这样就可以了，如果后面跟的是目录就加上个 -r 就行了（这个操作不会删除这个文件）1git rm -r --cached DIR 已提交文件忽略已经维护起来的文件即已经 commit 后的文件，即使加上了gitignore，也无济于事。用下面这个命令：1git update-index --assume-unchanged logs/*.log","link":"/2017/06/25/git-%E5%8F%96%E6%B6%88%E8%B7%9F%E8%B8%AA/"},{"title":"idea 自定义注释","text":"日常开发当中，开发规范要求每个开发人员做到要必要的代码上加上注释。借助IDE可以快速的生成这些注释。 1.文件头部注释每次创建新文件时会自动添加到文件头settings—Editor—&gt;File and Code Templates—&gt;Includes 即是，不过这里设值类似Eclipse用 ${ } /** * * @author ${USER} * @data ${DATE}. */ 2.方法注释idea 做的相当不错的，可以根据自定义注释名称来生成自己设定的注释settings—Editor—&gt;Live Templates—&gt; 点 + 创建 Template Group —&gt;再点 + 创建 Live Temp剩下的不用看也明白了，这里做一个模板：Abbreviation 是自定义快捷语，在代码中输入自定义名称回车就能出来。define 选择注释生效的范围 /** * method: * description: * @author $user$ * @data $data$ $time$ * $parameter$ * @return $return$ */ Edit variables 中编辑对应的值 多行需要在方法内部就可以实现，方法外部参数就是出不来。好 low 3.多行需要在 $parameter$ 的变量设置这面这行 groovy 脚本写在 Default Value 里： groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++) {result+='@param ' + params[i] + ((i &lt; params.size() - 1) ? '\\\\n\\\\b' : '')}; return result\", methodParameters())","link":"/2018/07/29/idea--%E6%B3%A8%E9%87%8A%E6%A8%A1%E6%9D%BF/"},{"title":"idea 设置编译版本无效问题解决","text":"idea 编译总是1.5处理使用 idea 时会碰到在 Project Structure 中设置了编译版本为 1.8 时，重新编译过后查看，还是1.5的问题，怎么都改不过来。这是因为 maven 的 compiler 工具的问题，两种解决方式。 1.指定 comipler 的编译版本12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 2.同理，只是在放在 properties 标签当中更简单的解决 idea 编译为 1.5 的问题1234&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt; 两种方式都可以解决 idea 设置无效的问题。","link":"/2018/07/28/idea--%E8%A7%A3%E5%86%B3idea%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3/"},{"title":"ConfigurationProperties 和 EnableConfigurationProperties 的区别","text":"@EnableConfigurationProperties测试发现 @ConfigurationProperties 与 @EnableConfigurationProperties 关系特别大。 @EnableConfigurationProperties 文档中解释：当@EnableConfigurationProperties注解应用到你的@Configuration时， 任何被@ConfigurationProperties注解的beans将自动被Environment属性配置。 这种风格的配置特别适合与SpringApplication的外部YAML配置进行配合使用。 测试发现：1.使用 @EnableConfigurationProperties 进行注册123456789101112131415161718192021222324252627282930@ConfigurationProperties(prefix = &quot;service.properties&quot;)public class HelloServiceProperties { private static final String SERVICE_NAME = &quot;test-service&quot;; private String msg = SERVICE_NAME; set/get}@Configuration@EnableConfigurationProperties(HelloServiceProperties.class)@ConditionalOnClass(HelloService.class)@ConditionalOnProperty(prefix = &quot;hello&quot;, value = &quot;enable&quot;, matchIfMissing = true)public class HelloServiceAutoConfiguration {}@RestControllerpublic class ConfigurationPropertiesController { @Autowired private HelloServiceProperties helloServiceProperties; @RequestMapping(&quot;/getObjectProperties&quot;) public Object getObjectProperties () { System.out.println(helloServiceProperties.getMsg()); return myConfigTest.getProperties(); }} #自动配置设置1234service.properties.name=my-test-nameservice.properties.ip=192.168.1.1service.user=kayleservice.port=8080 一切正常，但是 HelloServiceAutoConfiguration 头部不使用 @EnableConfigurationProperties，测访问报错。 2.不使用 @EnableConfigurationProperties 进行注册，使用 @Component 注册12345678910111213141516@ConfigurationProperties(prefix = &quot;service.properties&quot;)@Componentpublic class HelloServiceProperties { private static final String SERVICE_NAME = &quot;test-service&quot;; private String msg = SERVICE_NAME; public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; }}Controller 不变，一切正常，如果注释掉 @Component 测启动报错。由此证明，两种方式都是将被 @ConfigurationProperties 修饰的类，加载到 Spring Env 中。","link":"/2018/07/26/java--EnableConfigurationProperties%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"List分类算法","text":"对一个 List 里面相同属性的内容进行分类，如：对相同部门的员工进行分类。思路是使可以区分类型的属性进行分类，以部门类型为例。 1234567891011121314151617List&lt;Devloper&gt; devlopers = new ArrayList&lt;&gt;();devlopers.add(new Devloper(1, &quot;嗯哼&quot;, 1));devlopers.add(new Devloper(2, &quot;啊哈&quot;, 1));devlopers.add(new Devloper(3, &quot;哦吼&quot;, 1));devlopers.add(new Devloper(4, &quot;呃呵&quot;, 2));devlopers.add(new Devloper(5, &quot;呜唿&quot;, 2));Map&lt;Integer, List&lt;Devloper&gt;&gt; devloperMap = new HashMap&lt;&gt;();for (Devloper devloper: devlopers) { if (devloperMap.containsKey(devloper.getDept())) { devloperMap.get(devloper.getDept()).add(devloper); } else { List&lt;Devloper&gt; devs = new ArrayList&lt;&gt;(); devs.add(devloper); devloperMap.put(devloper.getDept(), devs); }} 结果：1234567891011{1=[ Devloper{id=1, name='嗯哼', dept=1}, Devloper{id=2, name='啊哈', dept=1}, Devloper{id=3, name='哦吼', dept=1} ], 2=[ Devloper{id=4, name='呃呵', dept=2}, Devloper{id=5, name='呜唿', dept=2} ]}","link":"/2015/07/22/java--List%E5%88%86%E7%B1%BB%E7%AE%97/"},{"title":"几个 String 的知识点","text":"String 类不可变字符对象。所以每次String对象的改变实际是创建了一个新对象。String 是 final 的也不能被继承。12345678String test1 = new String(&quot;ABCD&quot;);String test2 = &quot;ABCD&quot;; //通过字符串常量创建一个String对象。String test3 = &quot;ABCD&quot;;test3 += &quot;EFGH&quot;; //创建了一个新的String对象。StringBuilder test4 = new StringBuilder(test3);System.out.println(test1==test2);System.out.println(test1.equals(test2)); 由于String每次相加时都是创建一个新对象，所以尽量避免创建大是的String对象。比如：123for (int i = 0; i &lt; 1000; i++) { test1 += test1;}如果非得用这种方式的话，尽量用StringBuild来创建。123for (int i = 0; i &lt; 1000; i++) { test4.append(&quot;xxxx&quot;);} 防乱码处现如果IO流中有泛及到中文，那肯定有乱码问题。处现方式：1234if(&quot;teachername&quot;.equals(fileItem.getFieldName())){ String value = fileItem.getString(); teacherName = new String(value.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);} 空窜注意在使用split切割后判断字符串空串时，要注意，” “一个空格不能用一个空格” “来判断，而是用”” 无任何空格的空串来进行判断才能成功。便是单个string判断空串确没有问题？？？12345678String str = &quot;aa bb ccc ddd&quot;; String[] newStr = str.split(&quot; &quot;); System.out.println(Arrays.toString(newStr)); for(String str2 : newStr){ if(!&quot;&quot;.equals(str2)){ System.out.println(str2); }} 结果： [aa, bb, , , ccc, , , , , , , ddd] aa bb ccc ddd","link":"/2015/07/22/java--String%E7%B1%BB%E7%9B%B8%E5%85%B3/"},{"title":"spring boot 中使用 hibernate validate 校验","text":"spring boot 中使用 Hibernate validate 进行入参字段校验，一般用于web 接口入参校验，用起来非常方便。 spring boot 的配置123456789101112131415161718192021222324252627282930313233343536373839404142import org.hibernate.validator.HibernateValidator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.ValidatorFactory;@Configurationpublic class ValidatorConfiguration { @Bean /** * Method: 开启快速返回 * Description: * 如果参数校验有异常，直接抛异常，不会进入到 controller，使用全局异常拦截进行拦截 * Author: liu kai * Date: 2018/7/12 17:33 * * @param * @return org.springframework.validation.beanvalidation.MethodValidationPostProcessor */ public MethodValidationPostProcessor methodValidationPostProcessor() { MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor(); /**设置validator模式为快速失败返回*/ postProcessor.setValidator(validator()); return postProcessor; } @Bean public Validator validator(){ ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class ) .configure() .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; ) .buildValidatorFactory(); Validator validator = validatorFactory.getValidator(); return validator; }} controller 中使用使用步骤: 在 controller 类上 @Validated BindingResult result 这个不能省，必须要有，测试不加不行。 @Valid 加上这个注解 123456789101112131415161718@Validatedpublic class NewsInfoController { /** * Method: 添加新闻 * Description: * Author: pan ying * Date: 2018/6/13 17:43 * * @param newsRequestVo * @return com.reapal.openapi.web.vo.ResultVo */@RequestMapping(value = &quot;/save&quot; ,method={RequestMethod.POST,RequestMethod.GET})@ResponseBodypublic ResultVo saveNewsInfo(@RequestBody @Valid NewsRequestVo newsRequestVo, BindingResult result){ ResultVo resultVo = new ResultVo(); newsInfoBusiness.insert(newsRequestVo); return resultVo;} 实体类中使用12345678910111213public class NewsInfo implements Serializable { private static final long serialVersionUID = 3148176768559230877L; /** id */ private String id; /** 新闻编号 */ private String newsNo; /** 标题 */ @NotNull @Length(max=30, message=&quot;长度超过限制&quot;) private String title;}","link":"/2018/08/03/java--hibernate-validate%E4%BD%BF%E7%94%A8/"},{"title":"你为什么学不会lambda","text":"这个一篇对学习 Lambda 表达式进行解惑的文章，主要是总结了自己在学习 Lambda 表达式时候的一些理解不了的坑进行总结。长篇大论和详细语法，自行谷歌，这里只说一些理解起来不顺的概念。 重要事情说三遍123首先 Lambda 表达式 ()-&gt;{ } 是一种方法实现，并且在直接调用的时候才会执行。首先 Lambda 表达式 ()-&gt;{ } 是一种方法实现，并且在直接调用的时候才会执行。首先 Lambda 表达式 ()-&gt;{ } 是一种方法实现，并且在直接调用的时候才会执行。 1. 什么是 ()-&gt;{ }理论造航母，程序就一行。不提什么是函数式编程，用大白话，其实就是写了一个匿名实现，并且在需要使用这行匿名实现的时候调用了一下，才会直正去执行这个匿名实现方法。Lambda 表达式，本质上是一种延迟加载执行。将预先写好的实现方法进行加载。到实际使用时，再执行。 演示执行过程：1.声明一个 Lambda 表达式接口2.加载一下匿名实现方法3.执行一下 新建一个类，声明一个 Lambda 表达式接口12345@FunctionalInterfacepublic interface MyFunctional&lt;T&gt; { //只允许存在一个 public abstract 方法 boolean test(T t);} 新建一个测试类，加载一下匿名函数实现用来测试 Lambda 表达式的执行顺序123456789101112131415161718public class MethodReference { public static void main(String[] args) { //1. 一般匿名写法，这里仅是声明了这个匿名写法，但是并没有执行任务操作 testRef((test) -&gt; { System.out.println(String.format(&quot;3. lambda 接口调用方法时传入的参数: %s&quot;, test)); System.out.println(&quot;4.bbb&quot;); return test; }); } public static void testRef(MyFunctional myFunctional) { System.out.println(&quot;1. 到这一步，lambda 表达式还没有执行&quot;); System.out.println(&quot;2. 传入一个参数&quot;); // 2. 真正的去调用 lambda 表达式的实现方法 myFunctional.say(&quot;aaa&quot;); }} 执行结果：12341. 到这一步，lambda 表达式还没有执行2. 传入一个参数3. lambda 接口调用方法时传入的参数: aaaa4. bbb 用 IDEA 到 Functional 接口中点一下，可以看到，直接跳到 MethodReference 这个测试为的这一行 lambda 表达式中，也就是说，当有一个 lambda 表达式实现了 Functional 接口时，并通过以当前 Functional 为形参的方法传入时，可以被调用到。","link":"/2019/04/14/java--%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B8%8D%E4%BC%9Alamdbd/"},{"title":"竞态条件 racing condition","text":"多个线程读时，线程是安全的。当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。我的理解，竞态条件就是一种情况。 代码实现假设有 A、B 两个线程，调用 add 方法分别传入 1 和 2，理想条件下结果应该是 3。现在出现了不安全的情况，有可能结果不对。add 方法就是临界区，count 就是同一资源。 123456class Counter { protected long count = 0; public void add(long value) { this.count = this.count + value; } } 其实这样一看，说白了，就是要严格控制线程的执行顺序，假设是按A、B的顺序执行来讲，B依赖于A先执行完成，B再执行结果才是正确的，中间不能出现问题，否则如果，中间交叉执行，就有可能发生了竞态条件。","link":"/2017/09/30/java--%E5%A4%9A%E7%BA%BF%E7%A8%8B--%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6/"},{"title":"引用级别","text":"引用级别意义：用来标记对角是否可以被回收级别：强 &gt; 软 &gt; 弱 &gt; 虚 1.强引用即一般普通的引用。如果一个对象是强引用，绝对不会被回收，即使内存空间不足也不会被回收，而是抛 OutOfMemoryError 异常使程序终止。例1：123String str = &quot;abc&quot;;List&lt;String&gt; list = new Arraylist&lt;String&gt;();list.add(str);在list集合里的数据不会释放，即使内存不足也不会 例2：1Object obj = new Object(); //可直接通过obj取得对应的对象 如obj.equels(new Object());而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这是经常用到的编码形式。 2.软引用非必须引用，如果空间不足就会被GC回收。换句话说，在内存溢出之前进行回收。只要没有被回收，该对象就可能被程序使用。软引用可用来实现内存敏感的高速缓存。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。1234567public void testSofeReference() { Object obj= new Object(); SoftReference&lt;Object&gt; softReference = new SoftReference&lt;Object&gt;(obj); obj = null; System.out.println(softReference.get()); //有时候会返回 null System.out.println(softReference.isEnqueued()); //返回时否被 GC 回收的标记}这时候 softReference 是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。 3.弱引用第二次圾垃回收时，被回收 4.虚引用垃圾回收时回收，无法通过引用取到对象值","link":"/2017/03/04/java--%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/"},{"title":"抽象类总结","text":"抽象意义：抽出象的部分 抽象类可以没有抽象方法，但是有抽象方法的类必须定义为抽象类。 static 与 abstract 不能同时修饰一个方法。因为abstract的语义就是说这个方法是抽象方法，需要子类去实现。而static方法则是在本类中实现的，编译期绑定，不具有多态行为。 抽象方法必须存放在抽象类中。 不能用new去创建抽象对象，因为抽象类没有具体的方法体，创建没有意义。所以可以被继承，不能被实例化。 抽象类和抽象方法都必须用abstract修饰。 抽象类中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立子类对象的调用。如果子类只覆盖部分抽象方法，那么该子类是一个抽象类。如果子类想不成为抽象类，那必须复写所有的父类的抽象方法。也就是说父类的抽象方法，可以只实现部分，但那样自己就必须改变成抽象类。 如果子类没有全部重写父类的所有方法，则子类自已也需要变成抽象类，要用abstract修饰，那么子类将不能被实例化。反之则可以。","link":"/2014/12/29/java--%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%80%BB%E7%BB%93/"},{"title":"有状态和无状态对象","text":"这个概念在多线程中一直被提及，实际上很简单。1.有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 2.无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象，不能保存数据，是不变类，是线程安全的。 3.引用无状态的对象，则自己也可以是线程安全的1234public class StatelessBeanService { // 虽然有billDao属性，但billDao是没有状态信息的，是Stateless Bean. BillDao billDao;}","link":"/2016/04/02/java--%E6%9C%89%E7%8A%B6%E6%80%81%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E5%AF%B9%E8%B1%A1/"},{"title":"解决 Cannot determine embedded database driver class for database type NONE","text":"刚搭的新项目一启动就报错，一直就知种起不来。各种搜索以后总结两种解决方式。先看错误：1234567Description:Cannot determine embedded database driver class for database type NONEAction:If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active). 处理方式一：排除两个默认配置1@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})结论：没用 处理方式二： 可行网上说各种多于的依赖导至的问题，经过排查，确实是由 pagehelper 这个依赖引起的。123456789101112131415161718192021222324&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;org.hibernate&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;4.2.0.Final&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;1.1.1&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt;&lt;!--pagehelper--&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;1.1.2&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;mysql&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;5.1.21&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt; 总结：程序启动类不需要排除任务一个类，只需要去除引用却可。 其他思路http://www.cnblogs.com/kmsfan/p/7189626.html","link":"/2018/07/26/java--%E8%A7%A3%E5%86%B3database-driver-class-for-database-type-NONE/"},{"title":"final 的一些总结","text":"final 的含义是最终的、不可改变的。总结了一下 final 的一些规则。 修饰”类”则类不能被继承，所以没有子类，final类中的方法默认是final的。可以提高效率。JDK中很多加final是这个原因的。编译期确认调哪个方法，所以更快。1.5以后这样做没有效果。 修饰”方法”则方法不能被重写, 修饰”成员变量”则变量不以被改变，即被修饰成了常量。只能被赋值一次。 不能修饰构造方法 父类中的private成员方法是不能被子类覆盖的，因为private类型的方法默认是隐式final类型的 final 的引用不能指向新的对象。 形参声明为 final，则方法内不能再改变其： 基础数据类型值不可被修改 传入对象不能再被 new 继承关系时，final 的方法将不会被子类重写。所以父类使用的仍是本类自己的方法。 final 类不可被继承。","link":"/2016/06/02/java-final%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"},{"title":"NIO概述","text":"服务器实现模式为一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 Java NIO（Non-blocking / New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO 和 IO 的区别在于，IO 是面向流，NIO 是面向缓存。是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。 传统面向流的，单向的。三个核心组件 Channels Buffers Selectors 1.Channels 负责传输白话: 就是数据传输用的通道。作用是打开到IO设备的连接，文件、套接字都行。绕绕话: 标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 2.Buffers 负责存储缓冲区，用来存放具体要被传输的数据，比如文件、scoket 等。这里将数据装入 Buffers 再通过通道进行传输。 3.Selector负责监听事件和选择对应事件的渠道。 NIO 主要的编程模型来自 Reactor ReactorNIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。 NIO 是一种可以替代 Java IO API 的新API，提供了与标准 API 不同的工作方式。BIO是一个连接一个线程。NIO是一个请求一个线程。AIO是一个有效请求一个线程。三种IO 的区别Java BIO:同步并阻塞服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 Java NIO: 同步非阻塞服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 Java AIO(NIO.2) :异步非阻塞服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处。 BIO、NIO、AIO适用场景分析:BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。","link":"/2019/11/01/java-nio-1-NIO%E6%A6%82%E8%BF%B0/"},{"title":"nio和bio的区别","text":"BIO 和 NIO 的区别 BIO 好比是通道传输，一来一回 NIO 好比是管道传输，一堆来一堆回。 BIO 模型1234567________ _________| |-----------------------| || |-----------输入--------| || | | || |-----------输出--------| || |-----------------------| ||-------| |-------|输入和输出都需要建立一条管道。 也就是说，数据的传输是单向的，出去从输出流通道走，回来从输入流通道走。 面向流，通道传输的是流 NIO 模型1234567_________ _________| |-----------------------| || | | || | 输入-输出 | || | | || |-----------------------| ||-------| |-------|NIO 的通道没有传输数据的能力，通道的建立，相当于铺了铁路，而数据的传输需要火车。火车指的就是缓冲区。火车出发前会装一批人，而不会只装一个人。火车来回都只用一条通道。面向缓冲区，将数据装入缓冲区，由缓冲区进行传输。","link":"/2018/02/14/java-nio-nio%E5%92%8Cbio%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"socket01-原理","text":"原理网络之间的通信，说穿了还是流在通信。客户端跟服务器之间建立的管道，就叫scoket。网络通信的三要素：1.IP2.端口3.协议 网络编程也需要输入流和输出流进行交互，交互步骤：1.使用ServerSocket 指定端口，地址为本机。2.使用accept 接收客户端连接。3.发送数据（流）。 注意：1024以下端口保留给系统。 TCP/UDP1.TCP:像打电话，双向的，建产连接的。数据安全，不易丢失。点对点。2.UDP:像发知信，单向的，非面向连接。数据不安全，易丢失。","link":"/2015/01/11/java-socket01-%E5%8E%9F%E7%90%86/"},{"title":"socket02-ServerSocket 服务端","text":"ServerSocket是运行的服务端的ServerSocket。socket方式是点对点的属于TCP。 建立服务端频骤： 建立端口并指定服务器IP 使用 accpet 方法接收连接，阻塞式方法 使用流通信 代码实现： 建立服务器，建立通道对象 接收数据 发送数据 阻塞式的意思是，如果没有连接，就会一直等待。所以在while里面是一直处于等待状态。 1234567891011121314151617181920212223242526272829public static void main(String[] args) throws IOException { //1.创建服务器套接字 ServerSocket serverSocket = new ServerSocket(8888); BufferedWriter bf = null; Socket socket = null; DataInputStream date = null; String welcom = &quot;欢迎使用我的宇宙无敌服务器&quot;; while(true){ //2.建立连接，这只是建立连接，并不是接收客户端发来的信息，就像按电话的接听键 socket = serverSocket.accept(); // 阻塞式的接收方式 System.out.println(&quot;Server: &quot; + welcom); //3.逐行写出给客户端 bf = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream() // 从socket中获取数据 )); bf.append(welcom); bf.newLine(); // 一定要换行，相当于\\r\\n bf.flush(); //4.接收客户端发来的信息 date = new DataInputStream(socket.getInputStream()); String message = date.readUTF(); System.out.println(message); }}","link":"/2015/01/15/java-socket02-ServerSocket%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"title":"springboot打war包","text":"spring boot 在内置了 tomcat，但是会使用到外置 tomcat 的情况。在使用外置 tomcat 时需要让 spring boot 的打包方式打成 war 包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;build&gt; &lt;finalName&gt;fund&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;packagingExcludes&gt;**/env/**&lt;/packagingExcludes&gt; &lt;archive&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources/env/${env}&lt;/directory&gt; &lt;targetPath&gt;WEB-INF/classes&lt;/targetPath&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--打包参数--&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;qa&lt;/id&gt; &lt;properties&gt; &lt;env&gt;qa&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;env&gt;prod&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt;","link":"/2018/08/04/java-springboot%E6%89%93war%E5%8C%85/"},{"title":"socket03-Socket 客户端","text":"Soket客户端可以用来连接服务器 1.连接步骤： 建立连接 使用I/O 学节流进行交互 2.代码实现：12345678910111213141516171819public static void main(String[] args) throws IOException { //1.建立服务器连接 Socket client = new Socket(&quot;localhost&quot;,8888); //2.获取服务器传来的数据 BufferedReader bf = new BufferedReader( new InputStreamReader( client.getInputStream() )); String getMessage = bf.readLine(); //阻塞式 System.out.println(getMessage); //3.客户端向服务器发送 DataOutputStream ds = new DataOutputStream(client.getOutputStream()); ds.writeUTF(&quot;client: 获取到了服务器连接&quot;); ds.flush(); ds.close();}","link":"/2015/01/17/java-socket03-Socket%20%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"title":"产生线程死锁的原因和处理方式","text":"产生背景线程同步(就是加锁)会有一个问题，就是产生死锁 所谓死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。发生死锁的具体原因如下: 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当。 举列说明场景:死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。 123456789101112131415161718背景: 线程同步(就是加锁)会有一个问题，就是产生死锁所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。帮助理解：地上放着两个桶泡面，一个老坛酸菜，一个小鸡炖磨茹。两个人一个产品，一个测试，同时出发去抢老坛酸菜和小鸡炖磨茹，产品老坛酸菜，测试拿到小鸡炖磨茹，同一时刻，产品伸要去拽测试怀里的小鸡炖磨茹，测试伸手去拽产品的老坛酸菜，两个僵持不下，就死在那了，叫死锁。如果没有开发将他们各打一顿解救出来，它们奖无法推进下去。发生死锁的具体原因如下:1. 因为系统资源不足。2. 进程运行推进的顺序不合适。 3. 资源分配不当。举列说明场景:死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。死锁预防如果只使用一个锁就不会有死锁的问题，不过复杂场景下不太理实。1.以确定的顺序获得锁 线程A ---&gt; 锁定 A ----&gt; 偿试锁定 B 线程B ---&gt; 锁定 A ----&gt; 偿试锁定 B 这样就不会发生死锁2.超时放弃Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。","link":"/2019/04/20/java-%E4%BA%A7%E7%94%9F%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"},{"title":"使用freemarker页面静态化","text":"公司使用 vue + ngixn 前后端分离架构，重构一套新的静态化的门户网站。后台管理系统为动态页面。使用 freemarker 进行页面静态化的处理，生成静态化页在。前后分离的页面，静态图片需要使用 nginx 进行路径转换。UEditor 上传到本地的图片，没有使用文件管理系统，直接存放到服务器本地，需要 nginx 进行路径转换。 使用原理:1.freemarker 将数据填充入 ftl 模板中，再由 freemarker 生成静态页面2.vue 获取静态页面进行数据展示 1.工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import freemarker.template.Configuration;import freemarker.template.Template;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import java.io.*;import java.util.Map;/** * Title: 工具类 * Description: * * @author liukai * @date 2018/6/20 上午10:37. */@Componentpublic class CreateHtmlUtil { private static final Logger LOGGER = LoggerFactory.getLogger(CreateHtmlUtil.class); @Value(&quot;${htmlPath}&quot;) private String htmlPath; @Value(&quot;${ftlPath}&quot;) private String ftlPath; /** * 通过freemarker生成静态HTML页面 */ public void createHtml(String templateName,String targetFileName,Map&lt;String, Object&gt; map) throws Exception{ LOGGER.info(&quot;生成路径: {}, 模板路径：{}&quot;, htmlPath, ftlPath); //创建fm的配置 Configuration config = new Configuration(); //指定默认编码格式 config.setDefaultEncoding(&quot;UTF-8&quot;); Template template = null; //设置模版文件的路径 try { config.setDirectoryForTemplateLoading(new File(ftlPath)); //获得模版包 template = config.getTemplate(templateName); } catch (Exception e) { LOGGER.info(&quot;设置模板包异常：{}&quot; + e.getMessage()); } //定义输出流，注意必须指定编码 try (FileOutputStream fileInputStream = new FileOutputStream(new File(htmlPath+&quot;/&quot;+targetFileName)); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileInputStream, &quot;UTF-8&quot;); Writer writer = new BufferedWriter(outputStreamWriter)) { template.process(map, writer); LOGGER.info(&quot;写入html&quot;); } catch (Exception e) { LOGGER.info(&quot;生成异常: {}&quot;, e.getMessage()); } }} 2.添加填充数据据123456789private void generateHtml (Integer CategoryNo, int count, Map&lt;String, Object&gt; pageMap) { try { String htmlFileName = getHtmlFileName(CategoryNo, count + 1); LOGGER.info(&quot;html 文件名: {}&quot; , htmlFileName); createHtmlUtil.createHtml(NEWS_TEMPLATE, htmlFileName, pageMap); } catch (Exception e) { e.printStackTrace(); }} 3.静态页面12345678910111213141516171819202122232425262728293031323334&lt;input type=&quot;hidden&quot; id=&quot;total&quot; value=&quot;${total}&quot;/&gt;&lt;#if newsPageDatas??&gt; &lt;#list newsPageDatas as key&gt; &lt;div class=&quot;new-item-box clearfix clear&quot;&gt; &lt;div class=&quot;image fl&quot;&gt; &lt;img src=&quot;&lt;#if key.titleUrl??&gt;${key.titleUrl}&lt;#else &gt;../images/news-1.png&lt;/#if&gt;&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item-content-box&quot;&gt; &lt;div class=&quot;item-content&quot;&gt; ${key.title!''} &lt;/div&gt; &lt;div class=&quot;item-time-arrow clearfix&quot;&gt; &lt;div class=&quot;item-time&quot;&gt; &lt;div class=&quot;item-time-day&quot;&gt; &lt;#if key.publishDate??&gt; ${key.publishDate?string(&quot;dd&quot;)!} &lt;/#if&gt; &lt;/div&gt; &lt;div class=&quot;item-time-year&quot;&gt; &lt;#if key.publishDate??&gt; ${key.publishDate?string(&quot;yyyy.MM&quot;)!} &lt;/#if&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;a href=&quot;../page/news_details_${key.id}.html&quot;&gt; &lt;img src=&quot;../images/jiantou.png&quot; alt=&quot;&quot;&gt; &lt;/a &gt; &lt;/div&gt; &lt;/div&gt; &lt;/#list&gt;&lt;/#if&gt;","link":"/2018/10/06/java-%E4%BD%BF%E7%94%A8freemarker%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96/"},{"title":"java-多线程-使用wait-notify简单示例","text":"网上有很多关天 wait 、notify 的使用 一、 二、先 wait 再等待唤醒1234567891011121314151617181920212223242526272829303132333435public class SimpleWaitTest implements Runnable { private Object object; public SimpleWaitTest(Object object) { this.object = object; } @Override public void run() { testMethod(object); } public void testMethod(Object lock) { synchronized (lock) { try { System.out.println(&quot;testMethod begin &quot; + Thread.currentThread().getName()); //1. 锁住自己 lock.wait(); System.out.println(&quot;testMethod be notify &quot; + Thread.currentThread().getName()); //4.唤醒 wait 线程 lock.notify(); } catch (InterruptedException e) { e.printStackTrace(); } } } public void setObject(Object object) { this.object = object; }} 三、唤醒等待线程后，wait 住，等待唤醒12345678910111213141516171819202122232425262728293031323334public class SimpleWaitTest implements Runnable { private Object object; public SimpleWaitTest(Object object) { this.object = object; } @Override public void run() { testMethod(object); } public void testMethod(Object lock) { synchronized (lock) { try { System.out.println(&quot;testMethod begin &quot; + Thread.currentThread().getName()); //1. 锁住自己 lock.wait(); System.out.println(&quot;testMethod be notify &quot; + Thread.currentThread().getName()); //4.唤醒 wait 线程 lock.notify(); } catch (InterruptedException e) { e.printStackTrace(); } } } public void setObject(Object object) { this.object = object; }}","link":"/2016/06/11/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%BD%BF%E7%94%A8wait-notify%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"},{"title":"如何停止一个线程","text":"使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 使用interrupt方法中断线程。 不推荐使用 stop、suspend及resume 方法。相当于电脑断电关机一样，是不安全的方法。 使用退出标志线程当中一般都会写循环，如果不写循环，一句话能搞定的事，就没必要再开线程来处理。stop方法已经过时， run方法结束。开启多线程时，运行代码通常是循环结构，只要控制住循环，就可以让run方法结束，也就是线程结束。原理：只要循环终止了，线程也就终止了。 1234567891011121314public class StopThread implements Runnable{ private volatile boolean flag = true; @Override public void run() { while (flag) { System.out.println(Thread.currentThread().getName() + &quot;...run&quot;); } System.out.println(&quot;...stop&quot;); } public void set() { flag = false; }} 使用了一个关键字 volatile，保证当前 flag 在多核CPU 下的可见性。 1234567891011121314151617181920package com.liukai.thread.stop;public class MyThread extends Thread { public void run(){ super.run(); try { for(int i=0; i&lt;5000; i++){ if (i == 100) { System.out.println(&quot;主动中断线程&quot;); Thread.currentThread().interrupt(); } System.out.println(&quot;i=&quot;+(i+1)); Thread.sleep(100); } } catch (InterruptedException e) { e.printStackTrace(); } }}","link":"/2017/04/09/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B/"},{"title":"模拟线程不安全","text":"由于线程在执行的时候是异步的，当所有线程操作共享数据时，有可以能出现都已经进入判断的情况下，共享数据已被改变，但是其后线程不知道，当线程醒来的时候，直接开始运行，这样就会出现数据不全安的问题。错误原因：多条语句操作一个共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导到共享数据的错误。 测试类12345678910DemoRunnable run = new DemoRunnable();Thread t1 = new Thread(run);Thread t2 = new Thread(run);Thread t3 = new Thread(run);Thread t4 = new Thread(run); t1.start();t2.start();t3.start();t4.start(); 实现类12345678910111213141516171819202122public class DemoRunnable implements Runnable { private int ticket = 100; @Override public void run() { boolean flag = true; while (flag) { if (ticket &gt; 0) { //线程进入判断后睡10豪秒 try { Thread.sleep(10); //让每一条进入的线程都sleep 10豪秒 ticket--; //ticket也可以放到sleep上面，结果也是错的。 System.out.println(ticket); } catch (InterruptedException e) { e.printStackTrace(); } } else { flag = false; } } } } 结果： //每次结果都是不一样的！！！切记。0-1-2-3 分析：上面的例子中有4条线程，4条进程都是在 ticket&gt;0 时进入。假设此时ticket为1，按1、2、3、4顺序执行的。线程1先 sleep 10豪秒，然后 ticket–后此时为0。线程2先sleep 10豪秒，然后 ticket–后此时为-1。线程3先sleep 10豪秒，然后 ticket–后此时为-2。线程4先sleep 10豪秒，然后 ticket–后此时为-3。由于是异步的，所以每次的错误并不一定是相同的。由于每次，线程都已进入了判断，而每次sleep异至线程在执行上，都走到了一起，然后配来后分别各自执行各自的代码，此时所有线程都已绕过了if的判断，所以出现了问题。一般CPU是交替执行线程的，但是每个线程被sleep后CPU就交换了执行权，当CPU再切换过来时，实际上次代码并没有执行完。","link":"/2014/08/16/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8/"},{"title":"简单说明 lock 锁和 Condition 的操作","text":"作用：使当前线程进入等待状，并交换执行执，等待被交换的当前执行线程唤醒，才可以继续执行，如果不被唤醒？场景：多个线程操作同一个共享资源时使用。 Condition 是执行条件。类似传统技术中的 wait 的 notify 功能。Condition 是基于一个 lock 而存在。注意的是，Condition 的创建来自同一个 lock 对象， Condition 也行 wait 也好，套路就是使用三个工具来完成三步套路。即，用两个线程，同时跑两个代码，并且用 while 不段的去读取一个条件，来判断自己是否应该唤醒对方。 步骤：1.先lock住2.通过 lock 拿到 condition。再进行操作如 await3.然后多个线程开始 await、single注意 await 会释放锁。1await()的作用是能够让其他线程访问竞争资源，所以挂起状态就是要释放竞争资源的锁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.liukai.thread.lock.condition;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by liukai on 2016/2/25. * 测试 Lock、Condition 代替 synchronized、wait * 例子来自 JDK Condition API 中的示例代码，阻塞队列的原理。 * 注间的是，两个不同的方法里面的 等待 和 唤醒 是不同的对象 */public class TestCondition { private final Lock lock = new ReentrantLock(); private final Condition full = lock.newCondition(); private final Condition notFull = lock.newCondition(); private int count = 0; private int takeptr = 0; private int putptr = 0; Object [] blockArray = new Object[100]; public static void main(String[] args) { final TestCondition condition = new TestCondition(); for (int i = 0; i &lt; 100; i++) { new Thread(()-&gt;{ try { condition.put(new Object()); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); new Thread(()-&gt;{ try { condition.take(); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } public void put (Object element) throws InterruptedException { try { lock.lock(); while (count == blockArray.length) { System.out.println(&quot;put: putptr = &quot; + putptr + &quot;, await&quot;); full.await(); //等待和唤醒用的不是同一个对象 } System.out.println(&quot;put: putptr = &quot; + putptr + &quot;, 执行 put&quot;); blockArray[putptr] = element; if (++putptr == blockArray.length) { putptr = 0; } ++count; notFull.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); Object data = null; try { while (0 == count) { System.out.println(&quot;take: takeptr == &quot; + takeptr + &quot;，await&quot;); notFull.await(); } System.out.println(&quot;take: takeptr = &quot; + takeptr + &quot;, 执行 take&quot;); data = blockArray[takeptr]; if (++takeptr == blockArray.length) { takeptr = 0; } --count; full.signal(); return data; } finally { lock.unlock(); } }}","link":"/2016/08/09/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8Elock%E9%94%81%E5%92%8CCondition%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"Parallel Scavenge 新生代收集器","text":"新生代，多线程，使用复制算法，是多线程的并行的收集器。目标：达到一个可控的吞吐量(Throughput)。吞吐量：CPU用于运行代码时间 与 CPU总消耗时间的 比公式： 吞吐量 = 运行代码时间 / ( 运行代码时间 + GC时间）虚拟机运行 100 分钟，GC用掉1分钟，则吞吐量为99%。 100 /(100 + 1) = 0.99 1.停顿时间越短越好-XX:MaxGCPauseMillis： 最大GC停顿时间，最小可为0-XX:GCTimeRatio: 吞吐量大小,1-100 2.停顿时间与空间成反比停顿时间越短，则新生代的空间就越小。通过减小新生代的空间，让里面的垃圾变少，从而加快了集速度。原来：500MB 垃圾，10秒收集一次，每次停顿100毫秒为了缩短时间，修改 -XX:MaxGCPauseMillis 参数，使新生代空间变小，产生的垃圾就少了，停顿时间短了：现在：300MB 垃圾，5秒收集一次， 每次停顿70毫秒。 那时问题来了，停顿时间下降了，但是频率高了，则吞吐量也跟着降下来了。 3.GC 时间占总时间的比例GCTimeRatio 进行这个设置1-100之间，相当于吞量的倒数。计算方法:1.设置为 19 则： 1 / (1 + 19) = 5%，即最大 5% 的收集时间2.设置为 99 则: 1 / (1 + 99) = 1%，即最大 1% 的收集时间","link":"/2017/06/26/jvm--Parallel-Scavenge-%E6%96%B0%E7%94%9F%E4%BB%A3%E6%94%B6%E9%9B%86%E5%99%A8/"},{"title":"分代的概念","text":"123堆，才有分代的概念。 堆，才有分代的概念。 堆，才有分代的概念。 1.为什么要有分代的概念，不分代行不行不分代完全可以，但是分代的唯一理由是为了优化GC性能。怎么优化？如果不进行分代，每次GC都要把整片堆扫一遍来寻找垃圾对象，太慢。分代直接把对象创建到某一个分代区，这样GC就可以针对这一分代区域就行优化，就不费劲了。 2.年轻代年轻代分三个部分： Eden 区，即新生对象区，除大对象以外。 Survivor 区，即幸存代，2个一对：s0 和 s1 分别也叫 from 和 to。默认比例8:1。 3.对象经历的过程： 新创建对象，分配到Eden区，除大对象特殊处理。 在 Eden 区经过一次GC后，如果仍存活，移到 Survivor。 在 Survivor 中又经历一次 GC，年龄会增加一岁。 年龄到一定程度，移到老年代。 4.年轻代使用什么GC算法是复制算法。为什么选复制算法？因为：年轻代中的80%以上的对象很快就死亡。所以，在年轻代的垃圾回收算法使用的是复制算法。即，将内存分为两块，每次中使用其中一块（Eden 和 From），当一块使用完，则将还存活的对象复制到别一块上。复制算法不会产生碎片。 5.From 和 to 区的复制过程对上一节的说明，演示复制的过程： 在 GC 开始的前，对象只会存在于 Eden区 和 From 区。为什么 From 区会有对象？ From区有对象很容易理解，开始发生 GC ,Eden 中的对象被复制到了 To 区中。 而 From 中的对象只有两个结果： 年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中。 没有到达的复制到 To 区中 这次 GC 后，Eden 和 From 被清空。此时，To 和 From 互相交换换角色，也就是说 To 变成 GC 前的 From，类推。 到现在清楚了，为什么 From 中也会有对象，因为第一次发生GC时复制过到 To 区后，交换角色而来的。 6.年轻代相关的JVM参数 -XX:NewSize和-XX:MaxNewSize 用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。 -XX:SurvivorRatio用于设置Eden和其中一个Survivor的比值，这个值也比较重要。 -XX:+PrintTenuringDistribution这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。 -XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。","link":"/2016/07/02/jvm--%E5%88%86%E4%BB%A3%E7%9A%84%E6%A6%82%E5%BF%B5/"},{"title":"Java 堆内存简介","text":"Java 堆 是虚拟机管理的最大的一块内存。是被所有线程所共享的一块内存区域，在虚拟机启动时创建。 1.分配内存方式：所有的实例和数组都在要堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导至一些变化，所有的对象都分配在堆上也变得不那么绝对。 Java 堆是垃圾收集器管理的主要区域，也叫CG堆。由于现在收集器基本都爱用分代收集算法，所以Java堆中还可以细分为：新生代 和 老年代。再细致一点的有 : Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的Java堆中可能划多个线程私有的分配缓存区。 如何划分与存放内容无关，无论哪个区域，存储的都仍然是对象实例。进一步划分的目的是为了更好的回收内存、或都更快的分配内存。 2.存放特点：Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像磁盘空间。堆的实现，即可固定大小，也可以扩展，通过 -Xms 和 -Xmx 控制。如果堆中没有内存实例分配，并助理堆无法再扩展时，抛出 OutOfMemoryError","link":"/2017/03/02/jvm--%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/"},{"title":"对象的创建","text":"这里指普通 Java 对象，而非数组 和 Class对象等。 1.创建对象的过程：new —&gt; 到常量池中检查是否存在一个类的符号引用 —&gt; 如果有，检查这个符号引用代表的类是否已被加载、解析、初始化 —&gt; 没有，则执行类加载过程。 2.分配对象类加载完毕后，为新生对象分配内存。对象所需内存大小在类加载完成后便完全确定。分配空间。即，从JVM堆中划出一块确定大小的内存空间。 3.分配方法有两种分配方法： 指针碰撞：使用这种方式的前提是，内存是规整的。左边是空闲的空间，右边是已使用的内存空间，用一块，就往左边移一块，就像秤砣在称中间移动一样。 空闲列表内存不规整，此时不能使用指针碰撞。JVM 就需要维护一个列表，记录哪些空间可用并给对象。 堆内存是否规整决定了使用哪种分配方法。而堆是否会规整则由GC是否带有压缩整理功能决定。 4.避免并发操作同一片内存的问题并发时，A线程 拿着指针在为对象分配 0x111111 这片空间，分配动作执行到一半，B线程 也进来了拿着同一个指针在同一个地址上分配空间。这就出现了问题。 解决方案： CAS 配置失败重试的方式保证更新操作的原子性。 为每个线程开一小块内存空间，称为本地内存分配缓冲(TLAB)。线程在自己的TLAB是分配。 5.初始化当分配完成后，JVM将分配到的内存空间开始进行初始化为 0 值(不包括对象头)，0值就是数学中的0。如果是TLAB方式，提前到TLAB中分配时进行。这就是使用对象时，程序访问某些字段的数据类型默认有0的原因。就可以不用赋值也可以使用。 6.必要设置接下来JVM对对象进行必要设置。设置如：对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、GC分代年龄等。这些信息存放在对象头中。对JVM来说，对象已分配完成，一个新对象就此产生。但从 java 程序的角度来说对象创建才刚开始。调用 init 方法前，所有字段都是默认的0。执行init方法，对象进行初始化，这样一个真正可用的对象才算完全产生。","link":"/2017/03/12/jvm--%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"},{"title":"循环引用示例","text":"见过一个问题说，如果java里的对象出现了循环引用，对象会不会被回收。结论是：会。因为 java 的对象存活算法，使用的是可达性分析算法，而不是引用计算法，java中任务一款GC都没有使用过引用计算法。 1234567891011public static void main(String[] args) throws IOException { A a = new A(); B b = new B(); a.bb = b; b.aa = a; //a = null; //b = null; System.in.read();}","link":"/2017/03/02/jvm--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%A4%BA%E4%BE%8B/"},{"title":"竟态条件 racing condition","text":"竟态条件 racing condition多个线程读时，线程是安全的。当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。我的理解，竞态条件就是一种情况。 代码示例假设有 A、B 两个线程，调用 add 方法分别传入 1 和 2，理想条件下结果应该是 3。现在出现了不安全的情况，有可能结果不对。add 方法就是临界区，count 就是同一资源。 123456class Counter { protected long count = 0; public void add(long value) { this.count = this.count + value; } } 其实这样一看，说白了，就是要严格控制线程的执行顺序，假设是按A、B的顺序执行来讲，B依赖于A先执行完成，B再执行结果才是正确的，中间不能出现问题，否则如果，中间交叉执行，就有可能发生了竞态条件。","link":"/2016/10/02/jvm--%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6%20racing%20condition/"},{"title":"Java 虚拟机简单理解","text":"与PC寄存器一样，Java虚拟机栈也是线程私有的。每一个JVM线程都有自己的java虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。 1.虚拟机栈的特点：“虚拟机栈”描述的是Java方法执行的内存模型： 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储:局部变量表、操作数栈、动态链接、方法出口等信息。(栈帧我的理解就是一个对象，用来存储信息用) 每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 2.局部变量表： 存放了8种基本数据 类型 对象引用 类型 returnAddress 类型 除64位 long 和 duble 占2个局部空间外，其余的数据类型只占1个。注意，局部变量表所需的内存空间在编译期间完成分配，所以进入某个方法时，这个方法需要在栈桢中分配多大的空间完全是确定的，在方法运行时是不会改变局部变量表的大小的。 3.虚拟机栈出现异常两种情况： 如果线程请求的深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常; 如果虚拟机进行动态扩展，而扩展时无法申请到足够的内存，则抛出 OutOfMemoryError 异常。 注，大部分 Java 虚拟机分为：固定长度 和 动态扩展 两种 4.关于动态扩展： JVM stack 可以被实现成固定大小，也可以根据计算动态扩展。如果采用固定大小的JVM stack设计，那么每一条线程的JVM Stack容量应该在线程创建时独立地选定。JVM实现应该提供调节JVM Stack初始容量的手段；如果采用动态扩展和收缩的JVM Stack方式，应该提供调节最大、最小容量的手段。 如果线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError；如果JVM Stack可以动态扩展，但是在尝试扩展时无法申请到足够的内存时抛出OutOfMemoryError。","link":"/2017/03/02/jvm--%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"},{"title":"server和client模式的区别","text":"这两个相反的，由jvm启动时自动选择。 -server 模式：初始空间大，默认启动并行 VM，启动慢，运行快 -client 模式：初始空间小，默认启动串行 VM，启动快，运行慢 一般情况下 -server 模式多 64位系统只能使用 server 模式 1234java -versionjava version &quot;11.0.2&quot; 2019-01-15 LTSJava(TM) SE Runtime Environment 18.9 (build 11.0.2+9-LTS)Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.2+9-LTS, mixed mode) 32位了解即可 测试 java -D 命令 -D 后面传入的命令，会解析成 System 中的属性 12345678910public static void main(String[] args) { //java -DtestJvm=test TestGetSystemProperties String test = System.getProperty(&quot;testJvm&quot;); if (null != test) { System.out.println(&quot;test -&gt;&quot; + test); } else { System.out.println(&quot;property is null&quot;); }} 3.启动选择模式java -client -showversion TestGetSystemProperties","link":"/2019/06/01/jvm-server%E5%92%8Cclient%E6%A8%A1%E5%BC%8F/"},{"title":"jvm 的局部变量表","text":"Java中方法的局部变量是放在虚拟机栈的局部变量表里面，形参也算一个。本地变量表，就是局部变量表，只是翻译不同。代码说明 12345public static void main(String[] args) { byte[] waste = new byte[6 * 1024 * 1024]; int new_var = 0; System.gc(); } 反编译得到：1234567891011public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=3, args_size=1 0: ldc #2 // int 6291456 2: newarray byte 4: astore_1 5: iconst_0 6: istore_2 7: invokestatic #3 // Method java/lang/System.gc:()V 10: return 结果：locals=3也就是说局部变量表长度是3.","link":"/2017/05/13/jvm-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/"},{"title":"linux-console-shell的一些常用命令","text":"linux 的命令行用了这么久的 linux 才开始整理这部分的内容，该罚站 1.删除ctrl + w 往回删除一个单词，光标放在最末尾 ctl + u 删除光标以前的字符，其实这个是剪切ctl + k 删除光标以后的字符 ctrl + y 粘贴由 Ctrl+u ， Ctrl+w 剪走的单词ctrl + d 从当前位置开始，向右边删除字符 2.清屏ctrl + l 清屏ctrl + c 另起一行 3.光标位置ctl + a 移动光标至的字符头ctl + e 移动光标至的字符尾ctrl + ? 撤消前一次输入 ctrl + s 锁住终端 //实际上只是不显示字符而已，命令照样执行。ctrl + q 解锁终端 4.历史和命令ctrl + r 输入单词搜索历史命令，超好用ctrl + o 重复执行命令 5.屏幕输出Ctrl+S 暂停屏幕输出Ctrl+Q 继续屏幕输出 6.上下翻屏这个是找了N久才查到的命令shift + pageUp/pageDown //纯linux console 下测试有效，但不能一翻到顶，网上说只能翻最近15页shift + home/end //只有 xshell 下可用shift + 上/下 //xshell 下可用 7.连续执行命令echo commond 1 ; echo commond 1 //不论前面成功失败，每条都会执行commond 1 &amp;&amp; commond 1 //第一条成功则后面执行commond 1 || commond 1 //第一条失败，才执行","link":"/2018/06/14/linux-console-shell%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-md/"},{"title":"CommandLineRunner 指定启动顺序","text":"这个实际是可以用来当用启动时加载某些程序，相当于以前的 static{ } 这种块。这种方式优雅的多。 123456789101112131415161718192021@Component@Order(value=1)public class Runner1 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;执行顺序 -&gt; 1&quot;); }}@Component@Order(value=2)public class Runner2 implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;执行顺序 -&gt; 2&quot;); }} 根据控制台结果可判断，@Order 注解的执行优先级是按value值从小到大顺序。","link":"/2018/07/21/springboot--CommandLineRunner%E6%8C%87%E5%AE%9A%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"},{"title":"getWriter() has already been called for this response 的解决办法","text":"注释部份为有问题的写法。 12345678910111213141516171819202122232425try { //有问题的部份 //PrintWriter out = null; //out = response.getWriter(); // String json = new ObjectMapper().writeValueAsString(map); //out.write(json); //out.flush(); //out.close(); outputStream = response.getOutputStream(); String json = new ObjectMapper().writeValueAsString(map); outputStream.write(json.getBytes()); outputStream.flush(); outputStream.close();} catch (IOException e) { LOGGER.error(e.getMessage(), e);} finally { if (outputStream != null) { try { outputStream.close(); } catch (IOException e) { e.printStackTrace(); } }}","link":"/2018/04/28/springboot--getWriter()-has-already-been%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"pagehelper报错解决方法","text":"先说结论如果使用的是 springboot 不能使用，4.1.x 和 5.1.x，而需要使用 pagehelper-spring-boot-starter 同事的新项目使用 Spring boot，之前是 SpringMVC 所以把直 pom.xml 直接复制过来，一跑就报各种错，各种谷歌百度都不管用。查看 pom 依赖的包后，决定对他一顿老拳。 正确的示例而必须使用，否则 yml 配置无效。12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 坑一个是一个的示例，谁用谁脱发12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.4&lt;/version&gt;&lt;/dependency&gt; 12345678910111213@Configurationpublic class MybatisConfig {@Beanpublic PageHelper pageHelper() { System.out.println(&quot;MyBatisConfiguration.pageHelper()&quot;); PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;); p.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;); p.setProperty(&quot;reasonable&quot;, &quot;true&quot;); pageHelper.setProperties(p); return pageHelper;} 最坑爹的不是版本问题，而是大部分的答案都是这个错误的答案。","link":"/2018/05/08/springboot--pagehelper%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"springboot中的@ConfigurationProperties注解的使用","text":"ConfigurationProperties 注解的使用将配置文件中的配置，以属性的形式自动注入到 实体中。要特别说明的一个注属性ignoreUnknownFields = false这个超好用，自动检查配置文件中的属性是否存在，不存在则在启动时就报错。locations 这个注解属性，不知道为什么不可以使用。用来指定其他配置文件名。 1.application.properties 配置12345#自动配置设置service.properties.name=my-test-nameservice.properties.ip=192.168.1.1service.user=kayleservice.port=8080 2.对应实体Properties 就是对应的配置文件中的 properties，注意也要给 get/set也就是说，配置文件中的前缀是什么， prefix 中就使用什么。成员变量就是对应的配置文件的第二级属性名。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Description 测试配置类 * * @Author liukai * @Date 2017/7/23. */@Component //不加这个注解的话, 使用@Autowired 就不能注入进去了@ConfigurationProperties(prefix = &quot;service&quot;,ignoreUnknownFields = false)public class MyConfigTest { private int port; private String user; private Properties Properties; public static class Properties { private String name; private String ip; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getIp() { return ip; } public void setIp(String ip) { this.ip = ip; } } public int getPort() { return port; } public void setPort(int port) { this.port = port; } public String getUser() { return user; } public void setUser(String user) { this.user = user; } public MyConfigTest.Properties getProperties() { return Properties; } public void setProperties(MyConfigTest.Properties properties) { Properties = properties; }}3.测试12345678910111213141516171819@RestControllerpublic class ConfigurationPropertiesController { @Autowired private MyConfigTest myConfigTest; @RequestMapping(&quot;/getProperties&quot;) public String getProperties () { System.out.println(myConfigTest.getUser()); return myConfigTest.getUser(); } @RequestMapping(&quot;/getObjectProperties&quot;) public Object getObjectProperties () { System.out.println(myConfigTest.getUser()); return myConfigTest.getProperties(); }}4.结果1{&quot;name&quot;:&quot;my-test-name&quot;,&quot;ip&quot;:&quot;192.168.1.1&quot;} 5.也可修饰配置类方法12345@ConfigurationProperties(prefix = &quot;foo&quot;)@Beanpublic FooComponent fooComponent() {}","link":"/2017/10/20/springboot--springboot%E4%B8%AD%E7%9A%84@ConfigurationProperties%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"springboot中的@Import注解","text":"Import注解在4.2之前只支持导入配置类在4.2,@Import注解支持导入普通的java类,并将其声明成一个bean。在 spring boot 的配置类中的使用比较多。 1.测试 @Import 的自动导入功能1.一个配置类123456@Configuration@Import(ImportDemo.class)public class ImportConfig {}2.一个普通没有加任何注解的类12345public class ImportDemo { public void doSomething () { System.out.println(&quot;ImportDemo.doSomething()&quot;); }}3.测试类12345678910public class TestMain { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(&quot;com.springboot.importtest&quot;); ImportDemo importDemo = context.getBean(ImportDemo.class); importDemo.doSomething(); }} 2.如果注掉配置类的 @Import ，再运行测试类，则报错。证明，ImportDemo 是由 @Import 动态注入到 spring 容器中的","link":"/2017/10/19/springboot--springboot%E4%B8%AD%E7%9A%84@Import%E6%B3%A8%E8%A7%A3/"},{"title":"spring boot 使用 maven 打 jar 包配置","text":"使用 ide 进行开发时，直接在ide上启动即可，如果要放到服务器上进行使用，就必须打成jar包，这里使用 maven 的打包插件进行打包。注意 &lt;mainClass&gt;com.devops.WebApplication&lt;/mainClass&gt; 这行要改成你的启动类。 123456789101112131415161718192021222324252627282930313233&lt;build&gt; &lt;finalName&gt;devops-web&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib&lt;/classpathPrefix&gt; &lt;mainClass&gt;com.devops.WebApplication&lt;/mainClass&gt; &lt;/manifest&gt; &lt;addMavenDescriptor&gt;true&lt;/addMavenDescriptor&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","link":"/2018/09/02/springboot--%E4%BD%BF%E7%94%A8%20maven%E6%89%93jar%E5%8C%85%E9%85%8D%E7%BD%AE/"},{"title":"springboot + vue 跨域处理","text":"在使用 vue 做前端开发时，碰到 vue 请求接口出现跨域问题。解决的方法，就在后台添加一个跨域请求的过滤器，来添加跨域支持。 123456789101112131415161718192021222324252627282930313233343536373839import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * Title: 跨域处理 * Description: * vue 请求服务跨域处理 * @author liu kai * @date 2018/6/14 10:38. */@Componentpublic class CorsFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; // response.setHeader(&quot;Access-Control-Allow-Origin&quot;,reqs.getHeader(&quot;Origin&quot;)); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, PATCH, DELETE, PUT&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); chain.doFilter(req, res); } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { }}","link":"/2018/07/11/springboot--%E4%BD%BF%E7%94%A8vue%E8%B7%A8%E5%9F%9F%E5%A4%84%E7%90%86/"},{"title":"springboot 注解实现日志切面","text":"项目中很多时候需要去打印方法入参和出参的日志，有助于排查错误。注解需要操作简单。常用的方式之一就是使用切面来切日志。 步骤： 定义自定义注解 编写自定义注解的切面方法 使用注解在需要输出日志的方法上 1.自定义注解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * * controller 注解切面 * @author liukai * @data 2018/8/7 15:26. */@Target({ElementType.PARAMETER, ElementType.METHOD})//目标是方法@Retention(RetentionPolicy.RUNTIME)//注解会在class中存在，运行时可通过反射获取@Documented//文档生成时，该注解将被包含在javadoc中，可去掉@Inheritedpublic @interface ControllerLog { /** * 操作描述 业务名称business * * @return */ String description() default &quot;&quot;; /** * 操作模块 * * @return */ OperateModule module(); /** * 操作类型 create modify delete * * @return */ OperateType opType(); /** * 主键入参参数名称，入参中的哪个参数为主键 * * @return */ String primaryKeyName() default &quot;&quot;; /** * 主键在参数中的顺序，从0开始，默认0 */ int primaryKeySort() default 0; /** * 业务类型 * @return */ String business() default &quot;&quot;;} 2.模块枚举12345678910111213141516171819202122/** * @author 操作类型 * @date 2017/7/26. */public enum OperateModule { /** * 枚举状态码 */ LOGIN(&quot;登陆&quot;), LOGOUT(&quot;退出登陆&quot;), DEMAND(&quot;需求&quot;), ITERATION(&quot;迭代&quot;); private String text; OperateModule(String text) { this.text = text; } public String getText() { return text; }} 3.操作类型123456789101112131415161718192021222324package com.group.core.web.log;/** * @author 操作类型 * @date 2017/7/26. */public enum OperateModule { /** * 枚举状态码 */ LOGIN(&quot;登陆&quot;), LOGOUT(&quot;退出登陆&quot;), DEMAND(&quot;需求&quot;), ITERATION(&quot;迭代&quot;); private String text; OperateModule(String text) { this.text = text; } public String getText() { return text; }} 4.日志切面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244package com.group.core.web.log;import com.alibaba.fastjson.JSONObject;import com.google.common.collect.Maps;import com.group.common.constants.Constants;import com.group.core.model.SysLog;import com.group.core.service.SysLogService;import com.group.core.web.vo.ResultVo;import com.group.core.web.log.annotation.ControllerLog;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.SecurityUtils;import org.apache.shiro.subject.Subject;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.CodeSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.apache.shiro.mgt.SecurityManager;import org.springframework.validation.BindingResult;import javax.annotation.Resource;import java.lang.reflect.Method;import java.util.Map;/** * 日志切面 * * @author liukai * @data 2018/8/7 15:50. */@Aspect@Componentpublic class WebLogAspect { public static final String MODULE = &quot;module&quot;; @Resource private SysLogService logService; @Resource private SecurityManager securityManager; private static final Logger LOGGER = LoggerFactory.getLogger(WebLogAspect.class); /** * 定义一个切入点. * (&quot;execution(public * com.group.*.web..*.*(..))&quot;) * 解释下： * 第一个 * 代表任意修饰符及任意返回值. * 第二个 * 任意包名 * 第三个 * 代表任意方法. * 第四个 * 定义在web包或者子包 * 第五个 * 任意方法 * .. 匹配任意数量的参数. */ @Pointcut(&quot;execution(public * com.group..*.controller..*.*(..)) &amp;&amp; @annotation(com.group.core.web.log.annotation.ControllerLog)&quot;) public void webLog() { } /** * round * 环境切面方法，切日方法调用的出入时的操作 * author liukai * date 2018/8/7 16:16 * * @param joinPoint * @return java.lang.Object */ @Around(&quot;webLog()&quot;) public Object round(ProceedingJoinPoint joinPoint) throws Throwable { LOGGER.info(&quot;环绕日志切面开始&quot;); SecurityUtils.setSecurityManager(securityManager); Subject subject = SecurityUtils.getSubject(); String user = (String) subject.getPrincipal(); if (StringUtils.isNotEmpty(user)) { JSONObject jsonObject = JSONObject.parseObject(user.substring(4)); user = jsonObject.getString(&quot;sub&quot;); } Map&lt;String, Object&gt; controllerAnnotationValues = getControllerAnnotationValue(joinPoint); if (StringUtils.isNotEmpty(user)) { controllerAnnotationValues.put(&quot;user&quot;, user); LOGGER.info(&quot;用户 {}-- 操作:{} -- 模块: {}&quot;, user, controllerAnnotationValues.get(&quot;operateName&quot;), controllerAnnotationValues.get(&quot;moduleName&quot;));// //需求目志特殊处理// if (controllerAnnotationValues.get(MODULE).equals(OperateModule.DEMAND.toString())) {//// demandLogger.insertLog(controllerAnnotationValues, getParameter(joinPoint));// } else { insertLog(controllerAnnotationValues);// } } //切面返回值 Object returnValue = joinPoint.proceed(); //用户登陆，登陆后 subject 才会包含用户信息。 if (returnValue instanceof ResultVo &amp;&amp; user == null) { Subject logSubject = SecurityUtils.getSubject(); String logUser = (String) logSubject.getPrincipal(); if (StringUtils.isNotEmpty(logUser)) { JSONObject jsonObject = JSONObject.parseObject(logUser.substring(4)); logUser = jsonObject.getString(&quot;sub&quot;); } controllerAnnotationValues.put(&quot;user&quot;, logUser); insertLog(controllerAnnotationValues); } return returnValue; } /** * 插入通用日志 * &lt;p&gt; * author liukai * date 2018/8/10 17:33 * * @param controllerParam * @return void */ private void insertLog(Map&lt;String, Object&gt; controllerParam) { SysLog sysLog = new SysLog(); String moduleName = (String) controllerParam.get(&quot;moduleName&quot;); String operateName = (String) controllerParam.get(&quot;operateName&quot;); controllerParam.get(&quot;primaryKeyName&quot;); controllerParam.get(&quot;primaryKeySort&quot;); String user = (String) controllerParam.get(&quot;user&quot;); sysLog.setOperationUser(user); sysLog.setModifyUserId(user); sysLog.setCreateUserId(user); sysLog.setOperation(operateName); sysLog.setModel(moduleName); sysLog.setFlag(Constants.DELETE_TYPE_FALSE); logService.insert(sysLog); } /** * 获取日志注解的方法 * &lt;p&gt; * author liukai * date 2018/8/7 16:41 * * @param joinPoint * @return java.util.Map&lt;java.lang.String , java.lang.Object&gt; */ public static Map&lt;String, Object&gt; getControllerAnnotationValue(JoinPoint joinPoint) throws Exception { //取切点相关参数 String targetName = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); Object[] arguments = joinPoint.getArgs(); LOGGER.info(&quot;targetName: {} - methodName: {} - arguments: {}&quot;, targetName, methodName, arguments.toString()); //实例化该 Class targetClass = Class.forName(targetName); //获取该类的所有方法 Method[] methods = targetClass.getMethods(); Map&lt;String, Object&gt; map = Maps.newHashMapWithExpectedSize(7); for (Method method : methods) { if (method.getName().equals(methodName)) { Class[] classes = method.getParameterTypes(); if (classes.length == arguments.length) { String description = method.getAnnotation(ControllerLog.class).description(); String module = method.getAnnotation(ControllerLog.class).module().name(); String operateType = method.getAnnotation(ControllerLog.class).opType().name(); String primaryKeyName = method.getAnnotation(ControllerLog.class).primaryKeyName(); int primaryKeySort = method.getAnnotation(ControllerLog.class).primaryKeySort(); String operateName = getOpName(operateType); String moduleName = getModelName(module); map.put(&quot;module&quot;, module); map.put(&quot;moduleName&quot;, moduleName); map.put(&quot;operateType&quot;, operateType); map.put(&quot;operateName&quot;, operateName); map.put(&quot;business&quot;, description); map.put(&quot;primaryKeyName&quot;, primaryKeyName); map.put(&quot;primaryKeySort&quot;, primaryKeySort); break; } } } return map; } /** * 获取模块名 * &lt;p&gt; * author liukai * date 2018/8/7 21:11 * * @param module * @return java.lang.String */ private static String getModelName(String module) { String operate = null; for (OperateModule model : OperateModule.values()) { if (model.name().equals(module)) { operate = model.getText(); return operate; } } return operate; } /** * 获取类型名 * &lt;p&gt; * author liukai * date 2018/8/7 21:06 * * @param operateType * @return java.lang.String */ private static String getOpName(String operateType) { String operate = null; for (OperateType opType : OperateType.values()) { if (opType.name().equals(operateType)) { operate = opType.getMsg(); return operate; } } return operate; } private Map&lt;String, Object&gt; getParameter(JoinPoint joinPoint) { //入参 value Object[] args = joinPoint.getArgs(); //入参名称 String[] paramNames = ((CodeSignature) joinPoint.getSignature()).getParameterNames(); Map&lt;String, Object&gt; params = Maps.newHashMapWithExpectedSize(7); //获取所有参数对象 for (int i = 0; i &lt; args.length; i++) { if (null != args[i]) { if (args[i] instanceof BindingResult) { params.put(paramNames[i], &quot;bindingResult&quot;); } else { params.put(paramNames[i], args[i]); } } else { params.put(paramNames[i], &quot;&quot;); } } return params; }} 5.使用注解123456789101112131415161718192021/** * 退出 * * @param session * @return * @throws * @author liukai * @date 2018/8/2 上午9:05 */ @RequestMapping(value = &quot;/logout&quot;, method = RequestMethod.POST) @ResponseBody @ControllerLog(module = OperateModule.LOGOUT, opType = OperateType.logout) public ResultVo logOut(HttpSession session) { ResultVo resultVo = new ResultVo(); Subject subject = SecurityUtils.getSubject(); resultVo.setCode(SUCCESS_CODE); resultVo.setMsg(&quot;退出登陆&quot;); logger.info(&quot;退出登陆&quot;); subject.logout(); return resultVo; }","link":"/2018/11/27/springboot--%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2/"},{"title":"spring boot 添加默认根路径跳转","text":"同一组数据分组需求：一个 list 里可能会有出现一个用户多条数据的情况。要把多条用户数据合并成一条。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 public static void main(String[] args) { List&lt;User&gt; users = Arrays.asList( new User(1, &quot;liu big big&quot;, &quot;123456789&quot;), new User(2, &quot;liu big big&quot;, &quot;987654321&quot;), new User(3, &quot;su xiao xiao&quot;, &quot;55555555&quot;) ); Map&lt;String, Set&lt;User&gt;&gt; map = new HashMap&lt;&gt;(); for (User user : users) { Set&lt;User&gt; userSet = map.get(user.getName()); if (null == userSet) { userSet = new HashSet&lt;&gt;(); userSet.add(user); map.put(user.getName(), userSet); } else { userSet.add(user); } } Set&lt;String&gt; keySet= map.keySet(); Iterator&lt;String&gt; it = keySet.iterator(); while(it.hasNext()){ String key = it.next(); Set&lt;User&gt; user = map.get(key); System.out.println(user.toString()); } }}class User { public User(Integer id, String name, String phone) { this.id = id; this.name = name; this.phone = phone; } private Integer id; private String name; private String phone; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; }}","link":"/2018/08/15/springboot--%E6%B7%BB%E5%8A%A0%E9%BB%98%E8%AE%A4%E6%A0%B9%E8%B7%AF%E5%BE%84/"},{"title":"spring boot 添加自定义 fliter","text":"自定义的 springboot 过滤器要注册到 spring boot中， 首先先添加一个过滤器，然后在spring boot 进行注册即可。 1234567891011121314151617181920212223242526import com.reapal.openapi.web.filter.XSSFilter;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Title: 注册自定义过滤器 * Description: * * @author liu kai * @date 2018/6/26 16:06. */@Configurationpublic class XssFilterConfig { @Bean public FilterRegistrationBean someFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new XSSFilter()); registration.addUrlPatterns(&quot;/*&quot;); registration.setName(&quot;xssFilter&quot;); registration.setOrder(Integer.MAX_VALUE); return registration; }}","link":"/2018/07/11/springboot--%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8fliter/"},{"title":"spring boot 解决生产环境下多线程调用FTP流被关闭问题","text":"在 spring boot 下把 FTP 工具类以类的型式注入到 spring 容器中。FTP 工具类在实际应用过程中，如果是单例的对象会出现问题：当线程 A 调用FTP工具时调用连接，线程B 同时调用FTP并使用完闭关闭流，这时A的连接会就被关闭了。 解决方案：将 Bean 置为多例对象。这样当线程每次调用该 Bean 就会生成一个新对象，互相之间不影响。 12public class FtpUtil {} 12345678910111213@Configurationpublic class FtpUtilConfig { @Autowired private FtpProperties ftpProperties; @Bean @Scope(&quot;prototype&quot;) public FtpUtil ftpUtil () { FtpUtil ftpUtil = new FtpUtil(); return ftpUtil; }} 12345678910111213@Configuration@ComponentScan(&quot;com.fund.common&quot;)public class FtpScope{ public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(FtpScope.class); FtpUtil f1 = context.getBean(FtpUtil.class); FtpUtil f2 = context.getBean(FtpUtil.class); System.out.println(p1); System.out.println(p2); }} 结果12com.fund.common.util.FtpUtil@7dac3fd8com.fund.common.util.FtpUtil@425357dd","link":"/2017/11/30/springboot--%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8FTP%E6%B5%81%E8%A2%AB%E5%85%B3%E9%97%AD%E9%97%AE%E9%A2%98/"},{"title":"静态资源配置的问题","text":"spring boot 的项目是将静态资源打包到.jar 的文件包中， 项目中有碰到需要使用外部静态资源的情况，使用外部资源的一直老出问题，查了google 后发现是指定的方式不对。 静态资源配置将 resource/static 进行映射，springboot 默认优先级:1234/META-INF/resources//resources//static//public/ spring 属性合配 resources 配置1.本项目包含路径：12345spring:mvc: static-path-pattern: /lateresources: static-locations: classpath:/templates/dist/这两天遇到的坑 2.指定项目外的磁盘路径如果要映射本地磁盘路径，可以使用，注意必须得有 file:, 注意必须得有file:,注意必须得有file: 否则 404, 重要事情说三遍。12345spring:mvc: static-path-pattern: /lateresources: static-locations: file:/templates/dist/ 浏览器的访问路径通过这个就可以改。static-path-pattern 3.还有一种方式是打包到 webjars 中，不过一样是费劲的事，不如直接指定外部磁盘路径，使用 nginx 做转换成功访问静态文件，但是配置更麻烦。","link":"/2019/01/10/springboot--%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"springboot 非parent方式搭建","text":"非parent 方式推荐使用这种方式。这样就可以使子项目使用 parent 标签了。这种方式需要两次步骤：1.paretn 项目配置2.子项目配置 parent 项目配置123456789101112添加一个 spring boot 依赖&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; type 是 pom，scope 是 import，这种类型的 dependency 只能在 dependencyManagement 标签中声明。 2.子项目配置parent 就可以使用普通的父项目了，而只需要进行 spring boot 的普通依赖即可。12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","link":"/2017/10/17/springboot--%E9%9D%9Eparent%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BA/"},{"title":"Spring boot @Bean源码分析","text":"1.先看下 Bean 注解的内容123456789101112@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Bean { @AliasFor(&quot;name&quot;) String[] value() default {}; @AliasFor(&quot;value&quot;) String[] name() default {}; Autowire autowire() default Autowire.NO; String initMethod() default &quot;&quot;; String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;}Target 中指定了注解的使用范围是METHON 和 ANNOTATION_TYPE，就是限定方法 和 注解上可以使用。 @Target(ElementType.METHOD) //方法@Target(ElementType.ANNOTATION_TYPE)//注解 value – bean别名和name是相互依赖关联的，value,name如果都使用的话值必须要一致name – bean名称，如果不写会默认为注解的方法名称autowire – 自定装配默认是不开启的，建议尽量不要开启，因为自动装配不能装配基本数据类型、字符串、数组等，这是自动装配设计的局限性，以及自动装配不如显示依赖注入精确Spring引入Autowire（自动装配）机制就是为了解决标签下标签过多的问题，标签过多会引发两个问题： 如果一个Bean中要注入的对象过多，比如十几二十个（这是很正常的），那将导致Spring配置文件非常冗长，可读性与维护性差 如果一个Bean中要注入的对象过多，配置麻烦且一不小心就容易出错default-autowire有四种取值： no：默认，即不进行自动装配，每一个对象的注入比如依赖一个标签 byName：按照beanName进行自动装配，使用setter注入 byType：按照bean类型进行自动装配，使用setter注入 constructor：与byType差不多，不过最终属性通过构造函数进行注入 通过测试类，可以看到这个注解的12345678910111213141516171819202122232425/** * @author liukai* @data 2019/4/15 21:53. */@Configurationpublic class ConfigTest { @Bean(name = &quot;config_test&quot;) public User user () { User user = new User(); user.setAuthor(&quot;liu big big&quot;); user.setName(&quot;刘大大&quot;); return user; } public static void main(String[] args) { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(); ac.register(ConfigTest.class); ac.refresh(); User user = (User) ac.getBean(&quot;config_test&quot;); System.out.println(user.getAuthor()); System.out.println(user.getName()); }} //liu big big//刘大大","link":"/2018/04/15/springboot-@Bean%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"什么是上下文context","text":"上下文(背景/语境) context是当前运行程序的环境。网上各种不可说，模糊不清，但是一个概念的提出肯定有最初的含义。 总结上下文可以理解成： 上下文指由代码已运行的程序环境，不是指代码。 一组状态，这个好理解，取 spring cloud 的官方文档的例子： 一个Spring Cloud应用程序通过创建一个”引导”上下文来进行操作，这个上下文是主应用程序的父上下文。引导上下文使用与主应用程序上下文不同的外部配置约定，因此使用bootstrap.yml application.yml（或.properties）代替引导和主上下文的外部配置。这里所谓的 引导上下文 就是一组状态，实际就是一个保存配置的大对象，换个角度理就是环境。 环境背景每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 查了一下 context1n. 语境; 上下文; 背景; 环境;谁用的翻译上下文，明明用背景、环境更贴切， 摘自知乎 和其他传入对象参数没什么区别。但是通常使用Context来描述有几个特点：被传入Context的部分（组件），内部需要频繁的获取Context的data和调用function。对context有很强的依赖，实现建立在context的基础上。Context会被较为多数部分（组件）所需要，在软件实现部分Context会在某个scene下出现单一实例化，然后被多个部分（组件）实例对象调用。出现局部全局化。Context会持有很多状态data。Coder习惯，命名选择困难下的胶合产物。 https://www.zhihu.com/question/26387327","link":"/2018/09/17/springboot-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87context/"},{"title":"spring cloud 四种服务下线方式","text":"这里指已经在 Eureka 注册中心注册的服务，如果需要停用，有四种方式进行停用。 1.直接关闭最粗暴。写这个是因为，直接关闭，如果 Eureka 开了保护模式，会导至服务已关闭，但是未下线，还是会重试调用。如果不需强稳定性的话可以这么干。 2.客户端主动通知注册中心下线安全。Eureka注册中心在收到某个客户端下线后不会马上通知所有的注册的客户端，而是等到客户端进行心跳的时候(心跳(续约)频率，默认30秒 )再将下的数据返回。通过这种方式下线的话，可以在某个服务下线后防止其他服务调用此服务失败。 白话就是，服务状态下线了，但是不通知其他服务。等到续约时间到了，再通知所有注册服务。 猜测，服务下线后，在没有心跳前，其他服务还是可以进行调用。等到心跳后，通知所有服务已下线，其他服务认为已下线，就不会再调该下线服务。12345678 @Autowired private DiscoveryClient client; @ResponseBody @GetMapping(&quot;/eurekaUnRegister&quot;) public String shutDown() { eurekaClient.shutdown(); return &quot;eurekaUnRegistering&quot;; }或1234@RequestMapping(value = &quot;/offline&quot;, method = RequestMethod.GET) public void offLine(){ DiscoveryManager.getInstance().shutdownComponent(); } 3.调用接口方式下线http://10.168.62.58:9999/message/actuator/shutdown 返回结果123{ &quot;message&quot;: &quot;Shutting down, bye...&quot;}本地起机器后，调试结果 结果就是服务线程关闭，服务停止：1234567Stopping beans in phase 2147483647Stopping beans in phase 0Unregistering JMX-exposed beans on shutdownDiscoveryClient_GROUP-MESSAGE/group-message-provider-704 - registration status: 204Shutting down DiscoveryClient ...Unregistering ...DiscoveryClient_GROUP-MESSAGE/group-message-provider-704 - deregister status: 200网上博客https://blog.csdn.net/memmsc/article/details/78122962 4.修改服务状态这种方式，服务不会停止，只是状态变为 DOWN，适合禁用该服务的操作。DOWN 禁用UP 启用http://10.168.62.58:9999/message/actuator/service-registry123{ &quot;status&quot;: &quot;UP&quot;}sprinng boot 2.0 以上需要添加额外配置才能生效，否则报40412345678management: endpoints: web: exposure: include: &quot;*&quot; #包含的路径，可以单个如 info endpoint: shutdown: enabled: true #开启shutdown 关闭","link":"/2019/05/05/springcloud--%E5%9B%9B%E7%A7%8D%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF%E6%96%B9%E5%BC%8F/"},{"title":"spring cloud eureka 注册服务显示IP端口号","text":"Spring cloud 显示 INSTANCE-ID 如果以IP + 端口号的形式显示，会更清析的定位每个服务所在的机器节点的状态。 依赖的 pom12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; yml 相关配置1234567eureka: client: service-url: defaultZone: http://10.168.16.101:8761/eureka/ instance: instance-id: ${spring.cloud.client.ip-address}:${spring.application.instance_id:${server.port}} prefer-ip-address: true 效果","link":"/2019/05/06/springcloud--%E6%9C%8D%E5%8A%A1%E6%98%BE%E7%A4%BAIP%E7%AB%AF%E5%8F%A3%E5%8F%B7/"},{"title":"Leetcode-344-字符串反转","text":"LeetCode 的344 题。 示例1:12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]示例2:12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 思路分解：1.字符串是奇数个，则最后，中间位置的那个是不需要交换的。如果是偶数个，所有位置交换一遍就完成了。2.这个方法的使用的是首尾逐渐向中间位置的元素递增交换的过程。 分解过程：[1][2][3][4][5][6][7][7][2][3][4][5][6][1][7][6][3][4][5][2][1][7][6][5][4][3][2][1] 解题实现12345678910111213141516171819202122/** * * @author liu kai * @since 2018/7/18 13:38 */public class Solution { public static void main(String[] args) { reverseString(&quot;abcdefg&quot;.toCharArray()); } public static void reverseString(char[] s) { for (int i = 0;i &lt; s.length;i++) { int k = s.length - i - 1; if (k &lt; s.length / 2) break; char ch = s[i]; s[i] = s[k]; s[k] = ch; } System.out.println(Arrays.toString(s)); }} 分解过程1234567891011121314151617public static void reverseString(char[] s) { System.out.println(&quot;字符串总长度: &quot; + s.length); for (int i = 0; i &lt; s.length; i++) { int k = s.length - i - 1; if (k &lt; s.length / 2) { System.out.println(&quot;break---&gt; k: &quot; + k + &quot;, s.length / 2: &quot; + s.length / 2 + &quot;, i: &quot; + i); break; } else { System.out.println(&quot;元素[&quot; + k + &quot;] 和 元素[&quot; + i + &quot;] 交换&quot;); } char ch = s[i]; s[i] = s[k]; s[k] = ch; } System.out.println(Arrays.toString(s));}","link":"/2018/07/19/%E7%AE%97%E6%B3%95--LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"一维数组去重","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Description: 一维数组去重 * Author liu kai * Data 2016/7/25 14:02 * @param * @return void */public static void test (int[] arr){ int len = 0; //标记去重的次数 int newLen = 0; int[] newArray; for (int i = 0; i &lt; arr.length; i++) { for (int j = i+1; j &lt; arr.length; j++) { if (arr[i] == -1) { continue; } else { if (arr[i] == arr[j]) { arr[j] = -1; len++; } } } } //不使用 list 的情况下，用数组重新封装结果 newArray = new int[arr.length - len]; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] != -1) { newArray[newLen] = arr[i]; newLen++; } } printResult (newArray);}public static void printResult(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); }}public static void main(String[] args) { int[] arr = {1, 4, 6, 4, 3, 5, 5, 0, 9, 8, 2, 4, 3, 8, 9, 7}; test(arr);}","link":"/2016/12/15/%E7%AE%97%E6%B3%95--%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"},{"title":"两个原素交换位置","text":"123456789101112131415161718192021222324252627282930package com.miya.algorithm.sort;/** * Created by liu kai on 16/9/8. * 交换数组两个元素位置 */public class Change { public static void main(String[] args) { int x = 3, y = 5; int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; test(arr, x, y); } public static void test (int[] arr, int x, int y) { int a = arr[x]; int b = arr[y]; a = a+b; b = a-b; a = a-b; arr[x] = a; arr[y] = b; for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } }}","link":"/2016/12/15/%E7%AE%97%E6%B3%95--%E4%B8%A4%E4%B8%AA%E5%8E%9F%E7%B4%A0%E4%BA%A4%E6%8D%A2%E4%BD%8D%E7%BD%AE/"},{"title":"使用递归实现地址数据菜单","text":"跟网上的不同的是，我这种方式是以时间换空间的做法，不会一次性把数据全查出来再慢慢遍历，而是每次查询是否存在子级，有就递归下去查。数据量大时，查库的次数比较多，数据量少时对数据库查询次数少，压力较小，但是多次查询不会出现一次查询数据量很大卡住的情况。 思路 先获取一级菜单，对每个一级菜单设子区域。 如果子区域还有子区域，就递归查询，直到查不到子区域返回。 递归的核心就是在方法中设置一个返回条件，防止无限递归下去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 * @author liukai * @since 2019/6/12 16:14. */public class SignTree { private static RegionDao regionDao = new RegionDao(); public static void main(String[] args) { //1. 先拿到第一级地址 //2. 递归查每一级下面的子级： // 如果子级下面，还有子级就递归 // 如果子级下面，没有子级就返回退出递归 List&lt;RegionBean&gt; firstRegion = regionDao.queryParentId(0); for (RegionBean regionBean : firstRegion) { //设置子区域 regionBean.setRegionBeanList(setChild(regionBean.getId())); } String jsonObject = JSONObject.toJSONString(firstRegion); System.out.println(jsonObject); } /** * 递归查询所有子级 * @param parentId * @return */ private static List&lt;RegionBean&gt; setChild(int parentId) { List&lt;RegionBean&gt; childList = new ArrayList&lt;&gt;(); List&lt;RegionBean&gt; childTemp = regionDao.queryParentId(parentId); if (childTemp != null &amp;&amp; childTemp.size() &gt; 0) { for (RegionBean regionBean : childTemp) { childList.add(regionBean); regionBean.setRegionBeanList(setChild(regionBean.getId())); } } else { return childList; } return childList; }}class RegionDao { /** * 查询父级 * @param parentId * @return */ public List&lt;RegionBean&gt; queryParentId(int parentId) { List&lt;RegionBean&gt; regionBeans = dataBaseRegion(); List&lt;RegionBean&gt; firstRegion = new ArrayList&lt;&gt;(); for (RegionBean regionBean : regionBeans) { if (regionBean.getParentId() == parentId) { firstRegion.add(regionBean); } } return firstRegion; } public static List&lt;RegionBean&gt; dataBaseRegion() { List&lt;RegionBean&gt; regionBeans = Arrays.asList( new RegionBean(2, &quot;北京市&quot;, &quot;北京市&quot;, 0, 1), new RegionBean(22, &quot;天津市&quot;, &quot;天津市&quot;, 0, 2), new RegionBean(783, &quot;上海市&quot;, &quot;上海市&quot;, 0, 3), new RegionBean(457, &quot;辽宁省&quot;, &quot;辽宁省&quot;, 0, 8), new RegionBean(458, &quot;沈阳市&quot;, &quot;辽宁省-沈阳市&quot;, 457, 1), new RegionBean(472, &quot;铁岭市&quot;, &quot;辽宁省-铁岭市&quot;, 457, 2), new RegionBean(480, &quot;大连市&quot;, &quot;辽宁省-大连市&quot;, 457, 3), new RegionBean(491, &quot;鞍山市&quot;, &quot;辽宁省-鞍山市&quot;, 457, 4), new RegionBean(499, &quot;抚顺市&quot;, &quot;辽宁省-抚顺市&quot;, 457, 5), new RegionBean(507, &quot;本溪市&quot;, &quot;辽宁省-本溪市&quot;, 457, 6), new RegionBean(514, &quot;丹东市&quot;, &quot;辽宁省-丹东市&quot;, 457, 7), new RegionBean(521, &quot;锦州市&quot;, &quot;辽宁省-锦州市&quot;, 457, 8), new RegionBean(529, &quot;营口市&quot;, &quot;辽宁省-营口市&quot;, 457, 9), new RegionBean(536, &quot;阜新市&quot;, &quot;辽宁省-阜新市&quot;, 457, 10), new RegionBean(544, &quot;辽阳市&quot;, &quot;辽宁省-辽阳市&quot;, 457, 11), new RegionBean(552, &quot;朝阳市&quot;, &quot;辽宁省-朝阳市&quot;, 457, 12), new RegionBean(560, &quot;盘锦市&quot;, &quot;辽宁省-盘锦市&quot;, 457, 13), new RegionBean(561, &quot;三级数据&quot;, &quot;辽宁省-三级数据&quot;, 560, 13), new RegionBean(562, &quot;三级数据&quot;, &quot;辽宁省-三级数据&quot;, 560, 13), new RegionBean(563, &quot;三级数据&quot;, &quot;辽宁省-三级数据&quot;, 560, 13), new RegionBean(564, &quot;三级数据&quot;, &quot;辽宁省-三级数据&quot;, 560, 13), new RegionBean(565, &quot;三级数据&quot;, &quot;辽宁省-三级数据&quot;, 560, 13), new RegionBean(566, &quot;三级数据&quot;, &quot;辽宁省-三级数据&quot;, 560, 13), new RegionBean(666, &quot;四级数据&quot;, &quot;辽宁省-四级数据&quot;, 566, 13) ); return regionBeans; }} 1234567891011121314151617public class RegionBean implements java.io.Serializable { private static final long serialVersionUID = 1L; private int id; private String label; private String fullLabel; private int parentId; private int sortId; private List&lt;RegionBean&gt; regionBeanList = new ArrayList&lt;&gt;(); 结果12[{&quot;fullLabel&quot;:&quot;北京市&quot;,&quot;id&quot;:2,&quot;label&quot;:&quot;北京市&quot;,&quot;parentId&quot;:0,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:1},{&quot;fullLabel&quot;:&quot;天津市&quot;,&quot;id&quot;:22,&quot;label&quot;:&quot;天津市&quot;,&quot;parentId&quot;:0,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:2},{&quot;fullLabel&quot;:&quot;上海市&quot;,&quot;id&quot;:783,&quot;label&quot;:&quot;上海市&quot;,&quot;parentId&quot;:0,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:3},{&quot;fullLabel&quot;:&quot;辽宁省&quot;,&quot;id&quot;:457,&quot;label&quot;:&quot;辽宁省&quot;,&quot;parentId&quot;:0,&quot;regionBeanList&quot;:[{&quot;fullLabel&quot;:&quot;辽宁省-沈阳市&quot;,&quot;id&quot;:458,&quot;label&quot;:&quot;沈阳市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:1},{&quot;fullLabel&quot;:&quot;辽宁省-铁岭市&quot;,&quot;id&quot;:472,&quot;label&quot;:&quot;铁岭市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:2},{&quot;fullLabel&quot;:&quot;辽宁省-大连市&quot;,&quot;id&quot;:480,&quot;label&quot;:&quot;大连市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:3},{&quot;fullLabel&quot;:&quot;辽宁省-鞍山市&quot;,&quot;id&quot;:491,&quot;label&quot;:&quot;鞍山市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:4},{&quot;fullLabel&quot;:&quot;辽宁省-抚顺市&quot;,&quot;id&quot;:499,&quot;label&quot;:&quot;抚顺市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:5},{&quot;fullLabel&quot;:&quot;辽宁省-本溪市&quot;,&quot;id&quot;:507,&quot;label&quot;:&quot;本溪市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:6},{&quot;fullLabel&quot;:&quot;辽宁省-丹东市&quot;,&quot;id&quot;:514,&quot;label&quot;:&quot;丹东市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:7},{&quot;fullLabel&quot;:&quot;辽宁省-锦州市&quot;,&quot;id&quot;:521,&quot;label&quot;:&quot;锦州市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:8},{&quot;fullLabel&quot;:&quot;辽宁省-营口市&quot;,&quot;id&quot;:529,&quot;label&quot;:&quot;营口市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:9},{&quot;fullLabel&quot;:&quot;辽宁省-阜新市&quot;,&quot;id&quot;:536,&quot;label&quot;:&quot;阜新市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:10},{&quot;fullLabel&quot;:&quot;辽宁省-辽阳市&quot;,&quot;id&quot;:544,&quot;label&quot;:&quot;辽阳市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:11},{&quot;fullLabel&quot;:&quot;辽宁省-朝阳市&quot;,&quot;id&quot;:552,&quot;label&quot;:&quot;朝阳市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:12},{&quot;fullLabel&quot;:&quot;辽宁省-盘锦市&quot;,&quot;id&quot;:560,&quot;label&quot;:&quot;盘锦市&quot;,&quot;parentId&quot;:457,&quot;regionBeanList&quot;:[{&quot;fullLabel&quot;:&quot;辽宁省-三级数据&quot;,&quot;id&quot;:561,&quot;label&quot;:&quot;三级数据&quot;,&quot;parentId&quot;:560,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:13},{&quot;fullLabel&quot;:&quot;辽宁省-三级数据&quot;,&quot;id&quot;:562,&quot;label&quot;:&quot;三级数据&quot;,&quot;parentId&quot;:560,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:13},{&quot;fullLabel&quot;:&quot;辽宁省-三级数据&quot;,&quot;id&quot;:563,&quot;label&quot;:&quot;三级数据&quot;,&quot;parentId&quot;:560,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:13},{&quot;fullLabel&quot;:&quot;辽宁省-三级数据&quot;,&quot;id&quot;:564,&quot;label&quot;:&quot;三级数据&quot;,&quot;parentId&quot;:560,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:13},{&quot;fullLabel&quot;:&quot;辽宁省-三级数据&quot;,&quot;id&quot;:565,&quot;label&quot;:&quot;三级数据&quot;,&quot;parentId&quot;:560,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:13},{&quot;fullLabel&quot;:&quot;辽宁省-三级数据&quot;,&quot;id&quot;:566,&quot;label&quot;:&quot;三级数据&quot;,&quot;parentId&quot;:560,&quot;regionBeanList&quot;:[{&quot;fullLabel&quot;:&quot;辽宁省-四级数据&quot;,&quot;id&quot;:666,&quot;label&quot;:&quot;四级数据&quot;,&quot;parentId&quot;:566,&quot;regionBeanList&quot;:[],&quot;sortId&quot;:13}],&quot;sortId&quot;:13}],&quot;sortId&quot;:13}],&quot;sortId&quot;:8}] 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1n712ep0u8906","link":"/2019/06/14/%E7%AE%97%E6%B3%95-%E5%8D%95%E8%A1%A8%E6%A0%91%E5%9E%8B%E5%AE%9E%E7%8E%B0/"},{"title":"对 list 中的相同数据进行分组","text":"同一组数据分组需求：一个 list 里可能会有出现一个用户多条数据的情况。要把多条用户数据合并成一条。思路：将相同的数据中可以进行确认是相同的数据，拿来做分组的 key，这样保证不会重。实际中使用，以用户数据为例，可能用户名和身份证号是不会变的，用这两个条件拼接起来。 12345678910111213141516171819202122232425262728293031public class TestSort { public static void main(String[] args) { List&lt;User&gt; users = Arrays.asList( new User(1, &quot;liu big big&quot;, &quot;123456789&quot;), new User(2, &quot;liu big big&quot;, &quot;987654321&quot;), new User(3, &quot;su xiao xiao&quot;, &quot;55555555&quot;) ); Map&lt;String, Set&lt;User&gt;&gt; map = new HashMap&lt;&gt;(); for (User user : users) { Set&lt;User&gt; userSet = map.get(user.getName()); if (null == userSet) { userSet = new HashSet&lt;&gt;(); userSet.add(user); map.put(user.getName(), userSet); } else { userSet.add(user); } } Set&lt;String&gt; keySet= map.keySet(); Iterator&lt;String&gt; it = keySet.iterator(); while(it.hasNext()){ String key = it.next(); Set&lt;User&gt; user = map.get(key); System.out.println(user.toString()); } }} 1234567891011121314151617181920212223242526272829303132333435363738class User { public User(Integer id, String name, String phone) { this.id = id; this.name = name; this.phone = phone; } private Integer id; private String name; private String phone; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; }} 结果:12[com.liukai.User@2dda6444][com.liukai.User@79fc0f2f, com.liukai.User@50040f0c]","link":"/2016/07/09/%E7%AE%97%E6%B3%95-%E5%AF%B9%E5%90%8C%E4%B8%80%E7%BB%84list%E4%B8%AD%E7%9B%B8%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84/"},{"title":"面试-产生线程死锁的原因和处理方式","text":"背景:线程同步(就是加锁)会有一个问题，就是产生死锁所谓死锁: 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 帮助理解：地上放着两个桶泡面，一个老坛酸菜，一个小鸡炖磨茹。有两个人：一个产品(线程1)，一个测试(线程2)，同时扑向抢老坛酸菜(锁A)和小鸡炖磨茹(锁B)，产品拿到老坛酸菜，测试拿到小鸡炖磨茹，同一时刻，产品伸要去拽测试怀里的小鸡炖磨茹，测试伸手去拽产品的老坛酸菜，互使剪刀脚两个僵持不下，就卡死在那了，叫这就死锁。如果没有一个开发将他们各打一顿解救出来(中断状态)，它们将无法推进下去。 发生死锁的具体原因如下: 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当。 举列说明场景:死锁是因为多线程访问共享资源，由于访问的顺序不当所造成的，通常是一个线程锁定了一个资源A，而又想去锁定资源B；在另一个线程中，锁定了资源B，而又想去锁定资源A以完成自身的操作，两个线程都想得到对方的资源，而不愿释放自己的资源，造成两个线程都在等待，而无法执行的情况。 死锁预防如果只使用一个锁就不会有死锁的问题，不过复杂场景下不太理实。1.以确定的顺序获得锁123线程A ---&gt; 锁定 A ----&gt; 偿试锁定 B线程B ---&gt; 锁定 A ----&gt; 偿试锁定 B这样就不会发生死锁 2.超时放弃Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 死锁示列:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950packag com.liukai.thread.daed_locl;/** * 死锁 */public class SyncDeadLock{ private static Object locka = new Object(); private static Object lockb = new Object(); public static void main(String[] args){ new SyncDeadLock().deadLock(); } private void deadLock(){ Thread thread1 = new Thread(()-&gt;{ synchronized (locka){ try{ System.out.println(Thread.currentThread().getName()+&quot; 拿到 lock-A!&quot;); Thread.sleep(500); System.out.println(Thread.currentThread().getName()+&quot; 睡眠 500ms 后续继执行...!&quot;); }catch(Exception e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot; 偿试获取 lock-B!&quot;); synchronized (lockb){ System.out.println(Thread.currentThread().getName()+&quot; 已获得 lock-B!&quot;); } } }, &quot;thread1&quot;); Thread thread2 = new Thread(()-&gt;{ synchronized (lockb){ try{ System.out.println(Thread.currentThread().getName()+&quot; 拿到 lock-B!&quot;); Thread.sleep(500); System.out.println(Thread.currentThread().getName()+&quot; 睡眠 500ms 后续继执行...!&quot;); }catch(Exception e){ e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+&quot; 偿试获取 lock-A!&quot;); synchronized (locka){ System.out.println(Thread.currentThread().getName()+&quot; 已获得 lock-A!&quot;); } } },&quot;thread2&quot;); thread1.start(); thread2.start(); }}","link":"/2019/07/02/%E9%9D%A2%E8%AF%95-%E4%BA%A7%E7%94%9F%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"},{"title":"hashcode用在哪？或者说什么时候用","text":"hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；如果两个对象相同，就是适用于equals方法进行比较，那么这两个对象的hashCode一定要相同；","link":"/2017/06/02/%E9%9D%A2%E8%AF%95%E9%A2%98--hashcode%E7%94%A8%E5%9C%A8%E5%93%AA/"},{"title":"hashcode 相等两个类一定相等吗? equals呢? 相反呢?","text":"结论:不一定相等。 原因:hashCode 算法有一定概率产生相同的 hashCode，即 hash 碰撞。分重写 和 未重写 hashcode、equals 方法两种场景： 一、hashcode 方法 和 equals 方法没有重写时 hashcode相等两个类不一定相等 equals返回true的两个类一定相等（为同一个对象） 两个类相等hashcode不一定相等 两个类相等equals不一定返回true 二、hashcode 方法和 equals 方法均已按规范重写时 hashcode相等，两个类不一定相等（存在哈希冲突） equals返回true的两个类一定相等 两个类相等hashcode一定相等 两个类相等equals一定返回true","link":"/2017/06/02/%E9%9D%A2%E8%AF%95%E9%A2%98--hashcode%E7%9B%B8%E7%AD%89%E4%B8%A4%E4%B8%AA%E7%B1%BB%E4%B8%80%E5%AE%9A%E7%9B%B8%E7%AD%89%E5%90%97/"},{"title":"什么是线程安全?举例说明，区别。","text":"线程安全:当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。 线程不安全:在多核CPU的环境下，当多个线程访问同一个共享变量时，这个变量没有使用任务同步机制，会出现CPU 缓存同步内存不及时，导致出现数据不同步的情况，这就是所谓的线程不安全。单核CPU没有这个问题。","link":"/2017/06/02/%E9%9D%A2%E8%AF%95%E9%A2%98--%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BE%8B%E5%AD%90/"},{"title":"算法-leetcode007-整数反转","text":"当所计算数字大于2^30 次方或等于2^31 次方但余下的数大于7或小于-2^30 次方或等于-2^31 次方但余下的数小于-8时，只要再计算一次就溢出。 1234567891011121314151617181920public static int reverse(int x) { int pop; int res = 0; while (x != 0) { pop = x % 10; System.out.println(&quot;pop: &quot; + pop); x = x / 10; System.out.println(&quot;x: &quot; + x); if (res &gt; Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) { return 0; } if (res &lt; Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) { return 0; } System.out.println(&quot;res before: &quot; + res); res = res * 10 + pop; System.out.println(&quot;res after: &quot; + res); } return res;} Leetcode007","link":"/2020/12/16/%E7%AE%97%E6%B3%95--leetcode007-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"title":"算法-栈stack-用栈实现队列-Leetcode232","text":"用栈实现队列这个是 Leetcode 232 题，用两个栈来实现一个先进先出的队列，实现了一个版本。 https://leetcode-cn.com/problems/implement-queue-using-stacks/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue { Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); /** * Initialize your data structure here. */ public MyQueue() { } /** * Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** * Removes the element from in front of queue and returns that element. */ public int pop() { while (!stack1.empty()) { stack2.push(stack1.pop()); } int result = stack2.pop(); while (!stack2.empty()) { stack1.push(stack2.pop()); } return result; } /** * Get the front element. */ public int peek() { while (!stack1.empty()) { stack2.push(stack1.pop()); } int result = stack2.peek(); while (!stack2.empty()) { stack1.push(stack2.pop()); } return result; } /** * Returns whether the queue is empty. */ public boolean empty() { return stack1.empty(); }}","link":"/2020/12/15/%E7%AE%97%E6%B3%95--leetcode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"title":"RocketMQ安装","text":"包推荐使用 git 直接拉下来。没装 git 就 wget 去拉。需要 maven 来编译 rocketmq，实际上只要装好 maven 即可，其他不用操作 maven。 步骤: 安装 JDK，配置 JAVA_HOME，yum 方式安装的JDK也要配轩JAVA_HOME。 安装 maven。因为编译需要 maven，先配置MAVEN_HOME，否则执行 sh install.sh 不起作用 默认最少4G内存，需要最少2G SWAP 内存，内存不够则修改默认内存小于本机内存，不然一直报错 内存不够的话，直接看下面的修改内存 测试安装环境： centOS 6.5 1G 内存 RocketMQ 3.4.6 编译和安装1sh install.sh //在 mq 的根目录 下说明：安装完成后，因为 install.sh 脚本中创建 devenv 符号链接写错了目录，需要在RocketMQ目录下执行如下命令：1rm -rf devenv //删除错误的 devenv 目录ln -s target/alibaba-rocketmq-broker/alibaba-rocketmq devenv //搞了两天问题就在这里，坑坑坑坑","link":"/2015/04/09/RocketMQ-RocketMQ%E5%AE%89%E8%A3%85/"},{"title":"RocketMQ--主要角色1-Broker","text":"消息中转角色。负责存储消息，转发消息。一般也称为 Server。在JMS规范中称为 Provider。两两一组，四个，两主两从。Master 才是干活的 Broker 几个关键点： 负载均衡 可用性 1.负载均衡 一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。 如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。 topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。 2.可用性由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。","link":"/2015/04/16/RocketMQ-%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B21-Broker/"},{"title":"算法--leetcode-283-移动零","text":"相当于是使用 for 进行交换的一个小技巧的练习，后面会给出一些算法的小技巧，都是总结的一些算法的小技巧。 1234567891011121314151617public class Test { public static void main(String[] args) { Integer[] arr = {1, 3, 5, 0, 7, 0, 0, 0, 8, 9}; int j = 0; for (int i = 0; i &lt; arr.length; i++) { if (arr[i] != 0) { int temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; j++; } } System.out.println(Arrays.toString(arr)); }}","link":"/2020/12/16/%E7%AE%97%E6%B3%95--leetcode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"},{"title":"RocketMQ--主要角色2-NameServer","text":"NameServer 名字服务作用：在系统中肯定是做命名服务，服务治理方面的工作，功能应该是和zookeeper差不多.早期的版本中，使用的是 Zookeeper 做为配置中心，改名 RocketMQ 后使用了自己开发的 NameServer。 两个主要做用： NameServer 维护了一份 Broker 的地址列表和 Broker 在启动的时候会去 NameServer 进行注册，会维护 Broker 的存活状态。 NameServer 维护了一份 Topic 和 Topic 对应队列的地址列表，Broker 每次发送的心跳过来的时候会把 Topic 信息带上。 是一个几乎无状态的节点，可集群部署，节点之间无任何信息同步 互相独立，彼此没有通信关系，单台nameserver挂掉，不影响其他nameserver，即使全部挂掉，也不影响业务系统使用，这点类似于dubbo的zookeeper。 nameserver不会有频繁的读写，所以性能开销非常小，稳定性很高。","link":"/2015/04/17/RocketMQ-%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B22-NameServer/"},{"title":"多线程01--线程、进程概念","text":"进程正在进行中的程序。每一个进程至少有一个线程。当程序运行时在内存空间中开辟一片独立空间。每一个进程都有一个执行顺序。一个进程更象一个任务。进程的内存原理： 应用程序在执行时都会在内存中开辟一片内存空间并分配地址。进程用于标识这片空间，封装里面的控制单元。 而线程就是进程中的控制单元。线程在控制着进程的执行。 进程创建：进程和线程都是由系统来进行创建，JVM通过调用当前系进行开辟进行和线程的操作。 线程线程是进程中的内容。他是程序中的控制单元或叫执行路径。线程才是真正去执行的。一个进程可以有多个线程组成，他们分别执行不同的任务。一个进程至少有一条线程，当线程内有多个进程同时运行时，这种方式 称为并发运行。如：web服务器。线程控制着进程的执行。执行路径：一个程序从头走到尾就是一个执行路径 线程执行原理：以主线程为例，当执行进程时，进程内的线程开始执行代码。在程序中，内存中的代码都是由线程在执行的。java中的主线程就是main。 总结：一进程可以同时执行个线程，称多线程。理解方式：windows系统的理解方式。 同步：排队一前一后执行异步：并列各走个的","link":"/2014/08/09/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B01-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"title":"vim01-环境配置","text":"现在开发、写文章基本上已经离不开 vim了，写代码idea + vim 配合，写文章就是直接上 vim。vim 有一定的学习曲线，但是习惯了就好。习惯以后，再使用这些插件就会更好用。 配置存放仓库:https://github.com/forfreeday/vim coc java 问题JDK 版本要高于1.8否则，JDT会启动失败。 先上效果图 环境准备script1234npm install -g neovimpip3 install pylintnpm install -g typescriptpip3 install jedi Plug 插件script1curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim coc-settings.json特别说明，要使有 coc 的java语法提示，必须指定jdk为 JDK11，否则报错123456789101112131415161718192021222324252627282930313233343536373839404142{ &quot;suggest.noselect&quot;: true, &quot;suggest.enablePreselect&quot;: false, &quot;codeLens.enable&quot;: true, &quot;java.home&quot;: &quot;/Library/Java/JavaVirtualMachines/jdk-11.0.9.jdk/Contents/Home&quot;, &quot;suggest.completionItemKindLabels&quot;: { &quot;class&quot;: &quot;\\uf0e8&quot;, &quot;color&quot;: &quot;\\ue22b&quot;, &quot;constant&quot;: &quot;\\uf8fe&quot;, &quot;default&quot;: &quot;\\uf29c&quot;, &quot;enum&quot;: &quot;\\uf435&quot;, &quot;enumMember&quot;: &quot;\\uf02b&quot;, &quot;event&quot;: &quot;\\ufacd&quot;, &quot;field&quot;: &quot;\\uf93d&quot;, &quot;file&quot;: &quot;\\uf723&quot;, &quot;folder&quot;: &quot;\\uf115&quot;, &quot;function&quot;: &quot;\\u0192&quot;, &quot;interface&quot;: &quot;\\uf417&quot;, &quot;keyword&quot;: &quot;\\uf1de&quot;, &quot;method&quot;: &quot;\\uf6a6&quot;, &quot;module&quot;: &quot;\\uf40d&quot;, &quot;operator&quot;: &quot;\\uf915&quot;, &quot;property&quot;: &quot;\\ue624&quot;, &quot;reference&quot;: &quot;\\ufa46&quot;, &quot;snippet&quot;: &quot;\\ue60b&quot;, &quot;struct&quot;: &quot;\\ufb44&quot;, &quot;text&quot;: &quot;\\ue612&quot;, &quot;typeParameter&quot;: &quot;\\uf728&quot;, &quot;unit&quot;: &quot;\\uf475&quot;, &quot;value&quot;: &quot;\\uf89f&quot;, &quot;variable&quot;: &quot;\\ue71b&quot; }, &quot;coc.preferences.formatOnSaveFiletypes&quot;: [ &quot;json&quot;, &quot;java&quot;, &quot;python&quot;, &quot;css&quot;, &quot;dart&quot;, &quot;html&quot;, &quot;javascript&quot; ]} 字体 和 iTerm2 配置将 powerline 的字体也放到项目当中，方便大家直接导入字体。解决 vim-airline 下符号显示导常，箭头标志大小异常的问题 1.字体直接在项目中双点安装或自行下载安装script1git clone https://github.com/supermarin/powerline-fonts.git 2.iTerm2 设置安装 powerline 字体后在配置安装 Menlo Regular for Powerline.otf 这个字体，在 iTerm2下显示为 Menlo for Powerline，的字体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461&quot;=================================&quot; VIM 自身配置&quot;=================================&quot; 编码设置set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1set enc=utf8set fencs=utf8,gbk,gb2312,gb18030&quot; 启用插件set nocompatiblefiletype onfiletype plugin indent on&quot; Tab 转空格set tabstop=4set shiftwidth=4set softtabstop=4set expandtab&quot; 列高亮set cursorcolumn&quot; 记录上次光标位置au BufReadPost * if line(&quot;'\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;'\\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g'\\&quot;&quot; | endif&quot; 分屏设置&quot; 向右分屏并把光标移动向右边map td :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;&quot; 向右分屏并把光标移动向左边map ta :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;&quot; 向下分屏并把光标移动向上边map ts :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;&quot; 向下分屏并把光标移动向下边map tw :set splitbelow&lt;CR&gt;:split&lt;CR&gt;&quot; 替换方向键为调节分屏大小map &lt;up&gt; :res +5&lt;CR&gt;map &lt;down&gt; :res -5&lt;CR&gt;map &lt;left&gt; :vertical resize-5&lt;CR&gt;map &lt;right&gt; :vertical resize+5&lt;CR&gt;&quot; 按键映射map W :w&lt;CR&gt;map Q :wq&lt;CR&gt;map tq :q!&lt;CR&gt;map te :terminal&lt;CR&gt;&quot; 设置 buff、空白字符的视觉提示set list listchars=extends:❯,precedes:❮,tab:▸\\ ,trail:˽&quot; 其他的一些配置syntax on &quot; 语法高亮set number &quot; 显示行号&quot;set relativenumber &quot; 相对行号set wildmenu &quot; 让vim命令可用Tab补全set hlsearch &quot; 变输入搜索词边高亮set incsearch &quot; 光标自动跳转到搜索结果上set t_ut= &quot;防止vim背景颜色错误&quot;======================================&quot; VIM 自带颜色配置&quot;======================================&quot;光标选中部分的底色hi Visual guibg=#99cc99 guifg=#334433 gui=none ctermbg=9 ctermfg=15&quot;=================================&quot; 插件部分--开始&quot;=================================&quot; 插件call plug#begin('~/.vim/plugged')&quot; coc.nvim代码补全Plug 'neoclide/coc.nvim', {'branch': 'release'}&quot; vim的dart支持Plug 'dart-lang/dart-vim-plugin'&quot; NERDTree文件树Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }Plug 'Xuyuanp/nerdtree-git-plugin'&quot; 修改启动界面Plug 'mhinz/vim-startify'&quot; 状态栏、主题美化Plug 'vim-airline/vim-airline'Plug 'vim-airline/vim-airline-themes'&quot; 增加代码缩进线Plug 'yggdroot/indentline'&quot; 快速注释Plug 'scrooloose/nerdcommenter'&quot; 彩色括号Plug 'luochen1990/rainbow'&quot; 配色Plug 'crusoexia/vim-monokai'&quot; 展示当前文件的一些函数Plug 'majutsushi/tagbar'&quot; 翻译Plug 'voldikss/vim-translator'&quot; 模糊搜索Plug 'ctrlpvim/ctrlp.vim'call plug#end()&quot;=================================&quot; 插件部分--结束&quot;=================================&quot; =================================&quot; vim-translator&quot; =================================&quot; 在窗口中显示翻译nmap &lt;silent&gt; &lt;Leader&gt;w &lt;Plug&gt;TranslateW&quot; 将文字替换为翻译nmap &lt;silent&gt; &lt;Leader&gt;r &lt;Plug&gt;TranslateR&quot; 翻译剪贴板中的文字nmap &lt;silent&gt; &lt;Leader&gt;x &lt;Plug&gt;TranslateX&quot; =================================&quot; vim-monokai&quot; =================================&quot;colo monokaicolo gruvbox&quot; =================================&quot; tagbar&quot; =================================let g:tagbar_width=30&quot; 将tagbar的开关按键设置为 F5nnoremap &lt;silent&gt; &lt;F5&gt; :TagbarToggle&lt;CR&gt;&quot; =================================&quot; startify 设置 &quot; =================================&quot; 设置Startify 快捷键map &lt;F4&gt; :Startify&lt;cr&gt;&quot; =================================&quot; NERDTree&quot; =================================map tt :NERDTreeToggle&lt;CR&gt;&quot; \\ + r 定位当前文件所在目录，这个很有用&quot; 当前从左树进入，又要将当前目录定位到当前位置用这个map &lt;leader&gt;r :NERDTreeFind&lt;cr&gt; &lt;C-w&gt;&lt;C-w&gt;&quot;显示书签&quot;let NERDTreeShowBookmarks=1&quot; 忽略一下文件的显示let NERDTreeIgnore=['\\.pyc','\\~$','\\.swp']let g:NERDTreeIndicatorMapCustom = { \\ &quot;Modified&quot; : &quot;✹&quot;, \\ &quot;Staged&quot; : &quot;✚&quot;, \\ &quot;Untracked&quot; : &quot;✭&quot;, \\ &quot;Renamed&quot; : &quot;➜&quot;, \\ &quot;Unmerged&quot; : &quot;═&quot;, \\ &quot;Deleted&quot; : &quot;✖&quot;, \\ &quot;Dirty&quot; : &quot;✗&quot;, \\ &quot;Clean&quot; : &quot;✔︎&quot;, \\ 'Ignored' : '☒', \\ &quot;Unknown&quot; : &quot;?&quot; \\ }&quot; }}}&quot; =================================&quot; vim-airline&quot; =================================&quot; 设置状态栏&quot;字体设置，装完 powerline 后，添加这一项不会乱码，否则注释这一行let g:airline_powerline_fonts = 1&quot; 关闭状态显示空白符号计数 let g:airline#extensions#whitespace#enabled = 0 let g:airline#extensions#whitespace#symbol = '!'set t_Co=256 &quot;终端开启256色支持&quot;set laststatus=2 &quot;1为关闭底部状态栏 2为开启&quot;&quot; 开启tablinelet g:airline#extensions#tabline#enabled = 1&quot; tabline中未激活buffer两端的分隔字符let g:airline#extensions#tabline#left_alt_sep = '|'let g:airline#extensions#tabline#buffer_nr_show = 0let g:airline#extensions#tabline#formatter = 'default'let g:airline_theme = 'desertink' &quot; 主题let g:airline#extensions#keymap#enabled = 1let g:airline#extensions#tabline#buffer_idx_mode = 1let g:airline#extensions#tabline#buffer_idx_format = { \\ '0': '0 ', \\ '1': '1 ', \\ '2': '2 ', \\ '3': '3 ', \\ '4': '4 ', \\ '5': '5 ', \\ '6': '6 ', \\ '7': '7 ', \\ '8': '8 ', \\ '9': '9 ' \\}&quot; 设置切换tab的快捷键 &lt;\\&gt; + &lt;i&gt; 切换到第i个 tabnmap &lt;leader&gt;1 &lt;Plug&gt;AirlineSelectTab1nmap &lt;leader&gt;2 &lt;Plug&gt;AirlineSelectTab2nmap &lt;leader&gt;3 &lt;Plug&gt;AirlineSelectTab3nmap &lt;leader&gt;4 &lt;Plug&gt;AirlineSelectTab4nmap &lt;leader&gt;5 &lt;Plug&gt;AirlineSelectTab5nmap &lt;leader&gt;6 &lt;Plug&gt;AirlineSelectTab6nmap &lt;leader&gt;7 &lt;Plug&gt;AirlineSelectTab7nmap &lt;leader&gt;8 &lt;Plug&gt;AirlineSelectTab8nmap &lt;leader&gt;9 &lt;Plug&gt;AirlineSelectTab9&quot; 设置切换tab的快捷键 &lt;\\&gt; + &lt;-&gt; 切换到前一个 tabnmap &lt;leader&gt;- &lt;Plug&gt;AirlineSelectPrevTab&quot; 设置切换tab的快捷键 &lt;\\&gt; + &lt;+&gt; 切换到后一个 tabnmap &lt;leader&gt;+ &lt;Plug&gt;AirlineSelectNextTab&quot; 设置切换tab的快捷键 &lt;\\&gt; + &lt;q&gt; 退出当前的 tabnmap &lt;leader&gt;q :bp&lt;cr&gt;:bd #&lt;cr&gt;map &lt;tab&gt; :bn&lt;cr&gt; &quot;设置tab键映射&quot;map &lt;S-tab&gt; :bp&lt;cr&gt; &quot;设置tab键映射&quot;map &lt;S-q&gt; :bp\\|bd #&lt;cr&gt; &quot;关闭buffer&quot;&quot; =================================&quot; nerdcommenter&quot; =================================&quot;add spaces after comment delimiters by defaultlet g:NERDSpaceDelims = 1&quot; python 自动的会多加一个空格au FileType python let g:NERDSpaceDelims = 0&quot; Use compact syntax for prettified multi-line commentslet g:NERDCompactSexyComs = 1&quot; Align line-wise comment delimiters flush left instead of following code indentationlet g:NERDDefaultAlign = 'left'&quot; Set a language to use its alternate delimiters by defaultlet g:NERDAltDelims_java = 1&quot; 自定义格式&quot; let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }&quot; Allow commenting and inverting empty lines (useful when commenting a region)let g:NERDCommentEmptyLines = 1&quot; Enable trimming of trailing whitespace when uncommentinglet g:NERDTrimTrailingWhitespace = 1&quot; Enable NERDCommenterToggle to check all selected lines is commented or notlet g:NERDToggleCheckAllLines = 1&quot; =================================&quot; indentline&quot; =================================let g:indentLine_char='┆'let g:indentLine_enabled = 1&quot; =================================&quot; rainbow&quot; =================================let g:rainbow_active = 1let g:rainbow_conf = {\\ 'guifgs': ['darkorange3', 'seagreen3', 'royalblue3', 'firebrick'],\\ 'ctermfgs': ['lightyellow', 'lightcyan','lightblue', 'lightmagenta'],\\ 'operators': '_,_',\\ 'parentheses': ['start=/(/ end=/)/ fold', 'start=/\\[/ end=/\\]/ fold', 'start=/{/ end=/}/ fold'],\\ 'separately': {\\ '*': {},\\ 'tex': {\\ 'parentheses': ['start=/(/ end=/)/', 'start=/\\[/ end=/\\]/'],\\ },\\ 'lisp': {\\ 'guifgs': ['darkorange3', 'seagreen3', 'royalblue3', 'firebrick'],\\ },\\ 'vim': {\\ 'parentheses': ['start=/(/ end=/)/', 'start=/\\[/ end=/\\]/', 'start=/{/ end=/}/ fold', 'start=/(/ end=/)/ containedin=vimFuncBody', 'start=/\\[/ end=/\\]/ containedin=vimFuncBody', 'start=/{/ end=/}/ fold containedin=vimFuncBody'],\\ },\\ 'html': {\\ 'parentheses': ['start=/\\v\\&lt;((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ &gt;])@!\\z([-_:a-zA-Z0-9]+)(\\s+[-_:a-zA-Z0-9]+(\\=(&quot;[^&quot;]*&quot;|'.&quot;'&quot;.'[^'.&quot;'&quot;.']*'.&quot;'&quot;.'|[^ '.&quot;'&quot;.'&quot;&gt;&lt;=`]*))?)*\\&gt;/ end=#&lt;/\\z1&gt;# fold'],\\ },\\ 'css': 0,\\ }\\}&quot; =================================&quot; coc.nvim&quot; =================================let g:coc_global_extensions = [ \\ 'coc-json', \\ 'coc-vimlsp', \\ 'coc-tsserver', \\ 'coc-python', \\ 'coc-java', \\ 'coc-html', \\ 'coc-css', \\ 'coc-pairs', \\ 'coc-snippets', \\ 'coc-markdownlint', \\ 'coc-explorer', \\ 'coc-flutter-tools']set hiddenset updatetime=200set shortmess+=clet g:coc_snippet_next = '&lt;c-n&gt;'let g:coc_snippet_prev = '&lt;c-p&gt;'&quot; diagnostics appear/become resolved.if has(&quot;patch-8.1.1564&quot;) &quot; Recently vim can merge signcolumn and number column into one set signcolumn=numberelse set signcolumn=yesendif&quot; 让Tab键可以补全&quot; Use tab for trigger completion with characters ahead and navigate.&quot; NOTE: Use command ':verbose imap &lt;tab&gt;' to make sure tab is not mapped by&quot; other plugin before putting this into your config.inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt; \\ pumvisible() ? &quot;\\&lt;C-n&gt;&quot; : \\ &lt;SID&gt;check_back_space() ? &quot;\\&lt;TAB&gt;&quot; : \\ coc#refresh()inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\\&lt;C-p&gt;&quot; : &quot;\\&lt;C-h&gt;&quot;function! s:check_back_space() abort let col = col('.') - 1 return !col || getline('.')[col - 1] =~# '\\s'endfunction&quot; Ctrl+o 调出自动补全inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-o&gt; coc#refresh()&quot; Use &lt;cr&gt; to confirm completion, `&lt;C-g&gt;u` means break undo chain at current&quot; position. Coc only does snippet and additional edit on confirm.&quot; &lt;cr&gt; could be remapped by other vim plugin, try `:verbose imap &lt;CR&gt;`.if exists('*complete_info') inoremap &lt;expr&gt; &lt;cr&gt; complete_info()[&quot;selected&quot;] != &quot;-1&quot; ? &quot;\\&lt;C-y&gt;&quot; : &quot;\\&lt;C-g&gt;u\\&lt;CR&gt;&quot;else inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\\&lt;C-y&gt;&quot; : &quot;\\&lt;C-g&gt;u\\&lt;CR&gt;&quot;endif&quot; Use `[g` and `]g` to navigate diagnostics&quot; Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.nmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)nmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)&quot; GoTo code navigation.nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)&quot; Use K to show documentation in preview window.nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;function! s:show_documentation() if (index(['vim','help'], &amp;filetype) &gt;= 0) execute 'h '.expand('&lt;cword&gt;') else call CocAction('doHover') endifendfunction&quot; Highlight the symbol and its references when holding the cursor.autocmd CursorHold * silent call CocActionAsync('highlight')&quot; Symbol renaming.nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)&quot; Formatting selected code.xmap &lt;leader&gt;f &lt;Plug&gt;(coc-format-selected)nmap &lt;leader&gt;f &lt;Plug&gt;(coc-format-selected)augroup mygroup autocmd! &quot; Setup formatexpr specified filetype(s). autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected') &quot; Update signature help on jump placeholder. autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')augroup end&quot; Applying codeAction to the selected region.&quot; Example: `&lt;leader&gt;aap` for current paragraphxmap &lt;leader&gt;a &lt;Plug&gt;(coc-codeaction-selected)nmap &lt;leader&gt;a &lt;Plug&gt;(coc-codeaction-selected)&quot; Remap keys for applying codeAction to the current buffer.nmap &lt;leader&gt;ac &lt;Plug&gt;(coc-codeaction)&quot; Apply AutoFix to problem on the current line.nmap &lt;leader&gt;qf &lt;Plug&gt;(coc-fix-current)&quot; Map function and class text objects&quot; NOTE: Requires 'textDocument.documentSymbol' support from the language server.xmap if &lt;Plug&gt;(coc-funcobj-i)omap if &lt;Plug&gt;(coc-funcobj-i)xmap af &lt;Plug&gt;(coc-funcobj-a)omap af &lt;Plug&gt;(coc-funcobj-a)xmap ic &lt;Plug&gt;(coc-classobj-i)omap ic &lt;Plug&gt;(coc-classobj-i)xmap ac &lt;Plug&gt;(coc-classobj-a)omap ac &lt;Plug&gt;(coc-classobj-a)&quot; Use CTRL-S for selections ranges.&quot; Requires 'textDocument/selectionRange' support of LS, ex: coc-tsservernmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)xmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)&quot; Add `:Format` command to format current buffer.command! -nargs=0 Format :call CocAction('format')&quot; Add `:Fold` command to fold current buffer.command! -nargs=? Fold :call CocAction('fold', &lt;f-args&gt;)&quot; Add `:OR` command for organize imports of the current buffer.command! -nargs=0 OR :call CocAction('runCommand', 'editor.action.organizeImport')&quot; Add (Neo)Vim's native statusline support.&quot; NOTE: Please see `:h coc-status` for integrations with external plugins that&quot; provide custom statusline: lightline.vim, vim-airline.set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}&quot; Mappings for CoCList&quot; Show all diagnostics.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;a :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;&quot; Manage extensions.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;e :&lt;C-u&gt;CocList extensions&lt;cr&gt;&quot; Show commands.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;c :&lt;C-u&gt;CocList commands&lt;cr&gt;&quot; Find symbol of current document.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;o :&lt;C-u&gt;CocList outline&lt;cr&gt;&quot; Search workspace symbols.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;s :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;&quot; Do default action for next item.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;j :&lt;C-u&gt;CocNext&lt;CR&gt;&quot; Do default action for previous item.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;k :&lt;C-u&gt;CocPrev&lt;CR&gt;&quot; Resume latest coc list.nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;p :&lt;C-u&gt;CocListResume&lt;CR&gt;","link":"/2020/12/17/linux-vim01-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"算法--学习算法很简单","text":"很多非科班和科班的朋友看到算法就头疼，因为这东西学起来困难，也不常用，唯二的两个做用，面试和装B，一个能赚钱，一个能爽，但是学习路线太过陡峭，不是不想学，而是感觉入地无门。其实凡事都有技巧，难是因为不够了解它，就好像追不到女孩子其实不是你不够好，而是你不够了解对方。当然，开篇严肃一些，后面会慢慢把一些不容易理解的，化繁为简，包教包会，不会不退学费，本来也没人给我钱^.^。 一、数据结构和算法数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 数据结构在计算机科学界至今没有标准的定义。个人根据各自的理解的不同而有不同的表述方法：Sartaj Sahni在他的《数据结构、算法与应用》一书中称：“数据结构是数据对象，以及存在于该对象的实例合组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。”他将数据对象（data object）定义为”一个数据对象是实例或值的集合”。Clifford A.Shaffer在《数据结构与算法分析》一书中的定义是：”数据结构是 ADT（抽象数据类型Abstract Data Type） 的物理实现。”例如数组、集合、栈、队列、树、图都是数据结构。 算法是在有限步骤内求解某一问题所使用的一组定义明确的规则。通俗点说，就是计算机解题的过程。在这个过程中，无论是形成解题思路还是编写程序，都是在实施某种算法。前者是推理实现的算法，后者是操作实现的算法。一个算法应该具有以下五个重要的特征： 有穷性： 一个算法必须保证执行有限步之后结束； 确切性： 算法的每一步骤必须有确切的定义； 输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件； 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； 可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。 二、问题规模就是所要解决的问题，它的规模。1+2+3 是一个规模1+2+3…+10 是一个规模问题规模与核心操作次数，决定了这个算法的复杂度。 三、时间复杂度 和 空间复杂度这两个概念应该是很多非科班出身的程序员最难理解的，网上很多文章都讲的太云里雾里，其实没有那么难，化繁为简的讲明白才有用。这两个概念就是的意义是什么才是关键，后面专门去说这两个概念。 q\u0003:\u001b\u001b\u001basfasdf\u0003\u0003\u0003\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u001b\u0003\u0003","link":"/2015/08/23/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"}],"tags":[{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"概念","slug":"概念","link":"/tags/%E6%A6%82%E5%BF%B5/"},{"name":"Reactor模型","slug":"Reactor模型","link":"/tags/Reactor%E6%A8%A1%E5%9E%8B/"},{"name":"幂等","slug":"幂等","link":"/tags/%E5%B9%82%E7%AD%89/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"spring gateway","slug":"spring-gateway","link":"/tags/spring-gateway/"},{"name":"路由","slug":"路由","link":"/tags/%E8%B7%AF%E7%94%B1/"},{"name":"RSA","slug":"RSA","link":"/tags/RSA/"},{"name":"安全通信","slug":"安全通信","link":"/tags/%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1/"},{"name":"加密","slug":"加密","link":"/tags/%E5%8A%A0%E5%AF%86/"},{"name":"容错","slug":"容错","link":"/tags/%E5%AE%B9%E9%94%99/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hadoop1.0","slug":"hadoop1-0","link":"/tags/hadoop1-0/"},{"name":"NameNode","slug":"NameNode","link":"/tags/NameNode/"},{"name":"map 任务","slug":"map-任务","link":"/tags/map-%E4%BB%BB%E5%8A%A1/"},{"name":"hadoop","slug":"hadoop","link":"/tags/hadoop/"},{"name":"业务","slug":"业务","link":"/tags/%E4%B8%9A%E5%8A%A1/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"molloc","slug":"molloc","link":"/tags/molloc/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"开辟","slug":"开辟","link":"/tags/%E5%BC%80%E8%BE%9F/"},{"name":"空类型指针","slug":"空类型指针","link":"/tags/%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"malloc","slug":"malloc","link":"/tags/malloc/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","link":"/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"静态代理","slug":"静态代理","link":"/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"虚拟化","slug":"虚拟化","link":"/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"tomcat","slug":"tomcat","link":"/tags/tomcat/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"checkout","slug":"checkout","link":"/tags/checkout/"},{"name":"git pull","slug":"git-pull","link":"/tags/git-pull/"},{"name":"用法","slug":"用法","link":"/tags/%E7%94%A8%E6%B3%95/"},{"name":"分支","slug":"分支","link":"/tags/%E5%88%86%E6%94%AF/"},{"name":"冲突","slug":"冲突","link":"/tags/%E5%86%B2%E7%AA%81/"},{"name":"取消跟踪","slug":"取消跟踪","link":"/tags/%E5%8F%96%E6%B6%88%E8%B7%9F%E8%B8%AA/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"注释","slug":"注释","link":"/tags/%E6%B3%A8%E9%87%8A/"},{"name":"问题","slug":"问题","link":"/tags/%E9%97%AE%E9%A2%98/"},{"name":"解决","slug":"解决","link":"/tags/%E8%A7%A3%E5%86%B3/"},{"name":"编译","slug":"编译","link":"/tags/%E7%BC%96%E8%AF%91/"},{"name":"设置","slug":"设置","link":"/tags/%E8%AE%BE%E7%BD%AE/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"List","slug":"List","link":"/tags/List/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"final","slug":"final","link":"/tags/final/"},{"name":"hibernate","slug":"hibernate","link":"/tags/hibernate/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"竞态条件","slug":"竞态条件","link":"/tags/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6/"},{"name":"对象","slug":"对象","link":"/tags/%E5%AF%B9%E8%B1%A1/"},{"name":"引用级别","slug":"引用级别","link":"/tags/%E5%BC%95%E7%94%A8%E7%BA%A7%E5%88%AB/"},{"name":"抽象","slug":"抽象","link":"/tags/%E6%8A%BD%E8%B1%A1/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"有状态","slug":"有状态","link":"/tags/%E6%9C%89%E7%8A%B6%E6%80%81/"},{"name":"无状态","slug":"无状态","link":"/tags/%E6%97%A0%E7%8A%B6%E6%80%81/"},{"name":"报错","slug":"报错","link":"/tags/%E6%8A%A5%E9%94%99/"},{"name":"异常","slug":"异常","link":"/tags/%E5%BC%82%E5%B8%B8/"},{"name":"nio","slug":"nio","link":"/tags/nio/"},{"name":"概述","slug":"概述","link":"/tags/%E6%A6%82%E8%BF%B0/"},{"name":"socket","slug":"socket","link":"/tags/socket/"},{"name":"通信","slug":"通信","link":"/tags/%E9%80%9A%E4%BF%A1/"},{"name":"jar","slug":"jar","link":"/tags/jar/"},{"name":"打包","slug":"打包","link":"/tags/%E6%89%93%E5%8C%85/"},{"name":"war","slug":"war","link":"/tags/war/"},{"name":"死锁","slug":"死锁","link":"/tags/%E6%AD%BB%E9%94%81/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"页面静态化","slug":"页面静态化","link":"/tags/%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96/"},{"name":"freemarker","slug":"freemarker","link":"/tags/freemarker/"},{"name":"进程线","slug":"进程线","link":"/tags/%E8%BF%9B%E7%A8%8B%E7%BA%BF/"},{"name":"进程","slug":"进程","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"lock锁","slug":"lock锁","link":"/tags/lock%E9%94%81/"},{"name":"Condition 操作","slug":"Condition-操作","link":"/tags/Condition-%E6%93%8D%E4%BD%9C/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"原理","slug":"原理","link":"/tags/%E5%8E%9F%E7%90%86/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"收集器","slug":"收集器","link":"/tags/%E6%94%B6%E9%9B%86%E5%99%A8/"},{"name":"GC","slug":"GC","link":"/tags/GC/"},{"name":"垃圾回收","slug":"垃圾回收","link":"/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"name":"Parallel Scavenge","slug":"Parallel-Scavenge","link":"/tags/Parallel-Scavenge/"},{"name":"分代","slug":"分代","link":"/tags/%E5%88%86%E4%BB%A3/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"对象的创建","slug":"对象的创建","link":"/tags/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"},{"name":"循环引用","slug":"循环引用","link":"/tags/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"},{"name":"client 模式","slug":"client-模式","link":"/tags/client-%E6%A8%A1%E5%BC%8F/"},{"name":"server 模式","slug":"server-模式","link":"/tags/server-%E6%A8%A1%E5%BC%8F/"},{"name":"局部变量表","slug":"局部变量表","link":"/tags/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"CommandLineRunner","slug":"CommandLineRunner","link":"/tags/CommandLineRunner/"},{"name":"问题解决","slug":"问题解决","link":"/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"pagehelper报错","slug":"pagehelper报错","link":"/tags/pagehelper%E6%8A%A5%E9%94%99/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"ConfigurationProperties注解","slug":"ConfigurationProperties注解","link":"/tags/ConfigurationProperties%E6%B3%A8%E8%A7%A3/"},{"name":"Import注解","slug":"Import注解","link":"/tags/Import%E6%B3%A8%E8%A7%A3/"},{"name":"jar包","slug":"jar包","link":"/tags/jar%E5%8C%85/"},{"name":"srping boot","slug":"srping-boot","link":"/tags/srping-boot/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"aop","slug":"aop","link":"/tags/aop/"},{"name":"日志","slug":"日志","link":"/tags/%E6%97%A5%E5%BF%97/"},{"name":"切面","slug":"切面","link":"/tags/%E5%88%87%E9%9D%A2/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"filter","slug":"filter","link":"/tags/filter/"},{"name":"过滤器","slug":"过滤器","link":"/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"ftp","slug":"ftp","link":"/tags/ftp/"},{"name":"yml","slug":"yml","link":"/tags/yml/"},{"name":"源码分析","slug":"源码分析","link":"/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"服务下线","slug":"服务下线","link":"/tags/%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF/"},{"name":"eureka","slug":"eureka","link":"/tags/eureka/"},{"name":"交换字符串","slug":"交换字符串","link":"/tags/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"LeetCode 解题思路","slug":"LeetCode-解题思路","link":"/tags/LeetCode-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"},{"name":"去重","slug":"去重","link":"/tags/%E5%8E%BB%E9%87%8D/"},{"name":"交换","slug":"交换","link":"/tags/%E4%BA%A4%E6%8D%A2/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"线程死锁","slug":"线程死锁","link":"/tags/%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"hashcode","slug":"hashcode","link":"/tags/hashcode/"},{"name":"equals","slug":"equals","link":"/tags/equals/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"broker","slug":"broker","link":"/tags/broker/"},{"name":"RocketMQ","slug":"RocketMQ","link":"/tags/RocketMQ/"},{"name":"NameServer","slug":"NameServer","link":"/tags/NameServer/"},{"name":"vim配置","slug":"vim配置","link":"/tags/vim%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"architecture","slug":"architecture","link":"/categories/architecture/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"bigdata","slug":"bigdata","link":"/categories/bigdata/"},{"name":"c&#x2F;c++","slug":"c-c","link":"/categories/c-c/"},{"name":"design","slug":"design","link":"/categories/design/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"spring","slug":"java/spring","link":"/categories/java/spring/"},{"name":"safe","slug":"architecture/safe","link":"/categories/architecture/safe/"},{"name":"mapreduce","slug":"bigdata/mapreduce","link":"/categories/bigdata/mapreduce/"},{"name":"pointer","slug":"c-c/pointer","link":"/categories/c-c/pointer/"},{"name":"proxy","slug":"design/proxy","link":"/categories/design/proxy/"},{"name":"tomcat","slug":"java/tomcat","link":"/categories/java/tomcat/"},{"name":"git","slug":"java/git","link":"/categories/java/git/"},{"name":"idea","slug":"java/idea","link":"/categories/java/idea/"},{"name":"spring boot","slug":"java/spring-boot","link":"/categories/java/spring-boot/"},{"name":"lambda","slug":"java/lambda","link":"/categories/java/lambda/"},{"name":"concurrent","slug":"java/concurrent","link":"/categories/java/concurrent/"},{"name":"nio","slug":"java/nio","link":"/categories/java/nio/"},{"name":"scoket","slug":"java/scoket","link":"/categories/java/scoket/"},{"name":"freemarker","slug":"java/freemarker","link":"/categories/java/freemarker/"},{"name":"jvm","slug":"java/jvm","link":"/categories/java/jvm/"},{"name":"shell","slug":"linux/shell","link":"/categories/linux/shell/"},{"name":"spring cloud","slug":"java/spring-cloud","link":"/categories/java/spring-cloud/"},{"name":"栈","slug":"algorithm/栈","link":"/categories/algorithm/%E6%A0%88/"},{"name":"leetcode","slug":"algorithm/leetcode","link":"/categories/algorithm/leetcode/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"RocketMQ","slug":"RocketMQ","link":"/categories/RocketMQ/"},{"name":"概念","slug":"architecture/概念","link":"/categories/architecture/%E6%A6%82%E5%BF%B5/"},{"name":"interview","slug":"interview","link":"/categories/interview/"},{"name":"多线程","slug":"interview/多线程","link":"/categories/interview/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"面向对象","slug":"interview/面向对象","link":"/categories/interview/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"vim","slug":"linux/vim","link":"/categories/linux/vim/"}]}